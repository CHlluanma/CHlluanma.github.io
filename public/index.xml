<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Beautiful Hugo</title>
    <link>https://ahang7.github.io/</link>
    <description>Recent content on Beautiful Hugo</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>ch1447571882@qq.com (ch)</managingEditor>
    <webMaster>ch1447571882@qq.com (ch)</webMaster>
    <lastBuildDate>Thu, 31 Oct 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ahang7.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[go-rpc] 从零搭建rpc框架</title>
      <link>https://ahang7.github.io/backend-project/go-rpc/1.-rpc-basic/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/backend-project/go-rpc/1.-rpc-basic/</guid>
      <description>&lt;h2 id=&#34;rpc-基础&#34;&gt;RPC 基础&lt;/h2&gt;&#xA;&lt;p&gt;RPC（Remote Procedure Call），即远程过程调用。，允许计算机调用另外一台远程计算机上的程序&lt;/p&gt;</description>
    </item>
    <item>
      <title>[kv存储引擎] golang实现</title>
      <link>https://ahang7.github.io/backend-project/bit-db/kv%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/backend-project/bit-db/kv%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>&lt;h2 id=&#34;1-kv基础&#34;&gt;1. KV基础&lt;/h2&gt;&#xA;&lt;p&gt;KV存储，即键值数据存储，是一种基于键值对的存储方式，将数据存储为一个由键和值组成的二元组&lt;/p&gt;&#xA;&lt;p&gt;KC存储的应用场景：作数据库的缓存层、分布式系统中的元数据、分布式锁&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;最常见的KV数据库是Redis，Redis是基于内存的KV数据库，虽有持久化策略AOF和RDB，但是本质上还是面向内存设计的，数据收到内存的限制&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;而本项目&lt;code&gt;go-bitDB&lt;/code&gt;是面向磁盘的KV数据库&lt;/p&gt;&#xA;&lt;p&gt;KV数据库的数据存储模型大致分为两种，一个B+树，一个是LSM树&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;B+树：BolitDB&lt;/li&gt;&#xA;&lt;li&gt;LSM树：LevelDB、RocksDB&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-了解bitcask存储模型&#34;&gt;2. 了解bitcask存储模型&lt;/h2&gt;&#xA;&lt;p&gt;[[bitcask-intro.pdf]]&lt;/p&gt;&#xA;&lt;p&gt;bitcask存储模型是由提供分布式存储系统的企业Riak提出&#xA;对bitcask存储模型的理想：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读写低延迟&lt;/li&gt;&#xA;&lt;li&gt;高吞吐，特别对大量的随机写入&lt;/li&gt;&#xA;&lt;li&gt;能处理超过内存容量的数据&lt;/li&gt;&#xA;&lt;li&gt;崩溃恢复好，保证快速恢复，进来不丢失数据&lt;/li&gt;&#xA;&lt;li&gt;简单的备份和恢复策略&lt;/li&gt;&#xA;&lt;li&gt;相对简单，易懂的代码结构和数据存储格式&lt;/li&gt;&#xA;&lt;li&gt;在大数据量下，性能有保障&lt;/li&gt;&#xA;&lt;li&gt;能够自由使用在Riak系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;一个bitcask实例就是系统上的一个目录，并且限制同一时刻只能有一个进程打开这个目录。&#xA;目录中多个文件同一个刻只能有一个活跃的文件用于写入新的数据&lt;/p&gt;&#xA;&lt;p&gt;当活跃文件写到一个阈值后，就会被关闭，成为旧的数据文件，并打开一个新的文件用于写入&#xA;所以一个目录里面就是：一个活跃文件和多个旧文件&lt;/p&gt;&#xA;&lt;p&gt;当前活跃文件的写入是追加(append only)，这表示可以利用顺序IO，不会有多余的磁盘寻址，减少了磁盘寻道实践，最大限度保证吞吐&lt;/p&gt;&#xA;&lt;p&gt;写入文件的数据格式，其字段为&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;crc&lt;/code&gt;：数据校验，防止数据被破环、篡改&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt;：写入数据的时间戳&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ksz&lt;/code&gt;：key size，key的大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;value_sz&lt;/code&gt;：value size，value的大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;key&lt;/code&gt;：用户实际存储的key&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;value&lt;/code&gt;：用户实际存储的value&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;crc | tstamp | ksz | value_sz | key | value&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次写入都是追加到活跃文件中，删除操作实际上也是一次追加写入&lt;/p&gt;&#xA;&lt;p&gt;当下次merge的时候，才会将这种无效的数据清理。旧数据在merge前将一直存在于磁盘文件中，旧数据的删除操作是新追加一条标识其被删除的记录&lt;/p&gt;&#xA;&lt;p&gt;在追加写入磁盘文件后，更新内存中的数据结构，叫&lt;code&gt;keydir&lt;/code&gt;，实际是全部key的一个集合，存储的是key到一条磁盘文件数据的位置&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;keydir&lt;/code&gt;根据需求可以使用哈希表、B树、跳表等天然支持排序的数据结构&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;key --&amp;gt; file_id | value_sz | value_pos | tstamp&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;key --&amp;gt; file_id | value_sz | value_pos | tstamp&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;......&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;key --&amp;gt; file_id | value_sz | value_pos | tstamp&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;keydir&lt;/code&gt;在内存中存储一条数据在磁盘中的最新位置，旧数据等待merge的时候清理&lt;/p&gt;</description>
    </item>
    <item>
      <title>[makefile] makefile学习笔记</title>
      <link>https://ahang7.github.io/post/basic/middlewares/makefile/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/middlewares/makefile/</guid>
      <description>&lt;p&gt;learn form &lt;a href=&#34;https://blog.csdn.net/haoel/article/details/2886&#34;&gt;(陈皓) 跟我一起写 Makefile（一）_haoel的博客-CSDN博客_makefile标签&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://zhuanlan.zhihu.com/p/47390641&#34;&gt;Makefile由浅入深&amp;ndash;教程、干货 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;code&gt;makefile&lt;/code&gt; 关系到了整个工程的编译规则，&lt;code&gt;makefile&lt;/code&gt; 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件后需要编译，哪些文件需要重新编译，甚者进行更复杂的功能操作，&lt;code&gt;makefile&lt;/code&gt; 像 &lt;code&gt;shell&lt;/code&gt;脚本一样，其中也可以执行操作系统的命令。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;makefile&lt;/code&gt;带来的好处是-“自动化编译”，一旦写好，一个&lt;code&gt;make&lt;/code&gt;命令，整个工程完全自动编译，极大提高了软件开发的效率。&lt;code&gt;make&lt;/code&gt;是一个命令工具，是一个解释&lt;code&gt;makefile&lt;/code&gt;中指令的命令工具。&lt;/p&gt;&#xA;&lt;h2 id=&#34;makefile结构说明&#34;&gt;Makefile结构说明&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;code&gt;makefile&lt;/code&gt; 主要包含了五个东西：变量定义，显示规则，隐晦规则，文件标示和注释。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;变量定义。在&lt;code&gt;makefile&lt;/code&gt;中我们需要定义一系列的变量，一般是字符串，当&lt;code&gt;makefile&lt;/code&gt;被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;显示规则。说明了如何生成一个或者多个目标文件，由&lt;code&gt;makefile&lt;/code&gt;的书写者明显指出，要生成的文件，文件的依赖文件，生成的文件。【可类似&lt;code&gt;shell&lt;/code&gt;脚本】&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;隐晦规则。由于make有自动推导功能，使用隐晦的规则可以让我们比较粗糙地简略书写&lt;code&gt;makefile&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;文件指示。其中包括了三个部分。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;注释。&lt;code&gt;Makefile&lt;/code&gt;中只有行注释，使用 &lt;code&gt;#&lt;/code&gt; 字符&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;makefile中的预定义变量&#34;&gt;Makefile中的预定义变量&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;$* 　　不包含扩展名的目标文件名称。&lt;/p&gt;&#xA;&lt;p&gt;$+ 　　所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。&lt;/p&gt;&#xA;&lt;p&gt;$&amp;lt; 　　第一个依赖文件的名称。&lt;/p&gt;&#xA;&lt;p&gt;$? 　　所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。&lt;/p&gt;&#xA;&lt;p&gt;$@ 　 目标的完整名称。&lt;/p&gt;&#xA;&lt;p&gt;$^ 　　所有的依赖文件，以空格分开，不包含重复的依赖文件。&lt;/p&gt;&#xA;&lt;p&gt;$% 如果目标是归档成员，则该变量表示目标的归档成员名称。&lt;/p&gt;&#xA;&lt;h2 id=&#34;go-makefile&#34;&gt;Go Makefile&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;使用&lt;code&gt;makefile&lt;/code&gt;快速编译Go web程序，期望：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;高级、简单的命令。比如：&lt;code&gt;compile&lt;/code&gt; &lt;code&gt;start&lt;/code&gt; &lt;code&gt;stop&lt;/code&gt; &lt;code&gt;watch&lt;/code&gt; 等等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;管理具体项目环境的变量，它应该包含 &lt;code&gt;.env&lt;/code&gt; 文件&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;开发模式，修改时自动编译&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;开发模式，修改时自动重启服务&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;开发模式，简洁地显示编译的错误信息&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;具体项目的GOPATH，可以在&lt;code&gt;vendor&lt;/code&gt;目录维护依赖包&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;简化文件查看，&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;1环境变量&#34;&gt;1、环境变量&lt;/h4&gt;&#xA;&lt;p&gt;在&lt;code&gt;makefile&lt;/code&gt;中 &lt;code&gt;include&lt;/code&gt;为项目定义环境变量，第一行如下&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Plaintext&#34; data-lang=&#34;Plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;include .env&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;^^^&lt;/p&gt;&#xA;&lt;p&gt;…………&lt;/p&gt;&#xA;&lt;h4 id=&#34;final最终版本&#34;&gt;final.最终版本&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Plaintext&#34; data-lang=&#34;Plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;include .env&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PROJECTNAME=$(shell basename &amp;#34;$(PWD)&amp;#34;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Go related variables.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GOBASE=$(shell pwd)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GOPATH=&amp;#34;$(GOBASE)/vendor:$(GOBASE)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GOBIN=$(GOBASE)/bin&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GOFILES=$(wildcard *.go)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Redirect error output to a file, so we can show it in development mode.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;STDERR=/tmp/.$(PROJECTNAME)-stderr.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# PID file will keep the process id of the server&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PID=/tmp/.$(PROJECTNAME).pid&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Make is verbose in Linux. Make it silent.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;MAKEFLAGS += --silent&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## install: Install missing dependencies. Runs `go get` internally. e.g; make install get=github.com/foo/bar&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;install: go-get&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## start: Start in development mode. Auto-starts when code changes.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;start:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    bash -c &amp;#34;trap &amp;#39;make stop&amp;#39; EXIT; $(MAKE) compile start-server watch run=&amp;#39;make compile start-server&amp;#39;&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## stop: Stop development mode.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;stop: stop-server&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;start-server: stop-server&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  $(PROJECTNAME) is available at $(ADDR)&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-$(GOBIN)/$(PROJECTNAME) 2&amp;gt;&amp;amp;1 &amp;amp; echo $$! &amp;gt; $(PID)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @cat $(PID) | sed &amp;#34;/^/s/^/  \&amp;gt;  PID: /&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;stop-server:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-touch $(PID)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-kill `cat $(PID)` 2&amp;gt; /dev/null || true&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-rm $(PID)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## watch: Run given command when code changes. e.g; make watch run=&amp;#34;echo &amp;#39;hey&amp;#39;&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;watch:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) yolo -i . -e vendor -e bin -c &amp;#34;$(run)&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;restart-server: stop-server start-server&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## compile: Compile the binary.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;compile:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-touch $(STDERR)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-rm $(STDERR)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-$(MAKE) -s go-compile 2&amp;gt; $(STDERR)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @cat $(STDERR) | sed -e &amp;#39;1s/.*/\nError:\n/&amp;#39;  | sed &amp;#39;s/make\[.*/ /&amp;#39; | sed &amp;#34;/^/s/^/     /&amp;#34; 1&amp;gt;&amp;amp;2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## exec: Run given command, wrapped with custom GOPATH. e.g; make exec run=&amp;#34;go test ./...&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;exec:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) $(run)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## clean: Clean build files. Runs `go clean` internally.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;clean:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @(MAKEFILE) go-clean&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-compile: go-clean go-get go-build&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-build:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  Building binary...&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go build -o $(GOBIN)/$(PROJECTNAME) $(GOFILES)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-generate:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  Generating dependency files...&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go generate $(generate)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-get:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  Checking if there is any missing dependencies...&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go get $(get)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-install:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go install $(GOFILES)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-clean:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  Cleaning build cache&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go clean&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.PHONY: help&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;all: help&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;help: Makefile&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34; Choose a command run in &amp;#34;$(PROJECTNAME)&amp;#34;:&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @sed -n &amp;#39;s/^##//p&amp;#39; $&amp;lt; | column -t -s &amp;#39;:&amp;#39; |  sed -e &amp;#39;s/^/ /&amp;#39;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL逻辑架构</title>
      <link>https://ahang7.github.io/post/basic/mysql/6.-mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/6.-mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;h2 id=&#34;61-sql执行过程&#34;&gt;6.1 SQL执行过程&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84&#34;&gt;https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;MySQL架构分为两层：&lt;strong&gt;server层和存储引擎层&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Server层负责建立连接、分析和执行SQL&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MySQL大多数核心功能模块都在这里：连接器、查询缓存、解析器、预处理器、优化器、执行器等&lt;/li&gt;&#xA;&lt;li&gt;还有所有的内置函数&lt;/li&gt;&#xA;&lt;li&gt;所有跨存储引擎的功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;存储引擎层负责数据的存储和提取&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持InnoDB、MyISAM、Memory等多个存储引擎&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;611-连接器&#34;&gt;6.1.1 连接器&lt;/h3&gt;&#xA;&lt;p&gt;MySQL是基于TCP协议进行传输的，所以在连接MySQL的时候需要先进行TCP三次握手，在命令行使用命令进行连接&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mysql -h &lt;span class=&#34;nv&#34;&gt;$ip&lt;/span&gt; -u&lt;span class=&#34;nv&#34;&gt;$user&lt;/span&gt; -p&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户通过用户密码成功连接后，连接器会获取用户的权限，然后保存起来，在后续的此连接的任何操作，都会基于连接开始的时候读取到的权限逻辑进行判断&lt;/p&gt;&#xA;&lt;p&gt;建立连接后，即使修改了该用户的权限，也不影响已连接的权限。只有新建的连接才会有新的权限设置&lt;/p&gt;&#xA;&lt;h4 id=&#34;6111-查看mysql服务的客户端连接&#34;&gt;6.1.1.1 查看MySQL服务的客户端连接&lt;/h4&gt;&#xA;&lt;p&gt;可以执行&lt;code&gt;show processlist&lt;/code&gt; 命令进行查看&lt;/p&gt;&#xA;&lt;h4 id=&#34;6112-空闲连接会一直占着&#34;&gt;6.1.1.2 空闲连接会一直占着&lt;/h4&gt;&#xA;&lt;p&gt;不会，MySQL定义了空闲连接的最大空闲时长，由&lt;code&gt;wait_timeout&lt;/code&gt; 参数控制，默认值是8小时，超过这个时间，连接器就会把这个连接断开&lt;/p&gt;&#xA;&lt;p&gt;使用命令可以查看该值&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;show variables like &lt;span class=&#34;s1&#34;&gt;&amp;#39;wait_timeout&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以手动断开空闲的连接，使用的是&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;kill&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;connection&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当空闲的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求时，才会收到报错&lt;/p&gt;&#xA;&lt;p&gt;“ERROR 2013 (HY000): Lost connection to MySQL server during query”&lt;/p&gt;&#xA;&lt;h4 id=&#34;6113-mysql的连接限制&#34;&gt;6.1.1.3 MySQL的连接限制&lt;/h4&gt;&#xA;&lt;p&gt;MySQL服务支持的最大连接数由&lt;code&gt;max_connections&lt;/code&gt; 参数控制&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;show variables like &lt;span class=&#34;s1&#34;&gt;&amp;#39;max_connections&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;MySQL的连接跟HTTP一样，有短连接和长连接的概念&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;短连接&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;连接&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;服务（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;三次握手）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;执行&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;断开&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;服务（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;四次挥手）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;长连接&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;连接&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;服务（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;三次握手）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;执行&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;执行&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;执行&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;断开&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;服务（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;四次挥手）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般推荐长连接，但是使用长连接可能会占用内存增多，因为_MySQL在执行查询过程中临时使用内存管理连接对象__，_只有在连接断开的时候才会释放&lt;/p&gt;</description>
    </item>
    <item>
      <title>[wrk] http压测工具</title>
      <link>https://ahang7.github.io/post/basic/middlewares/http%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7wrk/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/middlewares/http%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7wrk/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;使用方法&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wrk&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;选项&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;被测HTTP服务的URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;                           &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;                                           &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;connections&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;跟服务器建立并保持的TCP连接数量&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;duration&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;压测时间&lt;/span&gt;          &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;threads&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;使用多少个线程进行压测&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;压测时&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;是有一个主线程来控制我们设置的n个子线程间调度&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                                    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;script&lt;/span&gt;      &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;指定Lua脚本路径&lt;/span&gt;      &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;header&lt;/span&gt;      &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;为每一个HTTP请求添加HTTP头&lt;/span&gt;     &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;latency&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;在压测结束后&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;打印延迟统计信息&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;超时时间&lt;/span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;version&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;打印正在使用的wrk的详细版本信&lt;/span&gt;                                              &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;代表数字参数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;支持国际单位&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;代表时间参数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;支持时间单位&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>[计网] HTTP</title>
      <link>https://ahang7.github.io/post/basic/network/3.-http/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/network/3.-http/</guid>
      <description>&lt;p&gt;接下来将从以下6个方面，逐渐学习和了解HTTP&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;HTTP基本概念&lt;/li&gt;&#xA;&lt;li&gt;Get与Post&lt;/li&gt;&#xA;&lt;li&gt;HTTP特征&lt;/li&gt;&#xA;&lt;li&gt;HTTP缓存&lt;/li&gt;&#xA;&lt;li&gt;HTTPS与HTTP&lt;/li&gt;&#xA;&lt;li&gt;HTTP/1.1、HTTP/2、HTTP/3演变&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YzgxNTk2MGIwMjM0ODdhZWNiYjM1YTdhNTM0NTMwOTJfaDdMekY5THZXQ0plelVaR2lCV1ZWWGptTUZISUMzcElfVG9rZW46TU5pOWJ0elBEbzVIa0p4bzdvTGM1N1VybkxoXzE3MjE4Mzk5Nzc6MTcyMTg0MzU3N19WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;http基本概念&#34;&gt;&lt;strong&gt;HTTP基本概念&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1http是什么&#34;&gt;&lt;strong&gt;1.HTTP是什么？&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;HTTP是超文本传输协议，也就是&lt;strong&gt;HyperText&lt;/strong&gt; &lt;strong&gt;Transfer Protocol&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;HTTP的名字【超文本传输协议】，可以拆成三个部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;超文本&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;传输&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;协议&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MWVjMWE4ZmI3M2M3YjczMWRmMDE3OWVmZjUwYTE0ODBfRXhVcm5qbEUxNlZaVGpid3I5Z25sQTJzV1ZlSVpGUTdfVG9rZW46UHhGZGJVNFI2b25hWDl4TmlsS2NoaVI2bjJpXzE3MjE4Mzk5Nzc6MTcyMTg0MzU3N19WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;针对 HTTP &lt;strong&gt;协议&lt;/strong&gt;，我们可以这么理解。&lt;/p&gt;&#xA;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;「协议」&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;HTTP 是一个用在计算机世界里的&lt;strong&gt;协议&lt;/strong&gt;。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（&lt;strong&gt;两个以上的参与者&lt;/strong&gt;），以及相关的各种控制和错误处理方式（&lt;strong&gt;行为约定和规范&lt;/strong&gt;）。&lt;/p&gt;&#xA;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;「传输」&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;HTTP 协议是一个&lt;strong&gt;双向协议&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;针对&lt;strong&gt;传输&lt;/strong&gt;，我们可以进一步理解了 HTTP。&lt;/p&gt;&#xA;&lt;p&gt;HTTP 是一个在计算机世界里专门用来在&lt;strong&gt;两点之间传输数据&lt;/strong&gt;的约定和规范。&lt;/p&gt;&#xA;&lt;ol start=&#34;9&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;「超文本」&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;HTTP 传输的内容是「超文本」。&lt;/p&gt;&#xA;&lt;p&gt;理解「超文本」，它就是&lt;strong&gt;超越了普通文本的文本&lt;/strong&gt;，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;HTTP是用于从互联网服务器传输超文本到本地浏览器的协议，这个说法是错误的，因为HTTP也可以服务于【服务器&amp;lt;&amp;mdash;&amp;gt;服务器】，所有采用&lt;strong&gt;两点之间&lt;/strong&gt;的描述比较准确&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;2http常见的状态码&#34;&gt;&lt;strong&gt;2.HTTP常见的状态码&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NzMzNjU4MzA0ZWM3ZGY0ZWRjM2MzOWQyMzA1NmIyMjJfN01YaTBhejQ1RVlOMFdWcWphQXNXaHNLYUhGekNOWFdfVG9rZW46WFRQcGJWUWdBb1VYdVp4YmM2ZWNWdmd0bnJjXzE3MjE4Mzk5Nzc6MTcyMTg0MzU3N19WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;1xx&lt;/code&gt; 类状态码属于&lt;strong&gt;提示信息&lt;/strong&gt;，是协议处理中的一种中间状态，实际用到的比较少。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;2xx&lt;/code&gt; 类状态码表示服务器&lt;strong&gt;成功&lt;/strong&gt;处理了客户端的请求，也是我们最愿意看到的状态。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;「&lt;strong&gt;200 OK&lt;/strong&gt;」是最常见的成功状态码，表示一切正常。如果是非 &lt;code&gt;HEAD&lt;/code&gt; 请求，服务器返回的响应头都会有 body 数据。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;「&lt;strong&gt;204 No Content&lt;/strong&gt;」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;「&lt;strong&gt;206 Partial Content&lt;/strong&gt;」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;3xx&lt;/code&gt; 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是&lt;strong&gt;重定向&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;「&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[计网] TCP/IP网络模型</title>
      <link>https://ahang7.github.io/post/basic/network/1.-tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/network/1.-tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/network/1_base/tcp_ip_model.html&#34;&gt;2.1 TCP/IP 网络模型有哪几层？&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;21-tcpip网络模型&#34;&gt;2.1 TCP/IP网络模型&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;前言：为什么要有TCP/IP网络模型？&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;答：为了提供一套 &lt;strong&gt;通用的****网络协议&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;因为在一台设备上的进程间通信有很多方式，比如管道、消息队列、共享内存、信号等方式，而对于不同的设备上的进程间通信，就需要网络通信，而设备是多样性的，需要兼容多种多样的设备，就需要一套 &lt;code&gt;通用的网络协议&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;这个网络协议是分层的，每一层都有各自的作用和责任&lt;/p&gt;&#xA;&lt;p&gt;TCP/IP网络模型分为4层：应用层&amp;ndash;&amp;gt;传输层&amp;ndash;&amp;gt;网络层&amp;ndash;&amp;gt;网络接口层(由上到下)&lt;/p&gt;&#xA;&lt;p&gt;接下来根据 [TCP/IP 网络模型 ]分别对每一层进行介绍：&lt;/p&gt;&#xA;&lt;h3 id=&#34;应用层最上层&#34;&gt;&lt;strong&gt;应用层（最上层）&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;最上层的，也是我们能直接接触到的就是&lt;strong&gt;应用层&lt;/strong&gt;(Application Layer)，我们使用的应用软件都是在应用层实现的，当两台不同的设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是&lt;strong&gt;传输层&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;接收数据后把数据传入&lt;strong&gt;传输层&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;所以，&lt;strong&gt;应用层&lt;/strong&gt;只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等&lt;/p&gt;&#xA;&lt;p&gt;应用层不用关心数据是如何传输&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;是工作在操作系统的用户态，&lt;strong&gt;传输层****及其一下&lt;/strong&gt;则工作在内核态&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;传输层&#34;&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;的数据包会传输到传输层，&lt;strong&gt;传输层&lt;/strong&gt;(Transport Layer) 是为应用层提供网络支持&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTM5NGVmNjMyYmZhOTE2Y2JiZTlhZjRkMzJhMGU4NTVfM3F5dVFqUnppQzA2cXFoQ2F6c1RwdVlpa3QzR0U2N3lfVG9rZW46RTgwT2JPenk5b1VQaW14Y1pFY2NkYTBmbmtoXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在&lt;strong&gt;传输层&lt;/strong&gt;会有两个传输协议，分别为&lt;code&gt;TCP&lt;/code&gt;和&lt;code&gt;UDP&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;的全称是“传输控制协议”(Transmission Control Protocol)，大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;有很多特征：流量控制、超时重传、拥塞控制等，这些保证了数据包能可靠地传输给对方&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;相对来说比较协议，简单到&lt;strong&gt;只负责发送数据包&lt;/strong&gt;，不保证数据包是否能抵达对方，但是实时性相对更好，传输效率也高。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;也可以实现可靠传输，把&lt;strong&gt;TCP&lt;/strong&gt;的特性在应用层上实现就行，（不过要实现一个商用的可靠UDP传输协议也不简单）&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过&lt;strong&gt;MSS&lt;/strong&gt;（TCP最大报文段长度），就要将数据包分块，这样即使在传输过程中一个分块缺失或者损坏了，只需要重新发送这一分开，而不用重新发送整个数据包。&lt;/p&gt;&#xA;&lt;p&gt;在TCP协议中，每一个分块称为一个&lt;strong&gt;TCP段&lt;/strong&gt;(TCP Segment)&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTE4YjBkOWU1ZTVlYmViZDkxNDQ1NTFmYWZkMTQzMTFfNllQajladEFQVERJUDFNWUZHNWxZRGVaWFZoanVZeE9fVG9rZW46VG5ZM2JrUzVGb1ZrN1N4UkF5b2NMdW5KbmZrXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当设备作为接收方时，传输层则要负责把数据包传给应用层，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要一个编号将应用区分开来，这个编号就是&lt;strong&gt;端口&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。&lt;/p&gt;&#xA;&lt;p&gt;由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;并不负责将数据从一个设备传输到另一个设备&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;网络层&#34;&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;在实际场景中，一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，其中的网络环节是错综复杂的。而&lt;strong&gt;传输层&lt;/strong&gt;的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则&lt;/p&gt;&#xA;&lt;p&gt;我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是&lt;strong&gt;网络层&lt;/strong&gt;(Internet Layer)&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBiZTU5ZmFlMmQyNGNiYzdkMTA1M2YxNmZmNmMwYjhfeUhWM2IyVzAxbWdwdHZud0N3eWtsbVdDbHZoMGNiR1RfVG9rZW46RmIxTWJ2TEF6b1RaZU94S29SRmNIazNRbnJFXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;个人理解：应用层把大量的数据发送给传输层，传输层将这些大量的数据进行打包，分段，确定好目的应用，然后由网络层进行传输。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;最常用的是&lt;strong&gt;IP协议&lt;/strong&gt;(Internet Protocol)，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成&lt;strong&gt;IP报文&lt;/strong&gt;，如果IP报文大小超过了&lt;strong&gt;MTU&lt;/strong&gt;(以太网中一般为1500字节)就会&lt;strong&gt;再次进行分片&lt;/strong&gt;，得到一个继续发送网络的IP报文&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBhODFlM2VmZWRiYWI5MTYyOTdjY2Q3NTlmNGQ4OTNfMWhGUGlQbmszY2FmYnhmYlhUU1dHTGw3VmxEU0JXV3pfVG9rZW46WnFoWmJwM09Ub2F6VDV4ek5FMGN6dnY3bmpmXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;负责将数据从一个设备传输到另一个设备，但是世界上那么多设备，如何找到对方呢，因此，网络层需要有区分设备的编号&lt;/p&gt;&#xA;&lt;p&gt;一般用&lt;strong&gt;IP地址&lt;/strong&gt;给设备进行编号，对于IPv4协议，IP地址共32位，分成了四段（比如127.0.0.1，分成四段，每段8位）。但是寻址起来特别麻烦，不能一个一个去匹配。&lt;/p&gt;&#xA;&lt;p&gt;因此，需要将IP地址分成两种意义：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个是&lt;strong&gt;网络号&lt;/strong&gt;，负责标识该IP地址是属于那个[ 子网 ]的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个是&lt;strong&gt;主机号&lt;/strong&gt;，负责标识同一[ 子网 ]下的不同主机&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;怎么区分&lt;strong&gt;网络号&lt;/strong&gt;和&lt;strong&gt;主机号&lt;/strong&gt;呢？这需要配合&lt;strong&gt;子网掩码&lt;/strong&gt;才能算出IP地址的网络号和主机号&lt;/p&gt;&#xA;&lt;p&gt;举个例子，比如 10.100.122.0/24，后面的&lt;code&gt;/24&lt;/code&gt;表示就是 &lt;code&gt;255.255.255.0&lt;/code&gt; 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[计网] 键入网址的过程</title>
      <link>https://ahang7.github.io/post/basic/network/2.-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/network/2.-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;p&gt;面试题：【当键入网址后，到网页显示，期间发生了什么？&lt;/p&gt;&#xA;&lt;p&gt;下面一张较简单的网络拓扑模型作为例子，探究探究其间发生了什么？&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YWYxZjYxMTdhY2RlODA5Yzc5ZDJmNzdlNzM3ZWNkZThfYXpBSE8zNllUVmREclRrV0l5RmEyaXE4V0lodEh3enpfVG9rZW46TGxKMmJSWDlXb1dTUWN4RUJNd2NaZ0IyblhlXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;http&#34;&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;浏览器做的第一步工作是&lt;strong&gt;解析****URL&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;首先浏览器做的第一步工作就是要对&lt;code&gt;URL&lt;/code&gt;进行解析，从而生成发生给&lt;code&gt;Web&lt;/code&gt;服务器的请求信息&lt;/p&gt;&#xA;&lt;p&gt;在一条长长的URL里的各个元素的代表是什么&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ4MGEyMTY1MWRiNGE0MjliMjBhNTRhNmM3OTkwOWZfS0tDMENDOUNRb05hZkxXZ0JJNkZIZWRFTklGZDI5R1VfVG9rZW46RnF1TWJpVklTb0pUSUR4Njg3N2NMVGRvbkZlXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这里的URL实际上是请求服务器里的文件资源&lt;/p&gt;&#xA;&lt;p&gt;当上图的蓝色部分URL元素都省略了，那么请求的是哪个文件呢？&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;当没有路径名时，就代表访问根目录下事先设置的&lt;strong&gt;默认文件&lt;/strong&gt;，也就是&lt;code&gt;/index.html&lt;/code&gt;或者&lt;code&gt;/default.html&lt;/code&gt;这些文件，这样就不好发生混乱&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;生产HTTP请求信息&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;对&lt;code&gt;URL&lt;/code&gt;进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生产HTTP请求信息&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ5OTZhMDE0M2U1NDg3YjkxOGM0YTBlMmZmZGNhODNfSU5nQW93c3pXYUppT1FKaGJ4WWd1VEZrU0hIUVVDd2JfVG9rZW46R1U3bWJ4aTZ6b0l5b1Z4VzdUUmN1a1FlblFQXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;真实地址查询dns&#34;&gt;&lt;strong&gt;真实地址查询——DNS&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给&lt;code&gt;Web&lt;/code&gt;服务器&lt;/p&gt;&#xA;&lt;p&gt;但是在发送之前，还需要&lt;strong&gt;查询服务器域名对应的IP地址&lt;/strong&gt;，因为委托操作系统发送消息时，必须提供通信对象的IP地址&lt;/p&gt;&#xA;&lt;p&gt;这里，有一种服务器就专门保存了&lt;code&gt;Web&lt;/code&gt;服务器域名与&lt;code&gt;IP&lt;/code&gt;的对应关系——DNS服务器&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;域名的层级关系&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;DNS中的域名都是用&lt;strong&gt;句点&lt;/strong&gt;来分隔的，比如&lt;code&gt;www.server.com&lt;/code&gt;，这里的句点带不了不同层次之间的界限&lt;/p&gt;&#xA;&lt;p&gt;在域名中，&lt;strong&gt;越靠右&lt;/strong&gt;的位置表示其&lt;strong&gt;层级越高&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;实际上&lt;strong&gt;域名&lt;/strong&gt;最后还有一个点，比如&lt;code&gt;www``.server.com.&lt;/code&gt;，这个最后一个点代表根域名&lt;/p&gt;&#xA;&lt;p&gt;也就是说，&lt;code&gt;.&lt;/code&gt;根域是最顶层，它的下一层是&lt;code&gt;.com&lt;/code&gt;顶级域,再下面是&lt;code&gt;server.com&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以，域名的层级关系类似一个树状结构&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;根DNS服务器&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;顶级域DNS服务器&lt;code&gt;.com&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;权威DNS服务器&lt;code&gt;server.com&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YzA0NDVhMjA2MDAxMDFkNTUxNTg4Yzg2MDhlYjk0ZTRfcVJsVzU0WHl0cXZFT1h5WHpDMEpjYnlRWnkxSEhWUkNfVG9rZW46RUhFTWIwWFBFb04yZ3V4RHVNSGM1V0dBbnc0XzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;根域的DNS服务器信息保存在互联网中所有的DNS服务器中，这样一来任何DNS服务器都可以找到并访问根域DNS服务器&lt;/p&gt;&#xA;&lt;p&gt;因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。&lt;/p&gt;&#xA;&lt;p&gt;域名解析的工作流程&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;首先会发出一个DNS请求，问&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;的IP是啥，并发给本地DNS服务器（也就是客户端的TCP/IP设置中填写的DNS服务器地址）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地域名服务器收到客户端的请求后，如果&lt;strong&gt;缓存里的表格&lt;/strong&gt;能找到&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;，则直接返回IP地址，如果没有，本地DNS会去问它的根域名服务器， 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;根DNS收到本地DNS的请求后，根据&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;的后置是&lt;code&gt;.com&lt;/code&gt;，这个域名归于&lt;code&gt;.com&lt;/code&gt;区域管理，返回&lt;code&gt;.com&lt;/code&gt;顶级域名服务器地址给本地&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地DNS收到顶级域名服务器地址后，向顶级域名服务器请求负责&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;的权威DNS服务器的地址，&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地DNS最后向权威DNS服务器请求&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;的IP地址，该server.com的权威服务器就是域名解析结果的出处。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;权威DNS服务器查询结后将对应的IP地址X.X.X.X返回到本地DNS&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地DNS再将IP地址返回客户端，客户端和目标建立连接&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;至此，DNS的解析过程完成了，其过程可见下图&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjI2MmYzMWEzODdiOWY0YjcxMjZjMmEzZmUzNzEwZDFfTENsN3NZRWxDc1pVVlpKaTB3RzJwWEpGOEdhU1NBYU5fVG9rZW46SE9EVmJ5NzFlb3VHdlV4cHBPV2NiRVZ5bjZnXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;域名解析并不是每次都需要经过这么多步骤&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;还有&lt;strong&gt;缓存&lt;/strong&gt;的存在。&lt;/p&gt;&#xA;&lt;p&gt;浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。&lt;/p&gt;&#xA;&lt;h2 id=&#34;协议栈&#34;&gt;&lt;strong&gt;协议栈&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;通过DNS获取IP后，就可以把HTTP的传输工具交给操作系统中的&lt;strong&gt;协议栈&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTJiYWJjOTQwZjU3YTI3ODUyMWExMzU2MTlhNjkxZTNfaU5halB3SXMwdzRTdTdXVUVWQnBPYjhTWnpIN1ZEbWhfVG9rZW46WDJTQWIyU3R6b1RvQzN4aGc2OWNWczZJblNiXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。&lt;/p&gt;&#xA;&lt;p&gt;协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL内存</title>
      <link>https://ahang7.github.io/post/basic/mysql/5.-mysql%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/5.-mysql%E5%86%85%E5%AD%98/</guid>
      <description>&lt;h2 id=&#34;为什么要有buffer-pool&#34;&gt;为什么要有Buffer Pool&lt;/h2&gt;&#xA;&lt;p&gt;MySQL的数据存储在磁盘的，如果每次都从磁盘里面读取数据，这样性能是很差的&lt;/p&gt;&#xA;&lt;p&gt;提高性能，就需要加入缓存。当数据从磁盘中取出来之后，缓存内存中，下次查询同样的数据，直接从内存中读取&lt;/p&gt;&#xA;&lt;p&gt;为此InnoDB存储引擎设计了&lt;strong&gt;一个缓存池（Buffer Pool），来提高数据库的读写性能&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;有了缓冲池后：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读取数据时，如果数据存在于Buffer Pool中，客户端就会直接读取Buffer Pool中的数据，否则再去磁盘中读取&lt;/li&gt;&#xA;&lt;li&gt;当修改数据时，首先修改Buffer Pool中数据所在的数据页，然后将该页设置为脏页，最后由后台线程将脏页写入到磁盘&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;buffer-pool有多大&#34;&gt;Buffer Pool有多大？&lt;/h2&gt;&#xA;&lt;p&gt;Buffer Pool在MySQL启动的时候，向操作系统申请的一片连续的内存空间，默认配置下Buffer Pool只有&lt;code&gt;128MB&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以通过调整&lt;code&gt;innodb_buffer_pool_size&lt;/code&gt; 参数来设置Buffer Pool的大小，一般建议设置为可用物理内存的60%~80%&lt;/p&gt;&#xA;&lt;h2 id=&#34;buffer-pool缓存什么&#34;&gt;Buffer Pool缓存什么？&lt;/h2&gt;&#xA;&lt;p&gt;InnoDB会把存储的数据分为若干个&lt;strong&gt;页&lt;/strong&gt;，以页作为磁盘和内存交互的基本单位，一个页的默认大小为**16kb，**因此Buffer Pool同样需要按页来划分&lt;/p&gt;&#xA;&lt;p&gt;在MySQL启动的时候，**InnoDB会为Buffer Pool申请一片连续的&lt;strong&gt;&lt;strong&gt;内存&lt;/strong&gt;&lt;/strong&gt;空间，然后按照默认的16&lt;strong&gt;&lt;strong&gt;kb&lt;/strong&gt;&lt;/strong&gt;的大小划分出一个个的页，Buffer Pool中的页就叫做缓存页。**这些缓存页都是空的，之后随着程序的运行，才会有磁盘上的页被缓存到Buffer Pool中&lt;/p&gt;&#xA;&lt;p&gt;所以，MySQL刚启动的时候，其使用的虚拟内存空间很大，而使用到的物理内存空间很小，这时因为这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系&lt;/p&gt;&#xA;&lt;p&gt;Buffer Pool缓存了以下的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;索引页&lt;/li&gt;&#xA;&lt;li&gt;数据页&lt;/li&gt;&#xA;&lt;li&gt;插入缓存页&lt;/li&gt;&#xA;&lt;li&gt;Undo页&lt;/li&gt;&#xA;&lt;li&gt;自适应哈希索引&lt;/li&gt;&#xA;&lt;li&gt;锁信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为了更好管理Buffer Pool中的缓存页，InnoDB为每一个缓存页都创建了一个**控制块，**控制块包括缓存页的表空间，页号，缓存页地址，链表节点等，控制块也占据内存空间，它是在Buffer Pool的最前面，接着才是缓存页&lt;/p&gt;&#xA;&lt;p&gt;暂时无法在飞书文档外展示此内容&lt;/p&gt;&#xA;&lt;p&gt;上面的控制块和缓存页之间的空白空间称为&lt;strong&gt;碎片空间&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;碎片空间：每一个控制块对应一个缓存页，在分配足够多的控制块和缓存页后，可能剩余的空间不足够一个控制块和缓存页的大小，那么这块空间就不被使用，剩下的这块空间就被称为碎片&lt;/p&gt;&#xA;&lt;p&gt;当Buffer Pool的大小设置的刚刚好，就不会产生碎片&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;查询一条记录时，InnoDB会把整个页的数据加载到Buffer Pool中，通过索引只能定位到磁盘中的页，而不能定位到页中一条记录。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/A5gNVXMNE-iIlY3oofXtLw&#34;&gt;mp.weixin.qq.com&lt;/a&gt;(从数据页的角度看B+树——InnoDB存储引擎)&lt;/p&gt;&#xA;&lt;p&gt;记录是按照行来存储的，但是数据库的读取并不是以&lt;strong&gt;行&lt;/strong&gt;为单位，否则一次读取（一次IO操作）只能处理一行数据，效率会非常低，因此，&lt;strong&gt;InnoDB的数据是按照数据页为单位来读写的&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;数据页的结构分为7个部分&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;File Header(38)&lt;/td&gt;&#xA;          &lt;td&gt;文件头，表示页的信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Page Header(56)&lt;/td&gt;&#xA;          &lt;td&gt;页头，表示页的状态信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;infimum+supermun(26)&lt;/td&gt;&#xA;          &lt;td&gt;两个虚拟伪记录，分别表示页中最小记录和最大记录&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;User Records(unclear)&lt;/td&gt;&#xA;          &lt;td&gt;存储行记录内容&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Free Space(unclear)&lt;/td&gt;&#xA;          &lt;td&gt;页中还没被使用的&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Page Directory(unclear)&lt;/td&gt;&#xA;          &lt;td&gt;页目录，存储用户记录的相对位置，对记录起索引作用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;File Tailer(8)&lt;/td&gt;&#xA;          &lt;td&gt;校验页是否完整&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;其中，行记录由&lt;code&gt;infimum+supremum&lt;/code&gt; 和 &lt;code&gt;User Records&lt;/code&gt;构成&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] 集群</title>
      <link>https://ahang7.github.io/post/basic/redis/6-redis%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/6-redis%E9%9B%86%E7%BE%A4/</guid>
      <description></description>
    </item>
    <item>
      <title>[MySQL] MySQL日志</title>
      <link>https://ahang7.github.io/post/basic/mysql/4.-mysql%E6%97%A5%E5%BF%97/</link>
      <pubDate>Tue, 29 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/4.-mysql%E6%97%A5%E5%BF%97/</guid>
      <description>&lt;p&gt;先理解执行一条sql语句，在mysql内部会发生什么？&lt;/p&gt;&#xA;&lt;p&gt;以执行一条&lt;code&gt;update&lt;/code&gt; 语句为例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;客户端会先通过连接器建立连接，连接器会判断用户身份&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;这里是一条update语句，所以不需要经过查询缓存（注意，当表上有更新语句，会把整个查询缓存清空，所以在Mysql8.0这个功能就被移除了）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解析器会通过词法分析识别出关键字，构建出语法树，接着做语法分析，判断输入的语句是否符合MySQL语法&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;预处理器会判断表和字段是否存在&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;优化器确定执行计划（使用索引或者全表查询）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;执行器负责具体执行，找到这一行然后更新&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不过，更新语句的流程会涉及到&lt;strong&gt;undo&lt;/strong&gt; &lt;strong&gt;log&lt;/strong&gt;**，redo log，binlog**三种日志：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;undo log（回滚日志）：是InnoDB存储引擎生成的日志，实现了事务中的&lt;strong&gt;原子性&lt;/strong&gt;，主要用于事务回滚和MVCC&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;redo log（重做日志）：是InnoDB存储引擎生成的日志，实现了事务中的&lt;strong&gt;持久性&lt;/strong&gt;，主要用于掉电等故障恢复&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;bing log（归档日志）：是Server层生成的日志，主要用于数据备份和主从复制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;1为什么需要undo-log&#34;&gt;1.为什么需要undo log？&lt;/h2&gt;&#xA;&lt;p&gt;在执行一条“增删改”语句的时候，MySQL会隐式开启事务，执行完后自动提交事务&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;MySQL中执行一条语句后是否自动提交事务，是由&lt;code&gt;autocommit&lt;/code&gt; 参数来决定的，默认是开启的&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;当事务执行过程中，都记录下回滚时需要的信息到一个日志中，那么在事务执行过程中发生MySQL崩溃后，可以通过这个日志回滚到事务之前的数据&lt;/p&gt;&#xA;&lt;p&gt;实现这一机制就是 &lt;strong&gt;undo&lt;/strong&gt; &lt;strong&gt;log&lt;/strong&gt;**（回滚日志），它保证了事务的&lt;strong&gt;&lt;strong&gt;ACID&lt;/strong&gt;&lt;/strong&gt;特性中的原子性**&lt;/p&gt;&#xA;&lt;p&gt;每当InnoDB引擎对每种操作进行回滚时，进行相反操作就行：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;插入 - 删除&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;删除 - 插入&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;更新 - 更新为旧值&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;一条记录每次进行操作产生的undo log格式都有一个roll_pointer和一个trx_id事务id：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;trx_id：记录该记录是被哪些事务修改的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;roll_pointer：指针可以将这些undo log串成一个链表，这个链表被称为版本链&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=N2UyNDE0NmNmNDU2N2UyY2Q5NDJkYzZiNzAwMzY3OTRfUjh5Zmw4d3VoWFI5VGZnaFR2a0NsVWk0bVdPTEM2WW5fVG9rZW46V3FmemIzbkhQb1BkRjB4UGFLbWNwR2RpbkRLXzE3MjE4NDExMjk6MTcyMTg0NDcyOV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;另外，undo log可以跟Read View一起实现MVCC（多版本并发控制）：&lt;/p&gt;&#xA;&lt;p&gt;对于 &lt;strong&gt;读提交&lt;/strong&gt; 和 &lt;strong&gt;可重复读&lt;/strong&gt; 隔离级别的事务来说，它们的快照读（普通select语句）是通过Read View + undo log来实现的，区别在于创建Read View的时机不同&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读提交：是在每一个select都会生成一个新的Read View，也意味着事务期间的多次读取同一数据，前后两次读的数据可能会出现不一致（不可重复读）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可重复读：是在启动事务时生成一个Read View，然后整个事务期间都在用这个Read View，这样保证了事务期间读到的数据都是事务启动时的记录&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这两个隔离级别实现是通过事务的Read View里的字段和记录两个隐藏列trx_id和roll_pointer的对比&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B&#34;&gt;事务隔离级别是怎么实现的？&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;因此，undo log两大作用：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现事务回滚，保障事务的原子性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现MVCC（多版本并发控制）关键因素之一&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Undo log是如何刷盘？&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] 场景</title>
      <link>https://ahang7.github.io/post/basic/redis/5-redis%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Tue, 29 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/5-redis%E5%9C%BA%E6%99%AF/</guid>
      <description>&lt;h2 id=&#34;六场景&#34;&gt;六、场景&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1缓存&#34;&gt;1.缓存&lt;/h3&gt;&#xA;&lt;p&gt;Redis由于性能高效，通常可以做数据库存储的缓存，比如给Mysql做缓存&lt;/p&gt;&#xA;&lt;p&gt;通常业务都满足二八原则，80%的流量在20%的热点数据上，所以缓存可以很大程度提高系统的吞吐量&lt;/p&gt;&#xA;&lt;h4 id=&#34;11缓存基础&#34;&gt;1.1缓存基础&lt;/h4&gt;&#xA;&lt;p&gt;一般而言，缓存分为服务器缓存，客户端缓存&lt;/p&gt;&#xA;&lt;p&gt;缓存一般有以下几种模式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;旁路缓存模式：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读穿透模式：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;写穿透模式：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;异步缓存写入模式：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h5 id=&#34;旁路缓存模式适用于读多写少&#34;&gt;旁路缓存模式（适用于读多写少）&lt;/h5&gt;&#xA;&lt;p&gt;Cache Aside，旁路缓存模式，是&lt;strong&gt;最常见的模式&lt;/strong&gt;，应用服务把缓存当作数据库的旁路，直接和缓存交互&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读操作：服务端收到查询请求，先查询数据是否在缓存上，如果在，就用缓存数据直接打包返回，如果不存在，就去数据库查询，并放到缓存&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;写操作：cache aside模式一般先更新数据库，再直接删除缓存（更新相比删除更容易造成时序性问题）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;适用于读多写少的场景，缺点是可能会出现缓存和数据库不一致的情况&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这里的写操作，更新相比删除更容易造成时序性问题，具体举例：线程1更新mysql -&amp;gt; 线程2更新mysql -&amp;gt; 线程2更新缓存 -&amp;gt; 线程1更新mysql，这样就出现了时许性问题&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;该模型的缺点：&lt;/p&gt;&#xA;&lt;p&gt;可能出现缓存和数据库不一致的情况，具体见：&lt;a href=&#34;https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98&#34;&gt;数据库和缓存如何保证一致性？&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h5 id=&#34;读穿透模式&#34;&gt;读穿透模式&lt;/h5&gt;&#xA;&lt;p&gt;与cache aside模式的区别主要在应用服务不再与缓存直接交互，而是直接去访问数据服务。&lt;/p&gt;&#xA;&lt;p&gt;这里的数据服务理解为一个**代理服务，**用它来访问缓存和数据库&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NGRhNWI5ZGY3OGFiNjlkNTc3NTQ1MTdjMGJiOTg2YmJfT09iTTdsU1pjbnNsR0dlU2ZvMEprMGlDa1hjd0l1QldfVG9rZW46TmE5MGJGTW52b3RWbHN4SmZadmM2dXZTbjJnXzE3MjE4NDE0OTU6MTcyMTg0NTA5NV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;相比于旁路缓存模式，读穿透模式的优势是缓存对业务是透明的；缺点是缓存命中的性能不如旁路缓存模式，会多一层服务调用&lt;/p&gt;&#xA;&lt;h5 id=&#34;写穿透模式&#34;&gt;写穿透模式&lt;/h5&gt;&#xA;&lt;p&gt;WriteThrough做了一层封装：有缓存服务先写入Mysql，再同步写入Redis，这样及时加载或更新了缓存数据（理解为，应用程序由一个单独的访问源，而存储服务自己维护访问逻辑）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YWE5MTA1Y2MyNWE3OTYyY2I3Y2FmZjNiM2VmN2M3NDBfV1JIVlJVR01KN3VCakM4WVZ2REpFeXRtb21nb1ZYa0FfVG9rZW46U0F6emJXa3JFb29tSHV4OWh6cmNFdGpVbnllXzE3MjE4NDE0OTU6MTcyMTg0NTA5NV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在使用WriteThrough时，一般都配合使用ReadThrough来使用&lt;/p&gt;&#xA;&lt;p&gt;适用情况：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对缓存及时性要求更高&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;不能忍受数据丢失和数据不一致&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;异步缓存写入模式write-behind&#34;&gt;异步缓存写入模式（Write-Behind）&lt;/h5&gt;&#xA;&lt;p&gt;write-Behind和Write-Through相同点是都是写入时会更新数据库、也会更新缓存&lt;/p&gt;&#xA;&lt;p&gt;不同点是：Write-Behind是先写缓存，后&lt;strong&gt;异步&lt;/strong&gt;把数据一起写入数据库&lt;/p&gt;&#xA;&lt;p&gt;数据库写操作可以用不同的方式完成：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;收集写操作并在某个时间点慢慢写入&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;合并几个写操作成为一个批量操作，一起批量写入&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;异步写操作极大降低了请求延迟，并减轻了数据库的负担，但是代价是安全性不够，如果缓存中的数据还没写入数据库，存储服务发生了崩溃，那么数据就丢失了&lt;/p&gt;&#xA;&lt;h4 id=&#34;12缓存异常&#34;&gt;1.2缓存异常&lt;/h4&gt;&#xA;&lt;h5 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题背景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;缓存穿透是指**缓存和数据库都没有的数据，**而用户不断发起请求。&lt;/p&gt;&#xA;&lt;p&gt;在流量大的时候，DB可能就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解决方案&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接口层增加校验，如用户鉴权校验，id做击穿校验，id&amp;lt;=0的直接拦截&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;从缓存取不到的数据，在数据库中也没有取到，这时可以将key-value对写成key-null，缓存有效时间写短点，例如30s&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;布隆过滤器：bloomfilter类似于一个hash set，用于快速判断某个元素是否存在于集合中，关键在于hash算法和容器大小&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;布隆过滤器：&lt;/p&gt;&#xA;&lt;p&gt;原理：布隆过滤器底层是一个64位的整型，将字符串用多个Hash函数映射不同的二进制位置，将整型中对应位置设置为1&lt;/p&gt;&#xA;&lt;p&gt;优点：空间、时间消耗都很小&lt;/p&gt;&#xA;&lt;p&gt;缺点：结果不完全准&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h5 id=&#34;缓存击穿&#34;&gt;缓存击穿&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题背景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;缓存击穿是指&lt;strong&gt;缓存中没有但数据库中有的数据&lt;/strong&gt;（一般缓存时间到期），这时由于并发的用户过多，同时读缓存没有数据又同时查询数据库，引起数据库压力瞬时增大&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解决方案&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;热点数据支付续期，持续访问的数据不断续期，避免因为过期失效而被击穿&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;发现缓存失效，重建缓存加互斥锁，当线程查询缓存发现缓存不存在就会尝试加锁，线程抢锁，拿到锁的线程进行查询数据库，然后重建缓存&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h5 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题背景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;指大量的应用请求因为异常无法在Redis缓存中处理，直接打到数据库。这里的异常就是：&lt;strong&gt;缓存中数据&lt;strong&gt;&lt;strong&gt;大批量&lt;/strong&gt;&lt;/strong&gt;到过期时间，而查询数据量巨大，引起数据库压力过大甚者宕机&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL锁</title>
      <link>https://ahang7.github.io/post/basic/mysql/3.-mysql%E9%94%81/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/3.-mysql%E9%94%81/</guid>
      <description>&lt;h2 id=&#34;锁的类型&#34;&gt;锁的类型&lt;/h2&gt;&#xA;&lt;p&gt;Mysql的锁，根据加锁的范围可以分为全局锁、表级锁和行锁三类&lt;/p&gt;&#xA;&lt;h3 id=&#34;全局锁&#34;&gt;全局锁&lt;/h3&gt;&#xA;&lt;p&gt;要使用全局锁，执行下面这条命令：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;flush&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行之后，整个数据库就处于只读状态，这时其他线程执行以下操作，就会被阻塞&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对数据的增删改，比如insert、delete、update等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对表结构的更改操作，比如alter table、drop table等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;要释放全局锁，执行下面的命令：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;全局锁的应用场景：&lt;/p&gt;&#xA;&lt;p&gt;全局锁主要用于做&lt;strong&gt;全库逻辑备份&lt;/strong&gt;，这样在备份数据库期间，不会因为数据或者结构的更新，而出现备份文件的数据与预期的不一样&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;加全局锁带来的缺点：会导致业务停滞，因为加全局锁之后，整个数据库都只是只读状态，不能更新数据&lt;/p&gt;&#xA;&lt;p&gt;可以通过开启事务，在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的Read View，&lt;/p&gt;&#xA;&lt;p&gt;备份数据库的工具是&lt;code&gt;mysqldump&lt;/code&gt; ，在使用mysqldump时加上&lt;code&gt;-single-transaction&lt;/code&gt; 参数的时候，就会在备份数据库之前开启事务&lt;/p&gt;&#xA;&lt;h3 id=&#34;表级锁&#34;&gt;表级锁&lt;/h3&gt;&#xA;&lt;p&gt;MySQL里面表级锁有以下几种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;表锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;元数据锁（MDL）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;意向锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;AUTO-INC锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;表锁&#34;&gt;表锁&lt;/h4&gt;&#xA;&lt;p&gt;使用下面的命令对表加锁和释放锁&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 加读锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 写锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 释放锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;表锁会影响别的线程和本线程的读写操作&lt;/p&gt;&#xA;&lt;h4 id=&#34;元数据锁mdl&#34;&gt;元数据锁（MDL）&lt;/h4&gt;&#xA;&lt;p&gt;对于MDL，我们不需要显示使用，因为当我们在对数据库进行操作时，会自动给这个表上加MDL：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对一张表进行CURD操作时，加的是MDL读锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对一张表做结构变更操作的时候，加的是MDL写锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;MDL是为了保证当前用户对表执行CRUD操作时，防止其他线程对这个表结构做了变更&lt;/p&gt;&#xA;&lt;p&gt;MDL是在事务提交之后才会释放，这意味着&lt;strong&gt;事务执行期间，MDL是一直持有&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;需要注意的是，在事务启用之后，如果事务A没有提交，此时如果有表结构的修改请求发起，就会发生阻塞，这个阻塞也会导致其他CURD的请求被阻塞住&lt;/p&gt;&#xA;&lt;p&gt;这是因为申请MDL锁的操作会形成一个队列，队列中&lt;strong&gt;写锁&lt;strong&gt;&lt;strong&gt;获取优先级大于&lt;/strong&gt;&lt;/strong&gt;读锁&lt;/strong&gt;，一旦出现MDL写锁等待，会阻塞该表后续的CRUD操作&lt;/p&gt;&#xA;&lt;h4 id=&#34;意向锁&#34;&gt;意向锁&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在使用InnoDB引擎的表里对某些记录加上共享锁之前，需要先在表级别加上一个意向共享锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在使用InnoDB引擎的表里对某些记录加上独占锁之前，需要先在表级别加上一个意向独占锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在执行insert、update、delete操作时，需要先对表上加 意向独占锁，然后对该记录加独占锁&lt;/p&gt;&#xA;&lt;p&gt;而普通的select是不会加行级锁，普通的select语句是利用MVCC实现一致性读，是无锁的&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// select也是可以对记录加共享锁和独占锁，&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 先在表上加上意向共享锁，然后对读取的记录加共享锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;share&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 先表上加上意向锁，然后再读取记录加独占锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;意向锁的目的是为了快速判断表里是否有记录被加锁&lt;/p&gt;&#xA;&lt;h4 id=&#34;auto-inc锁&#34;&gt;AUTO-INC锁&lt;/h4&gt;&#xA;&lt;p&gt;表里面的主键通常设置成自增的，在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过&lt;strong&gt;AUTO-INC锁&lt;/strong&gt;实现的&lt;/p&gt;&#xA;&lt;p&gt;Auto-Inc锁是特殊的表锁机制，不是在一个事务提交后才释放，而是再执行完插入语句后就会立即释放&lt;/p&gt;&#xA;&lt;h3 id=&#34;行级锁&#34;&gt;行级锁&lt;/h3&gt;&#xA;&lt;p&gt;InnoDB引擎是支持行级锁的，而MyISAM引擎并不支持行级锁&lt;/p&gt;&#xA;&lt;p&gt;行级锁的类型主要有三类：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] 持久化</title>
      <link>https://ahang7.github.io/post/basic/redis/4-redis%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/4-redis%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;五持久化&#34;&gt;五、持久化&lt;/h2&gt;&#xA;&lt;h3 id=&#34;0持久化介绍&#34;&gt;0.持久化介绍&lt;/h3&gt;&#xA;&lt;p&gt;redis是跑在内存里的，当程序重启或者服务崩溃，数据就会丢失，所以需要持久化，即把数据保存到可永久保存的存储设备中&lt;/p&gt;&#xA;&lt;h4 id=&#34;持久化方法&#34;&gt;持久化方法&lt;/h4&gt;&#xA;&lt;p&gt;redis提供两种方式来持久化：&lt;/p&gt;&#xA;&lt;h5 id=&#34;1rdbredis-database&#34;&gt;1.RDB(Redis Database)&lt;/h5&gt;&#xA;&lt;p&gt;记录Redis某个时刻的全部数据，这个方法的本质就是数据快照，直接保存二进制数据到磁盘，后续通过加载RDB文件恢复数据&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjc1YTM5MmU0NGI0MTVmNDVmYjMxZGU1ODg3ZTNiMDZfM01CeE9kMU9iRlVlSTNyUTBRSHFVa0dNS3RwUEJ2MHRfVG9rZW46RGR5NGIxdFJrb0NPa1l4RzJ2OWNsUHNsbnRjXzE3MjE4NDE0NjM6MTcyMTg0NTA2M19WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h5 id=&#34;2aofappend-only-file&#34;&gt;2.AOF(Append Only File)&lt;/h5&gt;&#xA;&lt;p&gt;记录执行的每条命令，重启之后通过重放命令来恢复数据，AOF是记录操作日志，后续通过日志重放恢复数据&lt;/p&gt;&#xA;&lt;h5 id=&#34;两种持久化方法的对比&#34;&gt;两种持久化方法的对比（*）&lt;/h5&gt;&#xA;&lt;p&gt;上面两种持久化方法对比：RDB（快照恢复）和AOF（日志恢复）&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;体积方面：相同数据量下，RDB体积小，因为RDB记录的是二进制紧凑型数据&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;恢复速度方面：RDB是数据快照，可以直接加载，而AOF文件恢复，相当于重放情况，RDB显然更快&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据完整性：AOF记录了每条日志，RDB是间隔一段时间记录一次，用AOF恢复数据通常会更加完整&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;rdb好还是aof好&#34;&gt;RDB好还是AOF好&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;业务本身需要的是缓存数据并且不是一个海量访问，可以不用开持久化&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对数据本身十分重视，可以同时开启RDB和AOF，注意，在同时开启的情况下，只会用AOF来加载，如果只有RDB文件而没有AOF文件，不会用RDB文件去恢复数据，如果逻辑是你自主开启选择AOF，表明要强一点的一致性，但是AOF文件缺失，此时不会去使用RDB，业务RDB会少很多数据，此时启动是一个空库&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;1rdb&#34;&gt;1.RDB&lt;/h3&gt;&#xA;&lt;p&gt;RDB文件的内容是**二进制数据，**记录的是某一瞬间的内存数据，是实际的数据，也叫做快照&lt;/p&gt;&#xA;&lt;p&gt;在Redis恢复数据时，RDB恢复数据的效率会比AOF高，因为会直接读取RDB文件到内存即可，不需要像AOF那样还需要额外执行操作命令的步骤才能恢复数据&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-rdb怎么使用&#34;&gt;1.1 RDB怎么使用&lt;/h4&gt;&#xA;&lt;p&gt;Redis提供两个命令来使用RDB文件，分别是&lt;code&gt;save&lt;/code&gt; 和&lt;code&gt;bgsave&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;save&lt;/code&gt; :执行了save命令，会在主线程生成RDB文件，由于和执行操作命令在同一个线程，所以写入RDB文件的时间太长，会&lt;strong&gt;阻塞主线程&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;bgsave&lt;/code&gt; :执行了bgsave命令，会创建一个子进程来生成RDB文件，这样可以&lt;strong&gt;避免主线程的阻塞&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;RDB文件的加载工作是在服务器启动时自动执行，Redis并没有提供专门加载RDB文件的命令&lt;/p&gt;&#xA;&lt;p&gt;在Redis的配置文件中，有以下的选项来实现每隔一段时间自动执行一次bgsave命令&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 这里写的是save，实际上是bgsave&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;save 900 1         # 900s之内，对数据库进行至少1次修改&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;save 300 10        # 300s之内，对数据库进行至少10次修改&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;save 60 10000      # 60s之内，对数据库进行至少10000次修改&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Redis的快照是&lt;strong&gt;全量快照&lt;/strong&gt;，也就是说每次执行快照，都是把内存中的所有数据记录到磁盘中&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RDB快照的缺点：当服务器发送故障时，丢失的数据会比AOF更多&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;12-执行快照时bgsave修改数据会发生什么&#34;&gt;1.2 执行快照时（bgsave），修改数据会发生什么？&lt;/h4&gt;&#xA;&lt;p&gt;在执行bgsave时，主线程是可以继续执行操作命令，由子线程来构建RDB文件，所以内存里的数据是可以修改的&lt;/p&gt;&#xA;&lt;p&gt;实现这一功能靠的是&lt;strong&gt;写时复制****技术&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;流程如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;执行bgsave命令时，会fork()创建子进程，此时子进程和父进程是共享同一片内存数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;主进程创建子进程时，子进程会复制父进程的页表，但是页表指向的物理内存跟主进程是同一个物理内存&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;此时如果主线程由写命令的执行，就会发生写时复制，物理内存才会被复制一次&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;发生&lt;strong&gt;&lt;strong&gt;写时复制&lt;/strong&gt;&lt;/strong&gt;后，&lt;strong&gt;&lt;strong&gt;RDB&lt;/strong&gt;&lt;/strong&gt;快照保存的是原本的&lt;strong&gt;&lt;strong&gt;内存&lt;/strong&gt;&lt;/strong&gt;数据&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这是因为创建bgsave子进程后，由于父子进程共享所有内存数据，所以可以直接将数据写入到RDB文件&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当主进程对共享的内存数据是&lt;strong&gt;只读****操作&lt;/strong&gt;，那么主进程和bgsave子进程是相互不影响&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当主进程对共享的内存数据进行&lt;strong&gt;写操作&lt;/strong&gt;时，就会发生&lt;strong&gt;写时复制&lt;/strong&gt;，这块数据的物理内存就会被复制一份，然后主线程在这个&lt;strong&gt;数据副本进行写操作&lt;/strong&gt;，此时bgsave子进程继续把原来的数据（原物理内存）写入到RDB文件&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;执行bgsave时，在极端情况下，如果所有的共享内存都被修改，则此时的内存占用是原先的两倍&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;13-什么时候执行rdb持久化&#34;&gt;1.3 什么时候执行RDB持久化&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主动执行命令save&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主动执行命令bgsave&lt;/p&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL事务</title>
      <link>https://ahang7.github.io/post/basic/mysql/2.-mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/2.-mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h2 id=&#34;1事务有哪些特征&#34;&gt;1.事务有哪些特征&lt;/h2&gt;&#xA;&lt;p&gt;原子性，隔离性，一致性，持久性&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;原子性：要么全做，要么全不做&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;隔离性：保证其它的状态转换不会影响到本次状态的转&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一致性：数据全部符合现实世界的约束&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;持久性： 更新后的数据存储到磁盘&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;InnoDB引擎通过以下技术来保证事务的四个特性&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;持久性是通过 redo log（重做日志）来保证&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;原子性是通过 undo log（回滚日志）来保证&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;隔离性是通过 mvcc（多版本并发控制）或者锁机制来保证&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一致性是通过持久性+原子性+隔离性来保证&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;2并发事务会引发的问题&#34;&gt;2.并发事务会引发的问题&lt;/h2&gt;&#xA;&lt;p&gt;MySQL服务端是允许多个客户端连接，这意味着MySQL会出现同时处理多个事务的情况&lt;/p&gt;&#xA;&lt;p&gt;在同时处理多个事务的时候，可能会出现脏读、不可重复读、幻读的问题&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;脏读：一个事务读到了另一个&lt;strong&gt;未提交事务修改过&lt;/strong&gt;的数据&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;不可重复读：在一个事务中多次读取同一个&lt;strong&gt;数据&lt;/strong&gt;，出现前后两次读到的数据不一样的情况&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;幻读：在一个事务中多次查询某个符合查询条件的&lt;strong&gt;记录数量&lt;/strong&gt;，如果出现前后两次查询到的记录数据不一样的情况&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;以上三个现象，问题的严重性是 脏读 &amp;gt; 不可重复读 &amp;gt; 幻读&lt;/p&gt;&#xA;&lt;h2 id=&#34;3事务的隔离级别&#34;&gt;3.事务的隔离级别&lt;/h2&gt;&#xA;&lt;p&gt;四种隔离级别：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读未提交：指一个事务还没有提交时，它做的变更就能被其他事务看到&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读提交：指一个事务提交之后，它做的变更才能被其他事务看到&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，&lt;strong&gt;MySQL&lt;/strong&gt; &lt;strong&gt;InnoDB引擎的默认隔离级别&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;串行化：对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生读写冲突的时候，后访问的事务必须等前一个事务执行完成&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;按隔离水平高低排序如下：&lt;/p&gt;&#xA;&lt;p&gt;串行化 &amp;gt; 可重复读 &amp;gt; 读已提交 &amp;gt; 读未提交&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;针对不同的隔离级别：并发事务时可能发生的现象也不同&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读未提交：脏读、不可重复读、幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读提交：不可重复读、幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可重复读：幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;串行化：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可重复读的隔离级别下，可以&lt;strong&gt;很大程度上避免&lt;/strong&gt;幻读现象的发生，所以MySQL不使用串行化隔离级别来避免幻读现象的发生，因为&lt;strong&gt;串行化隔离级别会影响性能&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;InnoDB在默认隔离级别：&lt;strong&gt;可重复读&lt;/strong&gt;的情况下很大程度上解决幻读现象的解决方案有两种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;针对**快照读（普通 select 语句），**是通过MVCC方式解决幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;针对**当前读（select &amp;hellip; for update），**通过next-key lock（记录锁+间隙锁）方式解决了幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;四种隔离事务是怎么实现的&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于读未提交：可以读到未提交事务修改的数据，所以直接读取就行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于串行化，通过加读写锁的方式来避免并行访问&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于读提交和可重复读这两种隔离级别的事务，是通过Read View来实现的，它们的区别是在于创建Read View时，读提交隔离级别是在每个语句执行之前都会重新生成一个Read View；而可重复读隔离级别是启动事务时生成一个Read View，然后整个事务都在用这个Read View&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在执行开启事务命令，并不意味着启动了事务：&lt;/p&gt;&#xA;&lt;p&gt;在MySQL中，开启事务有两种命令，分别是：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] 执行流程</title>
      <link>https://ahang7.github.io/post/basic/redis/3-redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/3-redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;四执行流程&#34;&gt;四、执行流程&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内存结构&lt;/li&gt;&#xA;&lt;li&gt;核心执行是单线程&lt;/li&gt;&#xA;&lt;li&gt;多线程负载一些异步任务&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;1redis在内存中是怎么存储的&#34;&gt;1.Redis在内存中是怎么存储的&lt;/h3&gt;&#xA;&lt;p&gt;redis是内存存储，将数据放在redis时，都是以键值对形式存到内存&lt;/p&gt;&#xA;&lt;h4 id=&#34;数据库结构&#34;&gt;数据库结构&lt;/h4&gt;&#xA;&lt;p&gt;redisDb代表Redis数据库结构，各种操作对象，都是存储在dict数据结构里&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// redisDb 结构&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;//字典&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expires&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 过期键&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;blocking_keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ready_keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;watched_keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;avg_ttl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;defrag_later&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// dict 结构&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dictht&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ht&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rehashidx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iterators&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;redisDb即数据库对象，指向了数据字典，字典包含我们平常存储的k-v数据，v支持任意redis对象&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjUwNmMwNDdlZTRiYmE0ODNjZjNlYWE1M2U2ZjRhZmZfMVhzNEFiWk0xQ2tYMXh0T21yQ045OGgwOVVLSzhDV0NfVG9rZW46VkdtbmJwMEZSb0tqcHF4ckhqVGNrTHI4blBkXzE3MjE4NDE0MjU6MTcyMTg0NTAyNV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在增加、查询、更新、删除的操作后，分别在内存存储是怎么体现的？&lt;/p&gt;&#xA;&lt;h4 id=&#34;增删改查在redis内存中的体现&#34;&gt;增删改查在Redis内存中的体现&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;即添加键值对，添加到dict结构字典中，Key必须为String对象，value为任何类型的对象&lt;/p&gt;&#xA;&lt;p&gt;添加数据后，会在redisDb里字段dict上添加dict对象&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;直接在dict找到对应的key，即完成查询&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更新数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;对已经Key对象的任何变更操作，都是更新&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;删除即把key和value从dict结构里删除&lt;/p&gt;&#xA;&lt;h4 id=&#34;过期键&#34;&gt;过期键&lt;/h4&gt;&#xA;&lt;p&gt;Redis可以设置过期键，到达一定时间，这些对象会被自动过期并回收&lt;/p&gt;&#xA;&lt;p&gt;**过期键存储在&lt;strong&gt;&lt;strong&gt;expires&lt;/strong&gt;&lt;/strong&gt;字典上，**expires字典中，value就是过期时间&lt;/p&gt;&#xA;&lt;p&gt;在redisDb中，dict和expires中Key对象，实际都是存储String对象指针，两个的key都会指向内存相应的字符串地址&lt;/p&gt;&#xA;&lt;h3 id=&#34;2redis是单线程还是多线程&#34;&gt;2.Redis是单线程？还是多线程？&lt;/h3&gt;&#xA;&lt;p&gt;redis是一个能高效处理请求的组件&lt;/p&gt;&#xA;&lt;p&gt;核心处理逻辑，Redis一直都是单线程，其他辅助模块会有一些多线程、多进程的功能，例如：复制模块用的多进程；某些异步流程从4.0开始用多线程；网络I/O解包从6.0开始用多线程；&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;核心处理逻辑：Redis在处理客户端的请求时，包括获取（socket写）、解析、执行、内容返回等都是由一个顺序串行的主线程处理，这就是所谓的单线程&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;redis为什么选择单线程&#34;&gt;Redis为什么选择单线程&lt;/h4&gt;&#xA;&lt;p&gt;redis的定位是内存k-v存储，是做短平快的热点数据处理，一般来说执行会很快，执行本身不会成为瓶颈，瓶颈通常在网络I/O，处理逻辑多线程并不会有太大收益&lt;/p&gt;&#xA;&lt;p&gt;同时Redis本身秉持简洁高效的理念，代码的简单性、可维护性是redis一直依赖的追求，执行本身不应该成为瓶颈，而且多线程本身也会引起额外成本&lt;/p&gt;&#xA;&lt;h4 id=&#34;1多线程引入的复杂度是极大的&#34;&gt;1.多线程引入的复杂度是极大的&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多线程引入后，redis原来的顺序执行特性就不复存在，为了事务的原子性、隔离性，redis就不得不引入一些很复杂的实现&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;redis的数据结构是极其高效，在单线程模式下做了很多特性的优化，如果引入多线程，那么所有底层数据都要改为线性安全，这很复杂&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多线程模式使得程序调试更加复杂和麻烦，会带来额外的开发成本及运营成本&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;2多线程带来额外的成本&#34;&gt;2.多线程带来额外的成本&lt;/h4&gt;&#xA;&lt;p&gt;除了引入复杂度，多线程还会带来额外成本，包括&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;上下文切换成本，多线程调度需要切换线程上下文，这个操作先存储当前线程的本地数据，程序指针，然后载入另一个线程数据，这种内核操作的成本不可忽略&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;同步机制的开销，一些公共资源，在单线程模式下直接访问就行，多线程需要通过加锁等方式进行同步&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个线程本身也占据内存大小，对redis这种内存数据库来说，内存非常珍贵，多线程本身带来的内存使用的成本也需要谨慎决策&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;&#xA;&lt;p&gt;多线程会引入额外的复杂度和成本，而redis是追求简洁高效的存储组件，而且事实也证明，虽然redis是单线程处理架构，redis性能还是经受住了考验&lt;/p&gt;&#xA;&lt;h3 id=&#34;3redis单线程为什么能这么快&#34;&gt;3.Redis单线程为什么能这么快&lt;/h3&gt;&#xA;&lt;h4 id=&#34;redis单线程&#34;&gt;Redis单线程&lt;/h4&gt;&#xA;&lt;p&gt;Redis核心的请求处理是单线程，但是Redis却能使用单线程模型达到每秒数万级别的处理能力，这是Redis多方面极致设计的一个综合结果&lt;/p&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL索引</title>
      <link>https://ahang7.github.io/post/basic/mysql/1.-mysql%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/1.-mysql%E7%B4%A2%E5%BC%95/</guid>
      <description>&lt;h2 id=&#34;1-b树索引数据结构&#34;&gt;1. B+树（索引数据结构）&lt;/h2&gt;&#xA;&lt;p&gt;什么是索引？&#xA;为什么索引能加快查询？&#xA;索引的数据结构是什么？&#xA;B+ 树 和（B 树 和 红黑树）有什么区别？&#xA;为什么选择 B+树 作为索引数据结构？&lt;/p&gt;&#xA;&lt;h3 id=&#34;为什么mysql-innodb选择b-tree作为索引&#34;&gt;为什么Mysql InnoDB选择B+ Tree作为索引？&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;B+ 树 vs B 树&#xA;B+ 树只在叶子节点存储数据，B树的非叶子节点也要存储数据，所以B+ 树的单个节点的数据量更小&lt;/li&gt;&#xA;&lt;li&gt;B+ 树 vs 二叉树&#xA;对于有N个叶子节点的B+ 树，搜索复制度为O（logdn）&lt;/li&gt;&#xA;&lt;li&gt;B+ 树 vs Hash&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/08%20%20%E7%B4%A2%E5%BC%95%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E8%89%BA%E6%9C%AF.md&#34;&gt;08 索引:排序的艺术&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html&#34;&gt;为什么 MySQL 采用 B+ 树作为索引？&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;2-索引组织表索引存储&#34;&gt;2. 索引组织表（索引存储）&lt;/h2&gt;&#xA;&lt;p&gt;堆表和索引组织表有什么区别？&lt;/p&gt;&#xA;&lt;p&gt;分别应用场景是什么？&lt;/p&gt;&#xA;&lt;p&gt;Mysql InnoDB存储引擎中数据存储方式：&lt;strong&gt;索引组织表&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;数据存储有&lt;strong&gt;堆表和索引组织表两种。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;堆表中的数据是无序存放的，数据的排序完全依赖索引&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;索引组织表，数据根据主键进行排序存放在索引中，主键索引也叫&lt;strong&gt;聚集索引&lt;/strong&gt;（Clustered Index）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在索引组织表中，数据即索引，索引即数据&lt;/p&gt;&#xA;&lt;h3 id=&#34;二级索引&#34;&gt;二级索引&lt;/h3&gt;&#xA;&lt;p&gt;InnoDB存储引擎的数据是根据主键索引排序存储的，除了主键索引外，其它的索引都称为二级索引（Secondeary Index），或者非聚集索引&lt;/p&gt;&#xA;&lt;p&gt;二级索引也是一颗B+树索引，但是它和主键索引不同的是叶子节点存放的是索引键值、主键值&lt;/p&gt;&#xA;&lt;p&gt;通过二级索引&lt;code&gt;idx_name&lt;/code&gt; 只能定位主键值，需要额外再通过主键索引进行查询，才能得到最终结果。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;这种二级索引通过&lt;strong&gt;&lt;strong&gt;主键&lt;/strong&gt;&lt;/strong&gt;索引进行再一次查询的操作叫做“回表”&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这样的二级索引设计的好处：若记录发生了修改，则其它索引无须进行维护，除非记录的主键发生了修改&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;在索引组织表中，万物皆索引，索引就是数据，数据就是索引&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;二级索引的性能评估&#34;&gt;二级索引的性能评估&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;要比较顺序，对聚集索引性能友好&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;尽可能紧凑，对二级索引的性能和存储友好&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;函数索引先了解&#34;&gt;函数索引（先了解）&lt;/h3&gt;&#xA;&lt;p&gt;&amp;hellip;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/09%20%20%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8%EF%BC%9A%E4%B8%87%E7%89%A9%E7%9A%86%E7%B4%A2%E5%BC%95.md&#34;&gt;09 索引组织表:万物皆索引&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;3组合索引联合索引&#34;&gt;3.组合索引（联合索引）&lt;/h2&gt;&#xA;&lt;p&gt;联合索引的结构是什么？&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] redis 对象</title>
      <link>https://ahang7.github.io/post/basic/redis/2-redis%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/2-redis%E5%AF%B9%E8%B1%A1/</guid>
      <description>&lt;h2 id=&#34;三对象&#34;&gt;三、对象&lt;/h2&gt;&#xA;&lt;h3 id=&#34;redis-object-是什么&#34;&gt;Redis Object 是什么？&lt;/h3&gt;&#xA;&lt;p&gt;redis是key-value存储，key-value在redis中被抽象为对象(Object)，key只能是String对象，value支持丰富的对象类型{String, List, Set, Hash, Sorted Set, Stream&amp;hellip;}&lt;/p&gt;&#xA;&lt;h4 id=&#34;object在内存中的样子&#34;&gt;Object在内存中的样子&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define LRU_BITS 24&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reidsObject&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LRU_BITS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;refcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;Type: 查看redis对象&lt;/li&gt;&#xA;&lt;li&gt;Encoding: 表明使用哪种底层编码&lt;/li&gt;&#xA;&lt;li&gt;Lru: 记录对象访问信息，用于内存淘汰&lt;/li&gt;&#xA;&lt;li&gt;Refcount: 引用计数，用来描述有多少指针，指向该对象&lt;/li&gt;&#xA;&lt;li&gt;Ptr: 内容指针，指向实际内容&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;对象与数据结果&#34;&gt;对象与数据结果&lt;/h4&gt;&#xA;&lt;p&gt;实际操作的对象有6个Redis对象，他们的底层依赖一些数据对象，包括字符串、跳表、哈希表、压缩列表、双端列表等&lt;/p&gt;&#xA;&lt;h3 id=&#34;1string&#34;&gt;1.String&lt;/h3&gt;&#xA;&lt;h4 id=&#34;string是什么&#34;&gt;String是什么&lt;/h4&gt;&#xA;&lt;p&gt;String是字符串，是Redis中最基本的数据对象，最大为512MB，可以通过配置项&lt;strong&gt;proto-max-bulk-len&lt;/strong&gt;修改它&lt;/p&gt;&#xA;&lt;p&gt;String可以存储各种类型的字符串（包括二进制文件）&lt;/p&gt;&#xA;&lt;h4 id=&#34;适用场景&#34;&gt;适用场景&lt;/h4&gt;&#xA;&lt;p&gt;使用场景：一般用来存放&lt;strong&gt;字节数据&lt;/strong&gt;、&lt;strong&gt;文本数据&lt;/strong&gt;、&lt;strong&gt;序列化****后的对象数据&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;例子：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;缓存场景：Value存Json字符串等信息&lt;/li&gt;&#xA;&lt;li&gt;计数场景：因为Redis处理命令是单线程，所以执行命令的过程是原子的，因此String数据类型适合计数场景&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;在redis中怎么使用&#34;&gt;在redis中怎么使用：&lt;/h4&gt;&#xA;&lt;p&gt;常用操作：创建、查询、更新、删除&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;创建 &amp;ndash;&amp;gt; set, setnx&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;SET&lt;/strong&gt; key value # 设置一个key值为特定的value&#xA;  set命令扩展参数：EX（键过期时间秒）、PX（键过期时间毫秒）、NX（只有键不存在时才对键进行操作，基本替代下面的SETNX操作）、XX（键存在时才对键进行操作）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;SETNX&lt;/strong&gt; key value # 用于在指定的&lt;strong&gt;key不存在&lt;/strong&gt;时，为key设置指定的值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查询 &amp;ndash;&amp;gt; get, mget&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Get&lt;/strong&gt; key # 查询某个key，存在就返回对应的value，不存在返回nil&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] Base理论</title>
      <link>https://ahang7.github.io/post/basic/redis/1-redis-base%E7%90%86%E8%AE%BA/</link>
      <pubDate>Fri, 25 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/1-redis-base%E7%90%86%E8%AE%BA/</guid>
      <description>&lt;h2 id=&#34;一什么是redis&#34;&gt;一、什么是redis？&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redis是一个内存数据结构储存，KV储存&lt;/li&gt;&#xA;&lt;li&gt;常用于缓存、消息中转、数据流引擎、分布式锁&lt;/li&gt;&#xA;&lt;li&gt;支持的数据结构有：字符串、散列、列表、集合、带范围查询的排序集合、位图、超日志、地理空间索引和流&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;(strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redis内置了复制、Lua脚本、LRU驱逐、事务和不同级别的磁盘持久化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://try.redis.io/&#34;&gt;Try Redis&lt;/a&gt; 官方redis在线操作平台&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;二base理论&#34;&gt;二、Base理论&lt;/h2&gt;&#xA;&lt;p&gt;Base理论是CAP中一致性的妥协，不追求强一致性，允许数据在一段时间内不一致，但是最终达到一致状态&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://rt5bap83jl.feishu.cn/docx/XXiHdxRVRokY7vxCqVccZ9PlnVe&#34;&gt;分布式系统的CAP定理与BASE理论&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>[golang] snc.Map</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/sync.map/</link>
      <pubDate>Fri, 04 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/sync.map/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] string</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/string/</link>
      <pubDate>Thu, 03 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/string/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] Map</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/map/</link>
      <pubDate>Wed, 02 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/map/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] interface</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/interface/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/interface/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] context</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/context/</link>
      <pubDate>Mon, 30 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/context/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] channel</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/channel/</link>
      <pubDate>Sun, 29 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/channel/</guid>
      <description></description>
    </item>
    <item>
      <title>[git] git-commit-message 规范</title>
      <link>https://ahang7.github.io/post/basic/git/git-commit-message/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/git/git-commit-message/</guid>
      <description>&lt;h1 id=&#34;符合angular规范的commit-message&#34;&gt;符合Angular规范的Commit Message&lt;/h1&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;type&amp;gt;[(optional scope)]: &amp;lt;description&amp;gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[optional body]  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[optional footers]  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分为了Header、Body、footer三个部分&lt;/p&gt;&#xA;&lt;h2 id=&#34;header&#34;&gt;Header&lt;/h2&gt;&#xA;&lt;p&gt;Header部分只有一行&lt;code&gt;&amp;lt;type&amp;gt;[(optional scope)]: &amp;lt;description&amp;gt;&lt;/code&gt;，其中type必选，其它可选&lt;/p&gt;&#xA;&lt;p&gt;type&amp;ndash;&amp;gt;归为两类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Development(项目管理类变更，不影响用户和生产环境的代码)&lt;/li&gt;&#xA;&lt;li&gt;Production(影响用户和生产环境的代码)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类型&lt;/th&gt;&#xA;          &lt;th&gt;类别&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;feat&lt;/td&gt;&#xA;          &lt;td&gt;Production&lt;/td&gt;&#xA;          &lt;td&gt;新增功能&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fix&lt;/td&gt;&#xA;          &lt;td&gt;Production&lt;/td&gt;&#xA;          &lt;td&gt;修复缺陷&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;perf&lt;/td&gt;&#xA;          &lt;td&gt;Production&lt;/td&gt;&#xA;          &lt;td&gt;提高代码性能的变更&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;style&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;代码格式类的变更，例如使用gofmt格式化代码&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;refactor&lt;/td&gt;&#xA;          &lt;td&gt;Production&lt;/td&gt;&#xA;          &lt;td&gt;其他代码类的变更，例如 简化代码、重命名变量、删除冗余代码等等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;test&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;新增测试用例或更新现有的测试用例&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ci&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;持续基础和部署相关的改动，例如修改Jenkins、GitLab CI等Ci配置文件或者更新系统单元文件&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;docs&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;文档类的更新，包括修改用户文档、开发文档&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;chore&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;其他类型，例如构建流程、依赖管理或者复制工具的变动&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;scope&amp;ndash;&amp;gt;不设置太具体的值，说明commit的影响范围&lt;br&gt;&#xA;description&amp;ndash;&amp;gt;对commit的简短描述，以动词开头&lt;/p&gt;&#xA;&lt;h2 id=&#34;body&#34;&gt;Body&lt;/h2&gt;&#xA;&lt;p&gt;Body对Commit Message的高度概况，方便查看具体做了什么变更&lt;/p&gt;&#xA;&lt;h2 id=&#34;footer&#34;&gt;Footer&lt;/h2&gt;&#xA;&lt;p&gt;Footer部分不是必选，可根据需要选择，主要用来说什么本次commit导致的后果，通常用来说明不兼容的改动或者关闭的issue&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BREAKING CHANGE: &amp;lt;breaking change summary&amp;gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;breaking change description + migration instructions&amp;gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Fixes(Closes) #&amp;lt;issue number&amp;gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;revert-commit&#34;&gt;Revert Commit&lt;/h2&gt;&#xA;&lt;p&gt;特殊的Commit Message。还原了先前的commit，则以&lt;code&gt;revert&lt;/code&gt;开头，后面跟还原的commit的Header，&lt;br&gt;&#xA;在Body必须写&lt;code&gt;This reverts commit &amp;lt;hash&amp;gt;&lt;/code&gt;，其中hash为要还原的commit的SHA标识&lt;/p&gt;</description>
    </item>
    <item>
      <title>[git] git-README 参考</title>
      <link>https://ahang7.github.io/post/basic/git/git-readme/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/git/git-readme/</guid>
      <description>&lt;h1 id=&#34;项目名称&#34;&gt;项目名称&lt;/h1&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;功能特性&#34;&gt;功能特性&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;软件架构可选&#34;&gt;软件架构(可选)&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;快速开始&#34;&gt;快速开始&lt;/h2&gt;&#xA;&lt;h3 id=&#34;依赖检查&#34;&gt;依赖检查&lt;/h3&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h3 id=&#34;构建&#34;&gt;构建&lt;/h3&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;使用指南&#34;&gt;使用指南&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;如何贡献&#34;&gt;如何贡献&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;社区可选&#34;&gt;社区(可选)&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;谁在用可选&#34;&gt;谁在用(可选)&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;许可证&#34;&gt;许可证&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>[golang] rpc</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%AE%9E%E8%B7%B5/1.-rpc/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%AE%9E%E8%B7%B5/1.-rpc/</guid>
      <description>&lt;p&gt;rpc包路径&lt;code&gt;net/rpc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;RPC服务的接口规范分为三个部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务名&lt;/li&gt;&#xA;&lt;li&gt;服务要实现的方法列表&lt;/li&gt;&#xA;&lt;li&gt;注册服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;注册服务的时候在RPC服务的名称中增加包路径前缀（这个RPC服务抽象的包路径，非真实的包路径）&lt;/p&gt;</description>
    </item>
    <item>
      <title>[golang] 内存逃逸</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</guid>
      <description></description>
    </item>
    <item>
      <title>[MQ] 消息队列</title>
      <link>https://ahang7.github.io/post/basic/middlewares/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97mq/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/middlewares/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97mq/</guid>
      <description>&lt;p&gt;消息队列是大型分布式系统不可缺少的中间件，也是高并发系统的基石中间件&lt;/p&gt;&#xA;&lt;h2 id=&#34;一消息队列mq概述&#34;&gt;一、消息队列MQ概述&lt;/h2&gt;&#xA;&lt;p&gt;消息队列（Message Queue），指保存消息的一个容器，本质是个&lt;!-- raw HTML omitted --&gt;队列&lt;!-- raw HTML omitted --&gt;，传送的消息可以是文本字符串，也可以是复杂的嵌入对象&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;基本模型&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;&#xA;&lt;h4 id=&#34;1异步处理&#34;&gt;1.异步处理&lt;/h4&gt;&#xA;&lt;p&gt;消息队列的主要特点是异步处理，主要目的是减少请求响应的时间，实现非核心流程异步化，提高系统响应性能&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;了解同步与异步&lt;a href=&#34;https://blog.csdn.net/hong521520/article/details/106671930&#34;&gt;同步与异步的区别(一看则懂)_同步和异步的区别-CSDN博客&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;异步的经典场景就是将比较耗时而且不需要即时（同步）返回结果的操作，通过&lt;strong&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/strong&gt;来实现****异步化&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;2应用解耦&#34;&gt;2.应用解耦&lt;/h4&gt;&#xA;&lt;p&gt;解耦：保证消息格式不变，消息的发送方和接收方之间并不需要彼此联系，也不受对方的影响&lt;/p&gt;&#xA;&lt;p&gt;只通过消息队列MQ来联系（？）&lt;/p&gt;&#xA;&lt;h4 id=&#34;3流量削锋&#34;&gt;3.流量削锋&lt;/h4&gt;&#xA;&lt;p&gt;一般在秒杀或团抢活动中使用广泛&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;这种场景中系统的&lt;strong&gt;&lt;strong&gt;峰值流量&lt;/strong&gt;&lt;/strong&gt;往往集中于一小段时间内，所以为了防止系统在短时间内的峰值流量冲垮，往往采用&lt;strong&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/strong&gt;来削弱峰值流量，相当于消息队列做了一次缓冲&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;4日志处理&#34;&gt;4.日志处理&lt;/h4&gt;&#xA;&lt;p&gt;日志处理是指将消息队列用在日志处理中，以解决大量日志传输的问题（比如Kafka）&lt;/p&gt;&#xA;&lt;p&gt;暂时无法在飞书文档外展示此内容&lt;/p&gt;&#xA;&lt;h2 id=&#34;二消息队列mq设计&#34;&gt;二、消息队列MQ设计&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1整体框架&#34;&gt;1.整体框架&lt;/h3&gt;&#xA;&lt;p&gt;暂时无法在飞书文档外展示此内容&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Producer 消息生产者：负责产生和发生消息到Broker；&lt;/li&gt;&#xA;&lt;li&gt;Broker 消息处理中心：负责消息存储、确认、重试等，一般会有多个queue；&lt;/li&gt;&#xA;&lt;li&gt;Consumer 消息消费者：负责从Broker中获取消息，并进行相应处理；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;2详细设计&#34;&gt;2.详细设计&lt;/h3&gt;&#xA;&lt;p&gt;Producer生产者 产生消息 &amp;ndash;&amp;gt; Broker消息处理中心 存储消息 &amp;ndash;&amp;gt; Consumer 消费者对消费消息，返回 消息确认 &amp;ndash;&amp;gt; Broker 进行消息备份/删除&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;RPC通信&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Producer产生消息，Consumer消费消息都会涉及到通信的问题，消息队列使用了RPC将数据流串起来&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;Broker存储&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;消息到达服务端后需要存储到Broker&lt;/p&gt;&#xA;&lt;p&gt;流量削峰、最终一致性等需求都是需要Broker先存储下来，等待合适的时机投递&lt;/p&gt;&#xA;&lt;p&gt;存储可以有很多方式，存储在内存，分布式KV，磁盘，数据库等，存储的选项需要考虑&lt;strong&gt;综合性能/高可用和开发维护成本&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;消费模型&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;消息到达Broker后，最终需要Consumer去消费消息，这里涉及到消费模型&lt;/p&gt;&#xA;&lt;p&gt;目前主要有两种：单播和广播&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;单播：点到点&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;广播：一点对多点&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;高级特性&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Consumer端把消息消费了，除了需要消息确认，还会涉及到比如：重复消息、顺序消息、消息延迟、事务消息等需要考虑的高级特性&lt;/p&gt;&#xA;&lt;h3 id=&#34;消息队列mq模型&#34;&gt;消息队列MQ模型&lt;/h3&gt;&#xA;&lt;p&gt;主要有两种模型：&lt;strong&gt;点对点&lt;/strong&gt; 与 &lt;strong&gt;发布订阅&lt;/strong&gt; 两种模型&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/cn/message-queue/&#34;&gt;消息队列是什么_mq是什么_MQ消息队列服务-AWS云服务&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/431149128&#34;&gt;深入消息队列MQ，看这篇就够了！&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>docker-基础</title>
      <link>https://ahang7.github.io/post/basic/docker/docker/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/docker/docker/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://yeasy.gitbook.io/docker_practice/&#34;&gt;https://yeasy.gitbook.io/docker_practice/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;一基本概念&#34;&gt;一、基本概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;镜像(&lt;code&gt;Image&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;容器(&lt;code&gt;Container&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;仓库(&lt;code&gt;Repository&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;理解以上三个概念，就能理解docker的生命周期&lt;/p&gt;&#xA;&lt;h3 id=&#34;1镜像&#34;&gt;1.镜像&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;Docker镜像&lt;/strong&gt;是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件，以及一些运行时所需的配置参数。镜像不包含任何动态数据，其内容在插件之后也不会被改变&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分层存储&lt;/strong&gt;，镜像采用了分层存储的架构，由一组文件系统组成的（多层文件系统联合组成）。在构建镜像时，会一层一层构建，后一层依赖于上一层，后一层上的任何改变都只会发生在本层，不会干涉到上一层。因此构建镜像的时候，需要对每层需要添加的东西尽量加最少最有必要的东西，减少额外的东西&lt;/p&gt;&#xA;&lt;p&gt;分层存储的特征还使得&lt;strong&gt;镜像的复用，定制&lt;/strong&gt;更为容易&lt;/p&gt;&#xA;&lt;h3 id=&#34;2容器&#34;&gt;2.容器&lt;/h3&gt;&#xA;&lt;p&gt;容器是镜像运行时的实体，可以被创建、启动、停止、删除暂停等&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;镜像(Image)和容器(container)的关系，就像是面向对象程序设计中的&lt;code&gt;类&lt;/code&gt; 和&lt;code&gt;实例&lt;/code&gt; 一样&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;容器的实质是进程，运行于属于自己的独立的命名空间。因此容器可以拥有自己的&lt;code&gt;root&lt;/code&gt; 文件系统，网络配置、进程空间等，运行在一个隔离的环境。这样的隔离特性，使得容器封装的应用比直接在宿主运行更加安全&lt;/p&gt;&#xA;&lt;p&gt;容器也是分层存储，是&lt;strong&gt;以镜像为基础层&lt;/strong&gt;，在其上创建一个当前容器的存储层，这个层是为容器运行时进行读写而准备的，称为&lt;strong&gt;容器存储层&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;容器存储层的生命周期跟容器一样，当容器消亡时，容器存储层也随之消亡，因此任何保存于容器存储层的信息都会随着容器的删除而丢失&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Dokcer最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层保存无状态化，所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录&lt;/p&gt;&#xA;&lt;p&gt;数据卷独立于容器，使用容器卷，容器的删除或者重写运行之后，数据都不会丢失&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;3仓库&#34;&gt;3.仓库&lt;/h3&gt;&#xA;&lt;p&gt;Docker Register：提供一个集中的存储、分发镜像的服务&lt;/p&gt;&#xA;&lt;p&gt;一个&lt;strong&gt;Docker Register&lt;/strong&gt;可以包含多个**仓库（&lt;strong&gt;&lt;strong&gt;Repository&lt;/strong&gt;&lt;/strong&gt;）;&lt;strong&gt;每个仓库可以包含多个&lt;/strong&gt;标签（Tag）,**每个标签对应一个镜像&lt;/p&gt;&#xA;&lt;p&gt;可以通过&lt;code&gt;&amp;lt;Repository Name&amp;gt;:&amp;lt;Tag Name&amp;gt;&lt;/code&gt; 的格式来指定具体的软件是那个版本的镜像&lt;/p&gt;&#xA;&lt;p&gt;仓库名以两段路径形式出现，比如&lt;code&gt;jwilder/nginx-proxy&lt;/code&gt; 前者是Docker Registry多用户环境下的用户名，后者是对应的软件名&lt;/p&gt;&#xA;&lt;h3 id=&#34;docker-registry-公开服务&#34;&gt;Docker Registry 公开服务&lt;/h3&gt;&#xA;&lt;p&gt;Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。&lt;/p&gt;&#xA;&lt;p&gt;最常见的是Docker Registry公开服务是官方的&lt;a href=&#34;https://hub.docker.com/&#34;&gt;hub.docker.com&lt;/a&gt;，也是默认的Registry&lt;/p&gt;&#xA;&lt;p&gt;也可以使用国内的镜像网站&lt;/p&gt;&#xA;&lt;h3 id=&#34;私有docker-registry&#34;&gt;私有Docker Registry&lt;/h3&gt;&#xA;&lt;p&gt;用户可以在本地搭建私有的Docker Registry。Docker提供了Docker Registry镜像，可以直接使用搭建私有Registry服务&lt;/p&gt;&#xA;&lt;h2 id=&#34;二镜像&#34;&gt;二、镜像&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1获取镜像&#34;&gt;1.获取镜像&lt;/h3&gt;&#xA;&lt;p&gt;从Docker镜像仓库获取镜像的命令是 &lt;code&gt;docker pull&lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker pull &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;选项&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;Docker Registry 地址&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;:端口号&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;/&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; 仓库名&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;:标签&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体选项可以从&lt;code&gt;docker pull --help&lt;/code&gt; 命令查看，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Docker镜像仓库地址：地址格式一般为 &lt;code&gt;&amp;lt;域名/IP&amp;gt;[:端口号]&lt;/code&gt;。默认地址是 Docker Hub&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;仓库名：仓库名是两段式，即&lt;code&gt;&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;&lt;/code&gt;.对于Docker Hub，如果不给出用户名，默认为 &lt;code&gt;library&lt;/code&gt;，也就是官方镜像&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker pull ubuntu:18.04&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面命令没有给出Docker镜像仓库地址，默认从&lt;code&gt;Docker Hub&lt;/code&gt;获取镜像。而镜像名称是&lt;code&gt;ubuntun:18.04&lt;/code&gt;,因此会获取官方镜像 &lt;code&gt;library/ubuntun&lt;/code&gt;仓库中标签为&lt;code&gt;18.04&lt;/code&gt;的镜像&lt;/p&gt;</description>
    </item>
    <item>
      <title>docker-部署</title>
      <link>https://ahang7.github.io/post/basic/docker/docker%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/docker/docker%E9%83%A8%E7%BD%B2/</guid>
      <description>&lt;p&gt;使用Docker 以及Docker Compose部署Go程序&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要docker&#34;&gt;为什么需要docker&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用docker的主要目标是其容器化。可以为应用程序提供一致的环境，而不依赖它运行的主机&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;部署示例&#34;&gt;部署示例&lt;/h3&gt;&#xA;&lt;h4 id=&#34;1准备代码&#34;&gt;1.准备代码&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Plaintext&#34; data-lang=&#34;Plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;package main&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;import (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &amp;#34;fmt&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &amp;#34;net/http&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func main() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        http.HandleFunc(&amp;#34;/&amp;#34;, hello)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        server := &amp;amp;http.Server{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                Addr: &amp;#34;:8888&amp;#34;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  fmt.Println(&amp;#34;server startup...&amp;#34;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if err := server.ListenAndServe(); err != nil {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                fmt.Printf(&amp;#34;server startup failed, err:%v\n&amp;#34;, err)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func hello(w http.ResponseWriter, _ *http.Request) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        w.Write([]byte(&amp;#34;hello liwenzhou.com!&amp;#34;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里是简单代码&lt;/p&gt;&#xA;&lt;h4 id=&#34;2创建docker镜像&#34;&gt;2.创建Docker镜像&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;镜像(image)包含运行应用程序所需的所有东西——代码/二进制文件、运行时、依赖项以及所需的任何其它人间系统对象&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;简单讲，镜像是定义应用程序以及运行所需的一切&lt;/p&gt;&#xA;&lt;h4 id=&#34;3编写dockerfile&#34;&gt;3.编写Dockerfile&lt;/h4&gt;&#xA;&lt;p&gt;要创建Docker镜像(image)必须在配置文件中的指定步骤，这个文件默认称为&lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>dockerfile-学习</title>
      <link>https://ahang7.github.io/post/basic/docker/dockerfile%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/docker/dockerfile%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;p&gt;学习自&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/7179042892395053113&#34;&gt;一篇文章带你吃透 Dockerfile - 掘金 (juejin.cn)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;Dockerfile reference&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/7042663735156015140&#34;&gt;全网最详细的Docker-Compose详细教程 - 掘金 (juejin.cn)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/387840381&#34;&gt;docker compose 配置文件 .yml 全面指南 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/compose-spec/compose-spec/blob/master/spec.md&#34;&gt;compose-spec/spec.md at master · compose-spec/compose-spec · GitHub&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;学习Dockers前期，通过Docker的官方镜像仓库拉取里面的镜像，根据这些镜像创建出容器并运行&lt;/p&gt;&#xA;&lt;p&gt;实际上，Docker官方镜像也是通过一定的方式构建出来的，只要弄清其中的逻辑，我们也可以仿照官方镜像的构建过程，构建出自己的镜像&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;就是这样一个用于描述Docker镜像构建过程的文本文件，dockerfile可以包含多条构建指令，以及相关的描述&lt;/p&gt;&#xA;&lt;h3 id=&#34;1什么是容器&#34;&gt;1.什么是容器&lt;/h3&gt;&#xA;&lt;p&gt;容器是计算机上的沙盒进程，与主机上的其它进程隔离，这种隔离利用了&lt;code&gt;内核命名空间和cgroups&lt;/code&gt;。简而言之容器是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;是&lt;code&gt;image&lt;/code&gt;的可运行实例&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以在本地计算机、虚拟机上运行或部署到云中&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;是可移植的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;与其它容器隔离，并运行自己的软件，二进制文件和配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2什么是容器映射&#34;&gt;2.什么是容器映射&lt;/h3&gt;&#xA;&lt;p&gt;当容器运行时，它使用了隔离的文件系统。这个自定义的文件系统由容器映像&lt;code&gt;container image&lt;/code&gt;提供。因为image包含了容器的问价系统，使用image必须包含所有的运行应用程序所必须的所有东西——依赖项、配置、脚本、二进制文件等等。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;沙盒进程是指在计算机系统中，为了保障安全和隔离性而采用的一种技术，将应用程序运行在一个受限制的环境中，限制它们能访问的资源和操作范围，从而避免恶意程序和授权程序对系统的破坏&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;3容器是怎么运行的&#34;&gt;3.容器是怎么运行的&lt;/h3&gt;&#xA;&lt;p&gt;当一个容器运行时，它为其文件系统使用来image的各个层。每个容器都有自己的命名空间来创建/更新/删除文件。在另一个容器中不会看到任何更改，即使它们使用相同的image&lt;/p&gt;&#xA;&lt;h3 id=&#34;4容器卷container-volumes&#34;&gt;4.容器卷[container volumes]&lt;/h3&gt;&#xA;&lt;p&gt;每个容器启动时都是从容器的定义开始的。在容器中可以创建、更新和删除文件，但当容器被删除时，这些改变将回丢失，所有更变都被隔离在各个容器中&lt;/p&gt;&#xA;&lt;p&gt;卷：提供了将容器的特定文件系统路径链路到主机的能力。如果在主机上的某个文件被挂载，那么当容器中该文件路径下的文件发送更改时，我们在主机上同样也可以看到更改。同样的，启动另一个挂载了同一个文件目录的容器，它也可以访问到相同的文件&lt;/p&gt;&#xA;&lt;h2 id=&#34;镜像构建原理&#34;&gt;镜像构建原理&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1docker架构模式&#34;&gt;1.Docker架构模式&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNkMzZjNzQ1MTljOTE0ZThhNjliYjMwODFiMjQ0NTJfSVlseWZldFNjR0l6QVpDbzFMdmNhYXg1TWRZb1oxUjZfVG9rZW46RjhBeWJoWkZpb2ZZbll4WEd2dGN3RXJHbkxoXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;使用了&lt;strong&gt;client&lt;/strong&gt;/&lt;strong&gt;server&lt;/strong&gt;的架构模式。构建镜像时，用户在&lt;strong&gt;dockers&lt;/strong&gt; &lt;strong&gt;client&lt;/strong&gt;输入构建命令。&lt;strong&gt;docker&lt;/strong&gt;引擎以 &lt;code&gt;REST API&lt;/code&gt;的形式，像 &lt;strong&gt;docker&lt;/strong&gt; &lt;strong&gt;daemon&lt;/strong&gt;发送构建请求，如何dockers daemon就根据构建请求的内容，开始镜像构建的工作，并向Client持续放回构建过程的信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2镜像分层模型&#34;&gt;2.镜像分层模型&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;docker&lt;/strong&gt;镜像是用于创建容器的只读模板，是通过 &lt;strong&gt;Dockerfile&lt;/strong&gt;中定义的指令构建而成的，构建结束后，会在原有的镜像层上生成一个新的镜像层，如下所示&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE5Yjk1OTNiMTc0MDI5YmU0NGZiNTNjZDU4NDQ5MDFfZmlPNWJYSnRaQ0RUSnJZNXpGSmN0anNFN1V6WGw4VkRfVG9rZW46RU9scmI4N0Jrb2RQVHJ4cVJFM2NwNlNtblBkXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在 tomcat 镜像创建一个容器后，会在tomcat镜像之上新创建一个可写的容器层，在容器中写文件时，会保存到这个容器层中&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MWU3YzUzYTM5OTE3NmZkZmEyNjhiYjZhYjljZTFiOTZfaTY2T1RORTY0UEVXWVJ0cnZ4RGxnSVE2ZGE0QWtsVlVfVG9rZW46Vk5McWI1RVV1b2h5WFV4aHBPM2NrcTNRbnVnXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;3基础镜像与父级镜像&#34;&gt;3.基础镜像与父级镜像&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;用于构建基础镜像的 &lt;strong&gt;Dockerfile&lt;/strong&gt; 不指定父级镜像，Docker约定使用如下形式基础镜像&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 &lt;code&gt;scratch&lt;/code&gt;是一个空镜像，可以从零开始构建镜像，常用来构建最小镜像，如&lt;code&gt;busybox&lt;/code&gt;，&lt;code&gt;debian&lt;/code&gt;，&lt;code&gt;alpine&lt;/code&gt;等镜像，省去很多linux命令，因此很小。一般，不需要自己去构建基础镜像。&lt;/p&gt;</description>
    </item>
    <item>
      <title>vscode.keyMap</title>
      <link>https://ahang7.github.io/post/tools/vscode/vscode.keymap/</link>
      <pubDate>Fri, 06 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/tools/vscode/vscode.keymap/</guid>
      <description>&lt;h3 id=&#34;常用-general&#34;&gt;常用 General&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + P，F1&lt;/td&gt;&#xA;          &lt;td&gt;显示命令面板 Show Command Palette&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + P&lt;/td&gt;&#xA;          &lt;td&gt;快速打开 Quick Open&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + N&lt;/td&gt;&#xA;          &lt;td&gt;新窗口/实例 New window/instance&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + W&lt;/td&gt;&#xA;          &lt;td&gt;关闭窗口/实例 Close window/instance&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + ,&lt;/td&gt;&#xA;          &lt;td&gt;用户设置 User Settings&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + S&lt;/td&gt;&#xA;          &lt;td&gt;设置键盘快捷方式 Keyboard Shortcuts&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;基础编辑-basic-editing&#34;&gt;基础编辑 Basic editing&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + X&lt;/td&gt;&#xA;          &lt;td&gt;剪切行（空选定） Cut line (empty selection)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + C&lt;/td&gt;&#xA;          &lt;td&gt;复制行（空选定）Copy line (empty selection)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + ↑ / ↓&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下移动行 Move line up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + ↓ / ↑&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下复制行 Copy line up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + K&lt;/td&gt;&#xA;          &lt;td&gt;删除行 Delete line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Enter&lt;/td&gt;&#xA;          &lt;td&gt;在下面插入行 Insert line below&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Enter&lt;/td&gt;&#xA;          &lt;td&gt;在上面插入行 Insert line above&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + |&lt;/td&gt;&#xA;          &lt;td&gt;跳到匹配的括号 Jump to matching bracket&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + ] / [&lt;/td&gt;&#xA;          &lt;td&gt;缩进/缩进行 Indent/outdent line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Home&lt;/td&gt;&#xA;          &lt;td&gt;转到行首 Go to beginning of line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;End&lt;/td&gt;&#xA;          &lt;td&gt;转到行尾 Go to end of line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Home&lt;/td&gt;&#xA;          &lt;td&gt;转到文件开头 Go to beginning of file&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + End&lt;/td&gt;&#xA;          &lt;td&gt;转到文件末尾 Go to end of file&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + ↑ / ↓&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下滚动行 Scroll line up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + PgUp / PgDown&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下滚动页面 Scroll page up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + [&lt;/td&gt;&#xA;          &lt;td&gt;折叠（折叠）区域 Fold (collapse) region&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + ]&lt;/td&gt;&#xA;          &lt;td&gt;展开（未折叠）区域 Unfold (uncollapse) region&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + [&lt;/td&gt;&#xA;          &lt;td&gt;折叠（未折叠）所有子区域 Fold (collapse) all subregions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + ]&lt;/td&gt;&#xA;          &lt;td&gt;展开（未折叠）所有子区域 Unfold (uncollapse) all subregions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + 0&lt;/td&gt;&#xA;          &lt;td&gt;折叠（折叠）所有区域 Fold (collapse) all regions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + J&lt;/td&gt;&#xA;          &lt;td&gt;展开（未折叠）所有区域 Unfold (uncollapse) all regions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + C&lt;/td&gt;&#xA;          &lt;td&gt;添加行注释 Add line comment&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + U&lt;/td&gt;&#xA;          &lt;td&gt;删除行注释 Remove line comment&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + /&lt;/td&gt;&#xA;          &lt;td&gt;切换行注释 Toggle line comment&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + A&lt;/td&gt;&#xA;          &lt;td&gt;切换块注释 Toggle block comment&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + Z&lt;/td&gt;&#xA;          &lt;td&gt;切换换行 Toggle word wrap&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;导航-navigation&#34;&gt;导航 Navigation&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + T&lt;/td&gt;&#xA;          &lt;td&gt;显示所有符号 Show all Symbols&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + G&lt;/td&gt;&#xA;          &lt;td&gt;转到行&amp;hellip; Go to Line&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + P&lt;/td&gt;&#xA;          &lt;td&gt;转到文件&amp;hellip; Go to File&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + O&lt;/td&gt;&#xA;          &lt;td&gt;转到符号&amp;hellip; Go to Symbol&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + M&lt;/td&gt;&#xA;          &lt;td&gt;显示问题面板 Show Problems panel&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F8&lt;/td&gt;&#xA;          &lt;td&gt;转到下一个错误或警告 Go to next error or warning&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + F8&lt;/td&gt;&#xA;          &lt;td&gt;转到上一个错误或警告 Go to previous error or warning&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Tab&lt;/td&gt;&#xA;          &lt;td&gt;导航编辑器组历史记录 Navigate editor group history&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + ← / →&lt;/td&gt;&#xA;          &lt;td&gt;返回/前进 Go back / forward&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + M&lt;/td&gt;&#xA;          &lt;td&gt;切换选项卡移动焦点 Toggle Tab moves focus&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;搜索和替换-search-and-replace&#34;&gt;搜索和替换 Search and replace&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + F&lt;/td&gt;&#xA;          &lt;td&gt;查找 Find&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + H&lt;/td&gt;&#xA;          &lt;td&gt;替换 Replace&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F3 / Shift + F3&lt;/td&gt;&#xA;          &lt;td&gt;查找下一个/上一个 Find next/previous&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + Enter&lt;/td&gt;&#xA;          &lt;td&gt;选择查找匹配的所有出现 Select all occurences of Find match&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + D&lt;/td&gt;&#xA;          &lt;td&gt;将选择添加到下一个查找匹配 Add selection to next Find match&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + D&lt;/td&gt;&#xA;          &lt;td&gt;将最后一个选择移至下一个查找匹配项 Move last selection to next Find match&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + C / R / W&lt;/td&gt;&#xA;          &lt;td&gt;切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;多光标和选择-multi-cursor-and-selection&#34;&gt;多光标和选择 Multi-cursor and selection&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt +单击&lt;/td&gt;&#xA;          &lt;td&gt;插入光标 Insert cursor&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Alt +↑/↓&lt;/td&gt;&#xA;          &lt;td&gt;在上/下插入光标 Insert cursor above / below&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + U&lt;/td&gt;&#xA;          &lt;td&gt;撤消上一个光标操作 Undo last cursor operation&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + I&lt;/td&gt;&#xA;          &lt;td&gt;在选定的每一行的末尾插入光标 Insert cursor at end of each line selected&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + L&lt;/td&gt;&#xA;          &lt;td&gt;选择当前行 Select current line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + L&lt;/td&gt;&#xA;          &lt;td&gt;选择当前选择的所有出现 Select all occurrences of current selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + F2&lt;/td&gt;&#xA;          &lt;td&gt;选择当前字的所有出现 Select all occurrences of current word&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + →&lt;/td&gt;&#xA;          &lt;td&gt;展开选择 Expand selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + ←&lt;/td&gt;&#xA;          &lt;td&gt;缩小选择 Shrink selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + （拖动鼠标）&lt;/td&gt;&#xA;          &lt;td&gt;列（框）选择 Column (box) selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Alt +（箭头键）&lt;/td&gt;&#xA;          &lt;td&gt;列（框）选择 Column (box) selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Alt + PgUp / PgDown&lt;/td&gt;&#xA;          &lt;td&gt;列（框）选择页上/下 Column (box) selection page up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;丰富的语言编辑-rich-languages-editing&#34;&gt;丰富的语言编辑 Rich languages editing&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + 空格&lt;/td&gt;&#xA;          &lt;td&gt;触发建议 Trigger suggestion&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Space&lt;/td&gt;&#xA;          &lt;td&gt;触发器参数提示 Trigger parameter hints&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + F&lt;/td&gt;&#xA;          &lt;td&gt;格式化文档 Format document&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + F&lt;/td&gt;&#xA;          &lt;td&gt;格式选定区域 Format selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F12&lt;/td&gt;&#xA;          &lt;td&gt;转到定义 Go to Definition&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + F12&lt;/td&gt;&#xA;          &lt;td&gt;Peek定义 Peek Definition&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K F12&lt;/td&gt;&#xA;          &lt;td&gt;打开定义到边 Open Definition to the side&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + .&lt;/td&gt;&#xA;          &lt;td&gt;快速解决 Quick Fix&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + F12&lt;/td&gt;&#xA;          &lt;td&gt;显示引用 Show References&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F2&lt;/td&gt;&#xA;          &lt;td&gt;重命名符号 Rename Symbol&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + X&lt;/td&gt;&#xA;          &lt;td&gt;修剪尾随空格 Trim trailing whitespace&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K M&lt;/td&gt;&#xA;          &lt;td&gt;更改文件语言 Change file language&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;编辑器管理-editor-management&#34;&gt;编辑器管理 Editor management&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + F4, Ctrl + W&lt;/td&gt;&#xA;          &lt;td&gt;关闭编辑器 Close editor&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K F&lt;/td&gt;&#xA;          &lt;td&gt;关闭文件夹 Close folder&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + |&lt;/td&gt;&#xA;          &lt;td&gt;拆分编辑器 Split editor&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + 1 / 2 / 3&lt;/td&gt;&#xA;          &lt;td&gt;聚焦到第 1，第 2 或第 3 编辑器组 Focus into 1st, 2nd or 3rd editor group&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + ← / →&lt;/td&gt;&#xA;          &lt;td&gt;聚焦到上一个/下一个编辑器组 Focus into previous/next editor group&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + PgUp / PgDown&lt;/td&gt;&#xA;          &lt;td&gt;向左/向右移动编辑器 Move editor left/right&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K ← / →&lt;/td&gt;&#xA;          &lt;td&gt;移动活动编辑器组 Move active editor group&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;文件管理-file-management&#34;&gt;文件管理 File management&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + N&lt;/td&gt;&#xA;          &lt;td&gt;新文件 New File&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + O&lt;/td&gt;&#xA;          &lt;td&gt;打开文件&amp;hellip; Open File&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + S&lt;/td&gt;&#xA;          &lt;td&gt;保存 Save&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + S&lt;/td&gt;&#xA;          &lt;td&gt;另存为&amp;hellip; Save As&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K S&lt;/td&gt;&#xA;          &lt;td&gt;全部保存 Save All&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + F4&lt;/td&gt;&#xA;          &lt;td&gt;关闭 Close&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + W&lt;/td&gt;&#xA;          &lt;td&gt;关闭所有 Close All&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + T&lt;/td&gt;&#xA;          &lt;td&gt;重新打开关闭的编辑器 Reopen closed editor&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Enter&lt;/td&gt;&#xA;          &lt;td&gt;输入保持打开 Enter Keep Open&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Tab&lt;/td&gt;&#xA;          &lt;td&gt;打开下一个 Open next&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Tab&lt;/td&gt;&#xA;          &lt;td&gt;打开上一个 Open previous&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K P&lt;/td&gt;&#xA;          &lt;td&gt;复制活动文件的路径 Copy path of active file&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K R&lt;/td&gt;&#xA;          &lt;td&gt;显示资源管理器中的活动文件 Reveal active file in Explorer&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K O&lt;/td&gt;&#xA;          &lt;td&gt;显示新窗口/实例中的活动文件 Show active file in new window/instance&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;显示-display&#34;&gt;显示 Display&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F11&lt;/td&gt;&#xA;          &lt;td&gt;切换全屏 Toggle full screen&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + 0&lt;/td&gt;&#xA;          &lt;td&gt;切换编辑器布局 Toggle editor layout&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + = / -&lt;/td&gt;&#xA;          &lt;td&gt;放大/缩小 Zoom in/out&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + B&lt;/td&gt;&#xA;          &lt;td&gt;切换侧栏可见性 Toggle Sidebar visibility&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + E&lt;/td&gt;&#xA;          &lt;td&gt;显示浏览器/切换焦点 Show Explorer / Toggle focus&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + F&lt;/td&gt;&#xA;          &lt;td&gt;显示搜索 Show Search&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + G&lt;/td&gt;&#xA;          &lt;td&gt;显示 Git Show Git&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + D&lt;/td&gt;&#xA;          &lt;td&gt;显示调试 Show Debug&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + X&lt;/td&gt;&#xA;          &lt;td&gt;显示扩展 Show Extensions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + H&lt;/td&gt;&#xA;          &lt;td&gt;替换文件 Replace in files&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + J&lt;/td&gt;&#xA;          &lt;td&gt;切换搜索详细信息 Toggle Search details&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + C&lt;/td&gt;&#xA;          &lt;td&gt;打开新命令提示符/终端 Open new command prompt/terminal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift +U&lt;/td&gt;&#xA;          &lt;td&gt;显示输出面板 Show Output panel&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + V&lt;/td&gt;&#xA;          &lt;td&gt;切换 Markdown 预览 Toggle Markdown preview&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K V&lt;/td&gt;&#xA;          &lt;td&gt;从旁边打开 Markdown 预览 Open Markdown preview to the side&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Z&lt;/td&gt;&#xA;          &lt;td&gt;打开禅模式（ Esc 键退出） Zen Mode (Esc Esc to ecit)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;调试-debug&#34;&gt;调试 Debug&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F9&lt;/td&gt;&#xA;          &lt;td&gt;切换断点 Toggle breakpoint&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F5&lt;/td&gt;&#xA;          &lt;td&gt;开始/继续 Start/Continue&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + F5&lt;/td&gt;&#xA;          &lt;td&gt;停止 Stop&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F11 / Shift + F11&lt;/td&gt;&#xA;          &lt;td&gt;下一步/上一步 Step into/out&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F10&lt;/td&gt;&#xA;          &lt;td&gt;跳过 Step over&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + I&lt;/td&gt;&#xA;          &lt;td&gt;显示悬停 Show hover&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;集成终端-integrated-terminal&#34;&gt;集成终端 Integrated terminal&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + `&lt;/td&gt;&#xA;          &lt;td&gt;显示集成终端 Show integrated terminal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + `&lt;/td&gt;&#xA;          &lt;td&gt;创建新终端 Create new terminal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + C&lt;/td&gt;&#xA;          &lt;td&gt;复制选定 Copy selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + V&lt;/td&gt;&#xA;          &lt;td&gt;粘贴到活动端子 Paste into active terminal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + ↑ / ↓&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下滚动 Scroll up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + PgUp / PgDown&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下滚动页面 Scroll page up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Home / End&lt;/td&gt;&#xA;          &lt;td&gt;滚动到顶部/底部 Scroll to top/bottom&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Linux 下编译安装Protobuf</title>
      <link>https://ahang7.github.io/post/tools/installx/protoc/linux.install/</link>
      <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/tools/installx/protoc/linux.install/</guid>
      <description>&lt;p&gt;以Ubuntu22.04为例，使用CMake从源码安装Protobuf v3.25.4&lt;/p&gt;&#xA;&lt;p&gt;前期准备：&lt;/p&gt;&#xA;&lt;p&gt;首先安装&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install -y gcc g++ cmake git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;cmake 版本高于 3.15&lt;/p&gt;&#xA;&lt;p&gt;Ubuntu的官方源没有提供abseil安装包，需要手动安装&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/abseil/abseil-cpp.git  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; abseil-cpp  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir build &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; build  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake -DABSL_BUILD_TESTING&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ON -DABSL_USE_GOOGLETEST_HEAD&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ON -DCMAKE_CXX_STANDARD&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;14&lt;/span&gt; ..  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ldconfig&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开始安装&lt;code&gt;protobuf&lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone -b v3.23.2 https://github.com/protocolbuffers/protobuf.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; protobuf  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git submodule update --init --recursive&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake .  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install .  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ldconfig &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>mysql面试题</title>
      <link>https://ahang7.github.io/eightlessay/mysql/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/eightlessay/mysql/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>&lt;h2 id=&#34;0-sql语法&#34;&gt;0. SQL语法&lt;/h2&gt;&#xA;&lt;h3 id=&#34;01-count主键和count非主键结果会不同吗&#34;&gt;0.1 count主键和count非主键结果会不同吗？&lt;/h3&gt;&#xA;&lt;p&gt;分析：count()函数是返回表中某个列的非NULL值数量&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主键不能存储NULL值，所以count(主键)返回的结果，可以表示数据库中所有行数据的量&lt;/li&gt;&#xA;&lt;li&gt;非主键可以保存NULL值，所以count(非主键)返回表中非主键列的非NULL值的数量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;回答：&#xA;主键不能存NULL值，所以count主键代表统计表中所有行数据的数量&#xA;而非主键可以存储NULL值，所以count非主键返回的是表中这个列的非NULL值的数量&lt;/p&gt;&#xA;&lt;h2 id=&#34;一索引面试题&#34;&gt;一、索引面试题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-mysql有哪些索引&#34;&gt;1.1 MySQL有哪些索引？&lt;/h3&gt;&#xA;&lt;p&gt;分析：索引是由存储引擎来实现的，不同存储引擎支持的索引类型也是不同的，大多数存储引擎都是支持&lt;/p&gt;&#xA;&lt;p&gt;B+树索引，哈希索引，全文索引的区别：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;B+树索引：InnoDB引擎默认的索引，支持排序，分组，模糊查询等，并且性能稳定&lt;/li&gt;&#xA;&lt;li&gt;哈希索引：多用于等值查询，时间复杂度为O(1)，效率非常高，但不支持排序，范围查询以及模糊查询&lt;/li&gt;&#xA;&lt;li&gt;全文索引：一般用于查询文本中的关键字，而不是直接比较是否相等等，主要用来解决 WHERE name LIKE &amp;ldquo;%aaaa%&amp;rdquo;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html&#34;&gt;dev.mysql.com&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;回答：我了解到Mysql支持B+树索引，哈希索引，全文索引这三种索引类型，比较常用的是B+树索引，因为它是InnoDB引擎默认使用的索引类型，支持排序，分组，范围查询，模糊查询等&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-innodb引擎的索引数据结构是什么&#34;&gt;1.2 InnoDB引擎的索引数据结构是什么？&lt;/h3&gt;&#xA;&lt;p&gt;回答：InnoDB引擎是采用B+树作为索引的数据结构&lt;/p&gt;&#xA;&lt;h3 id=&#34;130-mysql为什么使用b树&#34;&gt;1.3.0 mysql为什么使用B+树？&lt;/h3&gt;&#xA;&lt;p&gt;分析：这里要回答对平衡树、红黑树，跳表，B树等的对比&lt;/p&gt;&#xA;&lt;p&gt;回答：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;B+树是多叉树，平衡二叉树、红黑树是二叉树，在同等数据量下，平衡二叉树、红黑树高度更高，磁盘IO次数更多，性能更差，而且它们会频繁执行在平衡过程，来保证树形结构平衡&lt;/li&gt;&#xA;&lt;li&gt;和B+树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存&lt;/li&gt;&#xA;&lt;li&gt;和B+树相比，B树的数据结构存储在全部节点，对范围查询不友好，非叶子节点存储了数据，导致内存中难以放下全部非叶子节点，如果内存放不下非叶子节点，那么意味着查询非叶子节点的时候都需要磁盘IO&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;学习：&lt;a href=&#34;https://leeshengis.com/archives/672553&#34;&gt;10｜数据库索引：为什么MySQL用B+树而不用B树？ | JUST DO IT&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;13-为什么索引用b树而不用红黑树&#34;&gt;1.3 为什么索引用B+树？而不用红黑树？&lt;/h3&gt;&#xA;&lt;p&gt;分析：InnoDB引擎的数据是存储在磁盘上的，所以选择数据结构的第一优先级是考虑从磁盘查询数据的成本，如果树的高度越高，意味着磁盘I/O就越多，这样会影响查询性能&lt;/p&gt;&#xA;&lt;p&gt;对于N个叶子节点的B+树，其搜索复杂度为&lt;code&gt;O(logdN)&lt;/code&gt; ，其中d表示节点允许的最大子节点个数为d&lt;/p&gt;&#xA;&lt;p&gt;在实际的应用中，即使数据达到了千万级别，B+树的高度依旧维持在3&lt;del&gt;4层，也就是说一次数据查询操作只需要做3&lt;/del&gt;4次的磁盘I/O操作&lt;/p&gt;&#xA;&lt;p&gt;而红黑树本质上是二叉树，二叉树的每个父节点的儿子节点只能是2个，意味着其搜索复杂度为&lt;code&gt;O(logN)&lt;/code&gt; ，这已经比B+Tree高出不少，因此二叉树搜索到目标数据所经历的磁盘I/O次数要更多&lt;/p&gt;&#xA;&lt;p&gt;回答：主要原因是随着数据量的增多，红黑树的树高会比B+树高 ，这样查询数据的时候会面临更多的磁盘I/O，查询性能没那么好。&lt;/p&gt;&#xA;&lt;p&gt;因为红黑树本质是二叉树，而b+树是多叉树，存储相同数量的数据量下，红黑树的树高会比B+树的树高，由于InnoDB引擎的数据都是存储在磁盘上的，如果树的高度过高，意味着磁盘I/O就越多，会影响到查询性能，所以InnoDB引擎的索引选择了B+树&lt;/p&gt;&#xA;&lt;h3 id=&#34;14-为什么索引用b树而不是b树&#34;&gt;1.4 为什么索引用B+树？而不是B树？&lt;/h3&gt;&#xA;&lt;p&gt;分析：考察对B+树 和 B 树的理解，可以从三个角度分析&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;磁盘I/O角度&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;范围查询角度&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;增删改查角度&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;回答：我觉得主要有三个原因：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;B+树的磁盘读写代价更低：B+树只有叶子节点存储索引和数据，非叶子节点只存放索引，而B树所有节点都会存放索引和数据，因此存储相同数据量的情况下，B+树可以比B树更矮胖，查询叶子节点的磁盘I/O次数也少&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;B+树便于范围查询：MySQL经常需要使用范围查询，B+树所有叶子节点间都有链表进行连接，这种设计对范围查询查询非常有帮助，B树没有将所有叶子节点用链表串联起来的结构，只能用中序遍历来完成范围查询，这会比B+树范围查询涉及多个节点的磁盘I/O操作，一次范围查询的效率不如B+树&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;B+树增删改查效率更加稳定：B+树有大量冗余节点，这些冗余数据可以让B+树在插入、删除的效率都更高，比如删除根节点的时候，不会像B树那样会发生复杂的树的变化。另外，B+树把所有指向数据的指针都放在叶子节点，因此查询、插入、删除数据都需要走到最后一层，这不同于B树可能在任意一层找到数据，所以B+树更为稳定&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;15-为什么索引用b树而不用哈希表&#34;&gt;1.5 为什么索引用B+树？而不用哈希表？&lt;/h3&gt;&#xA;&lt;p&gt;分析：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;哈希表的数据是散列分布的，不具有序性，无法进行范围和排序&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;哈希表存在哈希冲突，哈希冲突严重，也会降低查询效率&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;回答：MySQL会有会多范围和排序的场景，虽然哈希表的搜索时间复杂度是O(1)，但是由于哈希表的数据都是通过哈希函数计算后散列分布的，所以哈希表索引不支持范围和排序操作，不支持联合索引最左匹配原则，如果重复键比较多，还容易操作哈希碰撞导致效率进一步降低。而B+树可以满足这些应用&lt;/p&gt;&#xA;&lt;h3 id=&#34;16聚簇索引和非聚簇索引有什么区别&#34;&gt;1.6聚簇索引和非聚簇索引有什么区别？&lt;/h3&gt;&#xA;&lt;p&gt;分析：先说聚簇索引和非聚簇索引B+树叶子节点存放内容的区别，然后再引出回表查询和覆盖索引查询&lt;/p&gt;</description>
    </item>
    <item>
      <title>todo list</title>
      <link>https://ahang7.github.io/post/todo.list/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/todo.list/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-iam&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-bitDB&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-distributedFS&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-asyncflow&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-timker&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-flashSale&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-pay&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-tcpZinx&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-anyX&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-rpc&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Photoswipe Gallery Sample</title>
      <link>https://ahang7.github.io/beautifulhugo/2017-03-20-photoswipe-gallery-sample/</link>
      <pubDate>Mon, 20 Mar 2017 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2017-03-20-photoswipe-gallery-sample/</guid>
      <description>&lt;p&gt;Beautiful Hugo adds a few custom shortcodes created by &lt;a href=&#34;https://www.liwen.id.au/heg/&#34;&gt;Li-Wen Yip&lt;/a&gt; and &lt;a href=&#34;https://github.com/GjjvdBurg/HugoPhotoSwipe&#34;&gt;Gert-Jan van den Berg&lt;/a&gt; for making galleries with &lt;a href=&#34;https://photoswipe.com&#34;&gt;PhotoSwipe&lt;/a&gt; .&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;gallery caption-position-bottom caption-effect-fade hover-effect-zoom hover-transition&#34; itemscope itemtype=&#34;http://schema.org/ImageGallery&#34;&gt;&#xA;&#x9;  &#xA;  &#xA;  &lt;link rel=&#34;stylesheet&#34; href=&#34;https://ahang7.github.io/css/hugo-easy-gallery.css&#34; /&gt;&#xA;  &lt;div class=&#34;box&#34; &gt;&#xA;    &lt;figure  itemprop=&#34;associatedMedia&#34; itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;&#xA;      &lt;div class=&#34;img&#34; style=&#34;background-image: url(&#39;https://ahang7.github.io//img/hexagon-thumb.jpg&#39;);&#34;&gt;&#xA;        &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://ahang7.github.io/img/hexagon-thumb.jpg&#34; alt=&#34;/img/hexagon-thumb.jpg&#34;/&gt;&#xA;      &lt;/div&gt;&#xA;      &lt;a href=&#34;https://ahang7.github.io/img/hexagon.jpg&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;&#xA;    &lt;/figure&gt;&#xA;  &lt;/div&gt;&#xA;&#xA;  &#xA;  &#xA;  &lt;div class=&#34;box&#34; &gt;&#xA;    &lt;figure  itemprop=&#34;associatedMedia&#34; itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;&#xA;      &lt;div class=&#34;img&#34; style=&#34;background-image: url(&#39;https://ahang7.github.io//img/sphere-thumb.jpg&#39;);&#34;&gt;&#xA;        &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://ahang7.github.io/img/sphere-thumb.jpg&#34; alt=&#34;Sphere&#34;/&gt;&#xA;      &lt;/div&gt;&#xA;      &lt;a href=&#34;https://ahang7.github.io/img/sphere.jpg&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;&#xA;        &lt;figcaption&gt;&#xA;            &lt;p&gt;Sphere&lt;/p&gt;&#xA;        &lt;/figcaption&gt;&#xA;    &lt;/figure&gt;&#xA;  &lt;/div&gt;&#xA;&#xA;  &#xA;  &#xA;  &lt;div class=&#34;box&#34; &gt;&#xA;    &lt;figure  itemprop=&#34;associatedMedia&#34; itemscope itemtype=&#34;http://schema.org/ImageObject&#34;&gt;&#xA;      &lt;div class=&#34;img&#34; style=&#34;background-image: url(&#39;https://ahang7.github.io//img/triangle-thumb.jpg&#39;);&#34;&gt;&#xA;        &lt;img itemprop=&#34;thumbnail&#34; src=&#34;https://ahang7.github.io/img/triangle-thumb.jpg&#34; alt=&#34;This is a long comment about a triangle&#34;/&gt;&#xA;      &lt;/div&gt;&#xA;      &lt;a href=&#34;https://ahang7.github.io/img/triangle.jpg&#34; itemprop=&#34;contentUrl&#34;&gt;&lt;/a&gt;&#xA;        &lt;figcaption&gt;&#xA;            &lt;p&gt;Triangle&lt;/p&gt;&#xA;        &lt;/figcaption&gt;&#xA;    &lt;/figure&gt;&#xA;  &lt;/div&gt;&#xA;&#xA;&#xA;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Big Image Sample</title>
      <link>https://ahang7.github.io/beautifulhugo/2017-03-07-bigimg-sample/</link>
      <pubDate>Tue, 07 Mar 2017 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2017-03-07-bigimg-sample/</guid>
      <description>&lt;p&gt;The image banners at the top of the page are refered to as &amp;ldquo;bigimg&amp;rdquo; in this theme. They are optional, and one more more can be specified. If more than one is specified, the images rotate every 10 seconds. In the front matter, bigimgs are specified using an array of hashes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Math Sample</title>
      <link>https://ahang7.github.io/beautifulhugo/2017-03-05-math-sample/</link>
      <pubDate>Sun, 05 Mar 2017 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2017-03-05-math-sample/</guid>
      <description>&lt;p&gt;KaTeX can be used to generate complex math formulas server-side.&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;\phi = \frac{(1+\sqrt{5})}{2} = 1.6180339887\cdots&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;Additional details can be found on &lt;a href=&#34;https://github.com/KaTeX/KaTeX&#34;&gt;GitHub&lt;/a&gt; or on the &lt;a href=&#34;https://katex.org/&#34;&gt;project homepage&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Code Sample</title>
      <link>https://ahang7.github.io/beautifulhugo/2016-03-08-code-sample/</link>
      <pubDate>Tue, 08 Mar 2016 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2016-03-08-code-sample/</guid>
      <description>&lt;p&gt;The following are two code samples using syntax highlighting.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flake it till you make it</title>
      <link>https://ahang7.github.io/beautifulhugo/2015-02-26-flake-it-till-you-make-it/</link>
      <pubDate>Thu, 26 Feb 2015 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2015-02-26-flake-it-till-you-make-it/</guid>
      <description>&lt;p&gt;Under what circumstances should we step off a path? When is it essential that we finish what we start? If I bought a bag of peanuts and had an allergic reaction, no one would fault me if I threw it out. If I ended a relationship with a woman who hit me, no one would say that I had a commitment problem. But if I walk away from a seemingly secure route because my soul has other ideas, I am a flake?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Test markdown</title>
      <link>https://ahang7.github.io/beautifulhugo/2015-02-20-test-markdown/</link>
      <pubDate>Fri, 20 Feb 2015 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2015-02-20-test-markdown/</guid>
      <description>&lt;p&gt;You can write regular &lt;a href=&#34;https://markdowntutorial.com/&#34;&gt;markdown&lt;/a&gt; here and &lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; will automatically convert it to a nice webpage.  I strongly encourage you to &lt;a href=&#34;https://markdowntutorial.com/&#34;&gt;take 5 minutes to learn how to write in markdown&lt;/a&gt; - it&amp;rsquo;ll teach you how to transform regular text into bold/italics/headings/tables/etc.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Here is some bold text&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;here-is-a-secondary-heading&#34;&gt;Here is a secondary heading&lt;/h2&gt;&#xA;&lt;p&gt;Here&amp;rsquo;s a useless table:&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Number&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Next number&lt;/th&gt;&#xA;          &lt;th style=&#34;text-align: left&#34;&gt;Previous number&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Five&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Six&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Four&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Ten&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Eleven&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Nine&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Seven&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Eight&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Six&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Two&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;Three&lt;/td&gt;&#xA;          &lt;td style=&#34;text-align: left&#34;&gt;One&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;How about a yummy crepe?&lt;/p&gt;</description>
    </item>
    <item>
      <title>To be</title>
      <link>https://ahang7.github.io/beautifulhugo/2015-02-13-hamlet-monologue/</link>
      <pubDate>Fri, 13 Feb 2015 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2015-02-13-hamlet-monologue/</guid>
      <description>&lt;p&gt;To be, or not to be&amp;ndash;that is the question:&#xA;Whether &amp;rsquo;tis nobler in the mind to suffer&#xA;The slings and arrows of outrageous fortune&#xA;Or to take arms against a sea of troubles&#xA;And by opposing end them. To die, to sleep&amp;ndash;&#xA;No more&amp;ndash;and by a sleep to say we end&#xA;The heartache, and the thousand natural shocks&#xA;That flesh is heir to. &amp;lsquo;Tis a consummation&#xA;Devoutly to be wished. To die, to sleep&amp;ndash;&#xA;To sleep&amp;ndash;perchance to dream: ay, there&amp;rsquo;s the rub,&#xA;For in that sleep of death what dreams may come&#xA;When we have shuffled off this mortal coil,&#xA;Must give us pause. There&amp;rsquo;s the respect&#xA;That makes calamity of so long life.&#xA;For who would bear the whips and scorns of time,&#xA;Th&amp;rsquo; oppressor&amp;rsquo;s wrong, the proud man&amp;rsquo;s contumely&#xA;The pangs of despised love, the law&amp;rsquo;s delay,&#xA;The insolence of office, and the spurns&#xA;That patient merit of th&amp;rsquo; unworthy takes,&#xA;When he himself might his quietus make&#xA;With a bare bodkin? Who would fardels bear,&#xA;To grunt and sweat under a weary life,&#xA;But that the dread of something after death,&#xA;The undiscovered country, from whose bourn&#xA;No traveller returns, puzzles the will,&#xA;And makes us rather bear those ills we have&#xA;Than fly to others that we know not of?&#xA;Thus conscience does make cowards of us all,&#xA;And thus the native hue of resolution&#xA;Is sicklied o&amp;rsquo;er with the pale cast of thought,&#xA;And enterprise of great pitch and moment&#xA;With this regard their currents turn awry&#xA;And lose the name of action. &amp;ndash; Soft you now,&#xA;The fair Ophelia! &amp;ndash; Nymph, in thy orisons&#xA;Be all my sins remembered.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dear diary</title>
      <link>https://ahang7.github.io/beautifulhugo/2015-01-27-dear-diary/</link>
      <pubDate>Tue, 27 Jan 2015 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2015-01-27-dear-diary/</guid>
      <description>&lt;p&gt;What is it with that Mary girl?  Dragging me to school every day. As if I had a choice.  What you don&amp;rsquo;t hear in those nursery rhymes is that she starves me if I don&amp;rsquo;t go to school with her; it&amp;rsquo;s the only way I can stay alive!  I&amp;rsquo;m thinking about being adopted by Little Bo Peep, sure I may get lost, but anything is better than being with Mary and those little brats at school (shudder, shudder).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Soccer</title>
      <link>https://ahang7.github.io/beautifulhugo/2015-01-19-soccer/</link>
      <pubDate>Mon, 19 Jan 2015 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2015-01-19-soccer/</guid>
      <description>&lt;p&gt;From Wikipedia:&lt;/p&gt;&#xA;&lt;p&gt;Association football, more commonly known as football or soccer,[2] is a sport played between two teams of eleven players with a spherical ball. It is played by 250 million players in over 200 countries, making it the world&amp;rsquo;s most popular sport.[3][4][5][6] The game is played on a rectangular field with a goal at each end. The object of the game is to score by getting the ball into the opposing goal.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pirates arrrr</title>
      <link>https://ahang7.github.io/beautifulhugo/2015-01-15-pirates/</link>
      <pubDate>Thu, 15 Jan 2015 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2015-01-15-pirates/</guid>
      <description>&lt;p&gt;Piracy is typically an act of robbery or criminal violence at sea. The term can include acts committed on land, in the air, or in other major bodies of water or on a shore. It does not normally include crimes committed against persons traveling on the same vessel as the perpetrator (e.g. one passenger stealing from others on the same vessel). The term has been used throughout history to refer to raids across land borders by non-state agents.&lt;/p&gt;</description>
    </item>
    <item>
      <title>First post!</title>
      <link>https://ahang7.github.io/beautifulhugo/2015-01-04-first-post/</link>
      <pubDate>Mon, 05 Jan 2015 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/beautifulhugo/2015-01-04-first-post/</guid>
      <description>&lt;p&gt;This is my first post, how exciting!&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/backend-project/redis-go/build-my-own-redis-in-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/backend-project/redis-go/build-my-own-redis-in-go/</guid>
      <description>&lt;h2 id=&#34;bind-to-a-port&#34;&gt;Bind to a port&lt;/h2&gt;&#xA;&lt;p&gt;使用&lt;code&gt;net&lt;/code&gt; 开启一个TCP服务，监听端口6379&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// You can use print statements as follows for debugging, they&amp;#39;ll be visible when running tests.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Logs from your program will appear here!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// Uncomment this block to pass the first stage&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;0.0.0.0:6379&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Failed to bind to port 6379&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Error accepting connection: &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Redis 客户端和服务器使用 TCP 相互通信。&lt;/p&gt;&#xA;&lt;h2 id=&#34;respond-to-ping&#34;&gt;Respond to PING&lt;/h2&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/eightlessay/network/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/eightlessay/network/http/</guid>
      <description>&lt;h2 id=&#34;http的协议有什么特点&#34;&gt;HTTP的协议有什么特点？&lt;/h2&gt;&#xA;&lt;p&gt;HTTP协议&lt;strong&gt;基于文本传输&lt;/strong&gt;的，&lt;strong&gt;支持不同的****数据格式&lt;/strong&gt;，例如HTML、JSON、XML等数据格式，并且&lt;strong&gt;http是无状态的&lt;/strong&gt;，每个http请求之间相互独立，&lt;strong&gt;采用了请求-应答模式&lt;/strong&gt;，&lt;strong&gt;有很好的扩展性&lt;/strong&gt;，可以通过扩展头部、方法等支持行方式&lt;/p&gt;&#xA;&lt;h2 id=&#34;http报文格式怎么分割&#34;&gt;HTTP报文格式？怎么分割&lt;/h2&gt;&#xA;&lt;p&gt;http的报文格式分为请求头、请求行、请求体，请求头包含了请求方式、url、http版本，请求行包含了key-value对的信息，有connection，content-lenth等字段，请求体包含了实际的请求数据；请求头和请求行通过/r/n进行分割，请求行和请求体通过一行空白行进行分割&lt;/p&gt;&#xA;&lt;h2 id=&#34;http有什么方法&#34;&gt;HTTP有什么方法？&lt;/h2&gt;&#xA;&lt;p&gt;GET、PUT、DELETE、post、head、options、trace、connect&lt;/p&gt;&#xA;&lt;h2 id=&#34;哪些http方法是安全的哪些是幂等的&#34;&gt;哪些http方法是安全的？哪些是幂等的&lt;/h2&gt;&#xA;&lt;p&gt;get、head是安全的&#xA;post、put、delete是不安全的&lt;/p&gt;&#xA;&lt;p&gt;get、head、put、delete是幂等的&#xA;post是不幂等的&lt;/p&gt;&#xA;&lt;h2 id=&#34;get和post请求的区别追问get请求一定是安全且幂等的吗&#34;&gt;GET和POST请求的区别？追问：GET请求一定是安全且幂等的吗？&lt;/h2&gt;&#xA;&lt;p&gt;get请求是从服务器获取资源，post请求向服务器提交数据，&lt;/p&gt;&#xA;&lt;p&gt;get请求是读操作，是安全且幂等的；post请求因为会修改服务器的资源，且多次post请求会创建多个资源，所以是不安全且不幂等的&#xA;get请求一般是将请求参数放在url的查询字符串中，浏览器对url的长度有限制，所以get请求的请求参数有长度限制。post请求的数据放在请求体，post请求的请求参数没有长度限制&lt;/p&gt;&#xA;&lt;h2 id=&#34;http有哪些状态码&#34;&gt;HTTP有哪些状态码？&lt;/h2&gt;&#xA;&lt;p&gt;100类：属于提示信息，为协议处理中的中间状态&#xA;200类：表示服务器成功处理客户端的请求&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;200：表示成功处理，返回期望的结果&lt;/li&gt;&#xA;&lt;li&gt;204：与200状态码相似，但是响应头没有body数据&lt;/li&gt;&#xA;&lt;li&gt;206：http分块下载或断点续传的几次，&#xA;300类：表示请求的资源发生了变动，需要客户端用新的URL重新发送请求，就是重定向&lt;/li&gt;&#xA;&lt;li&gt;301：永久性的重定向，后续请求可以直接重定向访问&lt;/li&gt;&#xA;&lt;li&gt;302：临时访问，&lt;/li&gt;&#xA;&lt;li&gt;304：&#xA;400类：表示客户端发送的报文有误，服务器无法处理&lt;/li&gt;&#xA;&lt;li&gt;403：请求的权限不够&lt;/li&gt;&#xA;&lt;li&gt;404：请求的资源不存在&#xA;500类：表示服务器处理 时内部发生了错误，属于服务器端的错误码&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;什么情况下会出现502错误码&#34;&gt;什么情况下会出现502错误码？&lt;/h2&gt;&#xA;&lt;p&gt;502（Bad GateWay）表示码表示服务器在充当网关或代理时，在尝试满足请求时从它访问的入站服务器接收到无效响应&#xA;如果客户端访问服务是通过nginx来反向代理到应用服务器，那么如果应用服务器出现故障，导致nginx无法从应用服务获得响应，这时候nginx就会返回502错误码给客户端&lt;/p&gt;&#xA;&lt;h2 id=&#34;有个服务出现504错误码这个服务出现了什么问题&#34;&gt;有个服务出现504错误码，这个服务出现了什么问题&lt;/h2&gt;&#xA;&lt;p&gt;504是网关超时错误，通过nginx将请求代理到后端应用，后端程序没有在规定时间内返回数据，需要开发检查接口超时问题，比如是否出现死循环、sql慢查询等&lt;/p&gt;&#xA;&lt;h2 id=&#34;重定向是哪一类状态码临时重定向和永久重定向有什么区别&#34;&gt;重定向是哪一类状态码？临时重定向和永久重定向有什么区别？&lt;/h2&gt;&#xA;&lt;p&gt;重定向是300类状态码，301表示永久重定向，302表示临时重定向&#xA;永久重定向，客户端会记忆重定向后的url，下次访问的时候不需要访问旧url，直接跳转新url访问&#xA;临时重定向，客户端会收到302状态码，不会记忆重定向后的url，下次访问依旧访问旧url，再跳转到新的url&lt;/p&gt;&#xA;&lt;h2 id=&#34;http11和20的区别&#34;&gt;HTTP1.1和2.0的区别&lt;/h2&gt;&#xA;&lt;p&gt;2.0引入stream概念，可以在同一个tcp连接中，实现并发传输，而1.1不能并发传输，必须在一个请求结束之后才能进行下一个请求应答，浏览器是通过建立多个tcp连接，实现http1.1的并发，比较消耗内存&lt;/p&gt;&#xA;&lt;p&gt;报文改进，1.1发生的是文本数据，2.0发生二进制数据，通过HPACK算法压缩HTTP头部，提高了传输效率&lt;/p&gt;&#xA;&lt;p&gt;http2.0支持服务器主动推送数据&lt;/p&gt;&#xA;&lt;h2 id=&#34;http20和http30的区别&#34;&gt;HTTP2.0和HTTP3.0的区别？&lt;/h2&gt;&#xA;&lt;p&gt;HTTP2.0和HTTP3.0的最大区别是传输层使用的协议不同了，HTTP2.0使用的是TCP协议连接，HTTP3.0使用UDP协议；&lt;/p&gt;&#xA;&lt;p&gt;HTTP2.0会出现TCP队头阻塞问题，（http2.0的tcp阻塞问题，是因为http2.0的并发传输是在一条TCP连接上实现的，在传输过程中，如果某个stream发生了丢包，服务端不仅不能处理这个stream，也不会处理其他的stream，必须等丢失的包重传，才能继续处理其他stream，这个就发生了tcp队头阻塞），但是HTTP3.0通过一个在UDP协议上实现了一个可靠的QUIC协议，当stream发生丢包时，只会阻塞这个stream，其他stream不会受影响&lt;/p&gt;&#xA;&lt;p&gt;http3.0建立连接比http2.0高效，http3.0：3次握手就能建立连接+TLS握手成功；http2.0需要3次TCP握手+TLS四次握手&lt;/p&gt;&#xA;&lt;p&gt;http3.0在网络切换的环境下无需重新建立连接，通过在应用层的唯一id来确定连接&lt;/p&gt;&#xA;&lt;h2 id=&#34;简述jwt的原理和校验机制&#34;&gt;简述JWT的原理和校验机制&lt;/h2&gt;&#xA;&lt;p&gt;jwt的数据个数是header.payload.signature，头部、负载、签名三部分组成，&lt;/p&gt;&#xA;&lt;p&gt;header包含：令牌的类型以及令牌签名的算法&lt;/p&gt;&#xA;&lt;p&gt;payload：向服务器传递的数据，比如包含认证信息&lt;/p&gt;&#xA;&lt;p&gt;签名：对前面两部分的签名，防止数据篡改（使用在Header中公开的特点签名算法，通过特定的密钥（由服务器进行保密），对前面两部分进行加密计算&lt;/p&gt;&#xA;&lt;p&gt;验证JWT令牌的流程：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务端接收到客户端发来的JWT，取出header+payload，然后服务端根据自己的加密密钥进行加密计算&lt;/li&gt;&#xA;&lt;li&gt;把加密的结果和客户端发来JWT的signature进行对比，如果完全相同，则表示前面两部分没有动，如果不相同表示被篡改了&lt;/li&gt;&#xA;&lt;li&gt;当令牌没有被篡改后，服务端可以进行其它验证：令牌过期，用户是否有权限访问等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;jwt令牌是由3个部分组成，分别是头部、负载、签名，头部包括类型和签名算法，负载包含了用户信息等数据，签名是对头部和负载两部分的签名，使用头部的签名算法，通过服务器的密钥对前面两部分内容进行加密计算&lt;/p&gt;&#xA;&lt;p&gt;校验jwt的过程是服务端接收到客户端发过来的jwt令牌后，服务端会取出头部和负载数据，然后用自己的密钥对头部和负载进行加密计算，将得到的加密结果和客户端发送过来的jwt的签名机械能对比，如果相同，表示前面两部分没有内中间人篡改，这个时候服务器可以进行其他检查，比如检查jwt是否过期，如果没有问题，正常执行业务逻辑&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是跨域什么情况下会发生跨域&#34;&gt;什么是跨域？什么情况下会发生跨域？&lt;/h2&gt;&#xA;&lt;p&gt;当网页尝试访问不同源的资源的使用，就会发生跨域，只要域名、协议、端口这三个信息任意一个不同，都认为是不同源的URL&#xA;可以用跨域资源共享技术，在服务器需要的响应头上添加Access-Control-Allow-Origin的字段，&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是restfulrestful请求的url有什么特点&#34;&gt;什么是Restful？RestFul请求的url有什么特点？&lt;/h2&gt;&#xA;&lt;p&gt;restful是一种api接口设计规范，用url定位资源，用http方法表示接口的动作，用http状态码表示接口处理的情况&lt;/p&gt;&#xA;&lt;h2 id=&#34;http和https有什么区别&#34;&gt;HTTP和HTTPS有什么区别？&lt;/h2&gt;&#xA;&lt;p&gt;安全性：HTTP使用明文传输，HTTPS通过SSL/TLS协议对数据进行加密处理，提供更高的安全性和数据保护&lt;/p&gt;&#xA;&lt;p&gt;建立连接：HTTP建立只需要TCP三次握手；HTTPS在TCP三次握手后还需要进行SSL/TLS的握手过程&lt;/p&gt;&#xA;&lt;p&gt;端口：HTTP的端口是80；HTTPS的端口是443&lt;/p&gt;&#xA;&lt;p&gt;证书：HTTPS需要使用数字证书来验证服务器的身份，并确保数据传输的安全性。证书由第三方机构颁发，用于证明服务器的身份和所有权。而HTTP没有使用证书进行身份验证和加密。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/eightlessay/network/tcp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/eightlessay/network/tcp/</guid>
      <description>&lt;h2 id=&#34;tcp三次握手&#34;&gt;TCP三次握手&lt;/h2&gt;&#xA;&lt;h3 id=&#34;tcp头部有哪些字段&#34;&gt;TCP头部有哪些字段？&lt;/h3&gt;&#xA;&lt;p&gt;tcp报文段 ： tcp头部+tcp数据部分&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;tcp头部：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;源端口：16位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;目的端口：16位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;序号：32位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;确认号：32位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据偏移：4位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;保留：6位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;窗口：16位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;校验和：16位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;紧急指针：16位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;选项和填充：最多为40字节&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;控制位：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;URG：紧急指针标志，为1时标识紧急指针有效，该报文应该优先传送，为0则忽略紧急指针&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ACK：确认序号标志，为1时表示确认号有效。携带ACK标识的TCP报文段被称为确认报文段&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;RST：重置连接&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;SYN：表示请求建立一个连接&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;FIN：用于释放连接&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;PSH：为1表示带有push标志的数据，优先将这个报文提交给应用程序，而不是缓冲区排队&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;tcp头部的最长是60字节&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据部分：。。。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;回答：tcp头部主要是源端口、目的端口、序列号、确认号、标记位：SYN、RST、ACK、FIN、头部长度、窗口大小，可扩展的选项等&lt;/p&gt;&#xA;&lt;p&gt;其中序列号和确认号的大小为32位，序列号保证数据的有序性，接收方按照发送方顺序发来的数据来组装有序的数据；确认号保证数据的可靠性，当发送方已发送的数据，超过一段时间没收到确认报文，就会重传报文。&lt;/p&gt;&#xA;&lt;p&gt;源端口和目的端口的大小是16位，源端口是发送方的端口号，目的端口是接收方使用的端口号，端口的作用是标识TCP连接是哪个进程&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/Jummyer/p/11026966.html&#34;&gt;TCP之报文首部格式 - Jummyer - 博客园&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;tcp三次握手连接过程&#34;&gt;TCP三次握手连接过程&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;客户端和服务端一开始都处于close状态，服务端会监听一个端口，处于listen状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;第一次握手：客户端产生随机初始化序号，放到tcp报文头部的序号字段，同时把SYN标志设置位1，标识SYN报文。接着把SYN报文发送给服务端，之后客户端处于SYN_SEND状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;服务端收到SYN报文后，服务端也生成随机初始化序号，放到TCP报文头部的序号字段中，对客户端的初始化序号+1作为确认号，放到TCP报文头部的确认应答字段中，并将SYN和ACK标志设置为1，表示SYN-ACK报文，把报文发送给客户端，之后服务端处于SYN_RECD状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;客户端收到服务端SYN-ACK报文后，客户端发送一个ACK确认报文，该报文的确认号为服务端的初始化序号+1，并将ACK标志设置为1。客户端处于ESTABLISHED状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;服务端收到ACK确认报文，服务端也处于ESTABLISHED状态&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;以上就是TCP三次握手的过程&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B&#34;&gt;4.1 TCP 三次握手与四次挥手面试题&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;为什么需要三次握手两次握手不行吗&#34;&gt;为什么需要三次握手？两次握手不行吗？&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;避免历史连接的建立，避免资源浪费&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;三次握手可以确认客户端和服务端是否同时具备发送和接收的能力&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;如果第二次握手丢包会发送什么&#34;&gt;如果第二次握手丢包，会发送什么？&lt;/h3&gt;&#xA;&lt;p&gt;超时重传机制，第二次SYN-ACK报文中有&lt;/p&gt;&#xA;&lt;p&gt;第二次报文中的ACK，是第一次握手的确认报文，那么当第二次报文丢包时，会导致客户端一直没有接收到ACK而触发超时重传机制，重传SYN包，即第一次握手&lt;/p&gt;&#xA;&lt;p&gt;第二次报文中的SYN，是服务端建立TCP连接的报文，当第二次报文丢失后，客户端没有发送ACK报文，服务端没有收到第三次握手，于是服务端会触发超时重传机制，重传SYN-ACK报文&lt;/p&gt;&#xA;&lt;h3 id=&#34;如果第三次握手丢包会发生什么&#34;&gt;如果第三次握手丢包，会发生什么？&lt;/h3&gt;&#xA;&lt;p&gt;我的理解是第三次握手如果发生丢包，服务端会迟迟接收不到第三次握手的ACK包，触发超时重传机制，服务端会重新发生第二次握手的SYN-ACK包，直到最大重传次数的限制，或者收到第三次握手&lt;/p&gt;&#xA;&lt;h3 id=&#34;tcp的半连接队列和全连接队列&#34;&gt;TCP的半连接队列和全连接队列？&lt;/h3&gt;&#xA;&lt;p&gt;在tcp三次握手的时候，linux内核会维护两个队列，分别是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;syn队列：半连接队列&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;accept队列：全连接队列&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;服务端收到客户端发起的SYN请求后，内核会将为握手完成的连接存储到半连接队列，等待完成三次握手后转移到全连接队列&lt;/p&gt;&#xA;&lt;p&gt;全连接队列：服务端收到客户端的第三次握手，内核会将连接从半连接队列移除，然后创建新的完全连接，并将其添加到全连接队列，等待进程调用accept函数将连接取出&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/network/3_tcp/tcp_queue.html&#34;&gt;4.4 TCP 半连接队列和全连接队列&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;tcp四次挥手&#34;&gt;TCP四次挥手&lt;/h2&gt;&#xA;&lt;h3 id=&#34;tcp四次挥手的过程&#34;&gt;TCP四次挥手的过程&lt;/h3&gt;&#xA;&lt;p&gt;tcp的四次挥手（断开连接）是可以客户端或者服务端断开&lt;/p&gt;&#xA;&lt;p&gt;客户端关闭连接，此时会发生一个fin报文，之后客户端进入fin_wait_1状态，&lt;/p&gt;&#xA;&lt;p&gt;服务端收到fin报文后，将向客户端发送ack报文，接着服务端进入close_wait状态&lt;/p&gt;&#xA;&lt;p&gt;客户端接收到ack应答报文后，之后进入fin_wait_2状态&lt;/p&gt;&#xA;&lt;p&gt;等待服务端处理完数据后，向客户端发送fin报文，服务端进入last_ack状态&lt;/p&gt;&#xA;&lt;p&gt;客户端收到服务端的fin报文后，回一个ack应答报文，客户端进入time_wait状态&lt;/p&gt;&#xA;&lt;p&gt;服务端接收到ack报文后，进入close状态，至此服务端完成连接的关闭&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/eightlessay/network/%E7%BD%91%E7%BB%9C%E5%B1%82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/eightlessay/network/%E7%BD%91%E7%BB%9C%E5%B1%82/</guid>
      <description>&lt;h2 id=&#34;ping的原理简述&#34;&gt;ping的原理简述：&lt;/h2&gt;&#xA;&lt;p&gt;ping命令是用来探测目标ip地址是否可以访问&#xA;Ping是通过ICMP协议实现的，ping的时候，会向接收方发送回送请求的ICMP报文，对方接收到后，会回复类型为回送应答的ICMP报文&lt;/p&gt;&#xA;&lt;h2 id=&#34;交换机和路由器有什么区别&#34;&gt;交换机和路由器有什么区别？&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;交换机工作在MAC层，称为二层网络设备，主要负责数据帧的转发和交换，交换机会根据MAC地址来转发数据包，是实现局域网内设备的通信&lt;/li&gt;&#xA;&lt;li&gt;路由器工作在IP层，称为三层网络设备，主要负责IP数据包的转发和路由选择，路由器会根据IP地址来转发数据包，实现不同网络间的通信&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;ip地址和mac地址有什么区别&#34;&gt;IP地址和MAC地址有什么区别？&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;IP地址用于网络中唯一标识和定位设备，它是网络层使用的地址，用于实现不同网络之间的通信&lt;/li&gt;&#xA;&lt;li&gt;MAC地址用于局域网中唯一标识和定位设备，它在数据链路层使用的地址，实现局域网内设备之间的通信&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;nat协议&#34;&gt;NAT协议&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26992935&#34;&gt;网络地址转换协议NAT功能详解及NAT基础知识介绍&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/network/4_ip/ip_base.html&#34;&gt;5.1 IP 基础知识全家桶&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;192168110024中斜杠代表什么意思&#34;&gt;192.168.1.100/24中斜杠代表什么意思？&lt;/h2&gt;&#xA;&lt;p&gt;斜杠（/）后面的数字表示子网掩码的位数&lt;/p&gt;&#xA;&lt;p&gt;比如，192.168.1.100/24中的斜杠后面数字表示子网掩码的位数，子网掩码用于划分IP地址中的网络部分和主机部分。将子网掩码和IP地址进行与运算，就可以得到网络号&lt;/p&gt;&#xA;&lt;p&gt;具体来说：192.168.1.100/24表示前24位是网络部分，后8位是主机部分&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/eightlessay/network/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/eightlessay/network/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h2 id=&#34;osi的7层网络模型各层的协议有什么&#34;&gt;OSI的7层网络模型？各层的协议有什么？&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用层：确定进程间通信的性质以及满足用户需要以及提高网络和用户应用&lt;/li&gt;&#xA;&lt;li&gt;表示层：主要解决用户信息的语法表达&lt;/li&gt;&#xA;&lt;li&gt;会话层：复制建立、管理和终止表示层实体之间的通信会话&lt;/li&gt;&#xA;&lt;li&gt;传输层：实现网络不同主机上的用户进程间的数据通信，可靠和不可靠的传输&lt;/li&gt;&#xA;&lt;li&gt;网络层：本层通过IP寻址来建立两个节点之间的连接&lt;/li&gt;&#xA;&lt;li&gt;数据链路层：将上层数据封装成帧，用MAC地址访问媒介&lt;/li&gt;&#xA;&lt;li&gt;物理层：设备之间比特流的传输，物理接口&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;回答：&#xA;OSI参考模型有7层，应用层、表示层、会话层、传输层、网络层、数据链路层、物理层&#xA;应用层有HTTP、HTTPS，传输层有TCP和UDP协议，网络层有IP、ICMP、ARP协议&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;网络分层的好处：对各层之间进行解耦，层与层之间不产生关联，比如应用层HTTP协议从HTTP1.1升级到HTTP2.0的时候，不会对传输层和网络层有影响，或者网络层的IPv4协议升级到IPv6协议的时候，不会影响到应用，传输层&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;TCP/IP协议是将OSI模型的应用层、表示层、会话层统一为应用层，数据链路层和物理层统一为网络接口层&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;tcpip的四层网络模型&#34;&gt;TCP/IP的四层网络模型？&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;应用层&lt;/li&gt;&#xA;&lt;li&gt;传输层&lt;/li&gt;&#xA;&lt;li&gt;网络层&lt;/li&gt;&#xA;&lt;li&gt;数据链路层（网络接口层）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;五层因特网协议栈&#34;&gt;五层因特网协议栈？&lt;/h2&gt;&#xA;&lt;p&gt;应用层、运输层、网络层、链路层、物理层&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;OSI七层网络协议&lt;/th&gt;&#xA;          &lt;th&gt;TCP/IP四层概念模型&lt;/th&gt;&#xA;          &lt;th&gt;对于网络协议&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;应用层&lt;!-- raw HTML omitted --&gt;&amp;mdash;&lt;!-- raw HTML omitted --&gt;表示层&lt;!-- raw HTML omitted --&gt;&amp;mdash;&lt;!-- raw HTML omitted --&gt;会话层&lt;/td&gt;&#xA;          &lt;td&gt;应用层（4）&lt;/td&gt;&#xA;          &lt;td&gt;HTTP、TFTP、FTP、NFS、WAIS、SMTP&lt;!-- raw HTML omitted --&gt;&amp;ndash;&lt;!-- raw HTML omitted --&gt;Telnet、Rlogin、SNMP、Gopher&lt;!-- raw HTML omitted --&gt;&amp;ndash;&lt;!-- raw HTML omitted --&gt;SMTP、DNS&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;键入网址场景问题&#34;&gt;键入网址场景问题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;键入网址后期间发送了什么&#34;&gt;键入网址后，期间发送了什么？&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;http/https -&amp;gt; dns -&amp;gt; tcp -&amp;gt; ip -&amp;gt; arp&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;浏览器会解析网址，解析出域名，资源路径，端口等信息，构造HTTP请求报文&lt;/li&gt;&#xA;&lt;li&gt;将域名解析为IP地址，先查看系统缓存是否有域名信息，有的话返回IP地址；没有就查看本地host文件没有域名信息，有就返回IP地址；如果再没有就查看本地DNS服务器，如果本地DNS服务器中有域名信息，就返回IP地址，否则本地DNS服务器分别去根域名服务器-&amp;gt;顶级域名服务器-&amp;gt;权威域名服务器询问，最后拿到IP地址&lt;/li&gt;&#xA;&lt;li&gt;HTTP协议是基于TCP协议传输的，所以要先进行TCP三次握手，&lt;/li&gt;&#xA;&lt;li&gt;然后到网络层，加上IP头，同时填上目标IP地址和源IP地址&lt;/li&gt;&#xA;&lt;li&gt;然后到数据链路层，通过ARP协议，获取路由器的MAC地址，然后加上MAC头，填上目标MAC地址和源MAC地址&lt;/li&gt;&#xA;&lt;li&gt;然后到物理层，直接把数据包转发给路由器，路由器再通过下一跳，找到最终的目的服务器&lt;/li&gt;&#xA;&lt;li&gt;当双方完成三次握手后，如果是HTTP协议，客户端就会把HTTP请求发送给目标服务器；如果是HTTPS协议，还需要进行TLS四次握手，客户端才会把HTTP报文发送给目标服务器&lt;/li&gt;&#xA;&lt;li&gt;目标服务器收到HTTP报文后，返回HTTP响应消息，浏览器对响应消息进行解析渲染，呈现给用户&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;dns是如何解析的属于哪一层的协议&#34;&gt;DNS是如何解析的？属于哪一层的协议？&lt;/h3&gt;&#xA;&lt;p&gt;DNS属于应用层的协议，客户端在进行DNS解析时，首先会查看浏览器和操作系统是否缓存域名对应的IP地址，如果没有就向本地DNS服务器发出查询请求，接着本地DNS向根DNS发送查询请求，根DNS服务器返回顶级域名服务器地址，本地DNS服务器向顶级域名服务器发送查询请求，顶级域名服务器返回权威域名服务器的IP地址，本地DNS服务器再向权威域名服务器发出查询请求，权威域名服务器收到请求后，就返回域名对应的IP地址了，本地DNS服务器返回查询结果给客户端，然后将本次查询得到的结果保存到缓存里，以备下次使用&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/eightlessay/redis/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/eightlessay/redis/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>&lt;h2 id=&#34;面试题&#34;&gt;面试题：&lt;/h2&gt;&#xA;&lt;h3 id=&#34;string面试与分析&#34;&gt;String面试与分析&lt;/h3&gt;&#xA;&lt;p&gt;考点分析：集中在String的操作和底层实现&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-set一个已有的数据会发生什么&#34;&gt;1.1 Set一个已有的数据会发生什么？&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt; 常用操作&lt;/p&gt;&#xA;&lt;p&gt;**回答：**如果是同种类型的值，会覆盖原有值，同时会覆盖或者擦除键的过期时间&lt;/p&gt;&#xA;&lt;p&gt;set命令还可以直接把key抹除，例如列表键mylist，可以直接 set mylist newlist 来覆盖这个列表键。类似隐式的del（或者unlink）mylist + set&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;什么是列表键？即key-value种value是列表&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;12-浮点型在string是用什么表示&#34;&gt;1.2 浮点型在String是用什么表示？&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;分析：&lt;strong&gt;基础知识，String有三种编码模式，INT只针对整形，所以浮点型必然是&lt;/strong&gt;字符串&lt;/strong&gt;存储&lt;/p&gt;&#xA;&lt;p&gt;**回答：**将浮点数放入字符串对象，先将浮点数转换成字符串值，再保存转换所得的字符串值，所以浮点数在String对象中使用字符串值表示&lt;/p&gt;&#xA;&lt;h4 id=&#34;13-string可以有多大512m&#34;&gt;1.3 String可以有多大？（512M）&lt;/h4&gt;&#xA;&lt;p&gt;**分析：**基础知识，需要知道明确的数值，进一步思考为什么是这个值&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;回答：&lt;strong&gt;一个Redis字符串最大为&lt;/strong&gt;512M&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/pipizhen_/article/details/113308109&#34;&gt;Redis的String类型的最大长度是2^29-1 (536870911)，这是因为Redis的字符串大小限制在512M(1)&lt;/a&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_42348880/article/details/112357490&#34;&gt;。这个限制主要是出于内存管理和性能考虑。如果字符串过大，可能会导致内存使用效率低下，并且在网络传输时也会消耗更多的带宽。此外，处理大字符串也会占用更多的CPU资源。因此，Redis设计者选择了512M作为字符串的最大长度，以平衡内存使用、网络带宽和CPU资源之间的关系&lt;/a&gt; [from new bing chat]&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;14-redis中字符串是怎么实现的&#34;&gt;1.4 Redis中字符串是怎么实现的？&lt;/h4&gt;&#xA;&lt;p&gt;**分析：**分情况讲编码类型，分别应用在什么场景。EMBSTR编码和RAW编码的选择阈值（可以说版本差别，3.2之前是39，3.2版本之后是44）&lt;/p&gt;&#xA;&lt;p&gt;**回答：**redis字符串底层是String对象，String对象有三中编码方式：INT、EMBSTR、RAW。如果存储一个整形，可以用long表示的整数就以INT编码存储；如果存字符串，当字符串长度小于等于阈值（44）就使用EMBSTR编码；如果字符串大于阈值，则使用RAW编码。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Redis &amp;lt; 3.2 阈值=39，&amp;gt; 3.2 阈值=44&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;15-为什么embstr的阈值是44超级冷门&#34;&gt;1.5 为什么EMBSTR的阈值是44？（超级冷门）&lt;/h4&gt;&#xA;&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;redis默认使用jemalloc作为内存分配器&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;jemalloc是以64字节作为内存单元做内存分配，如果超出了64个字节就超过了一个内存单元，尽量在一个内存单元，是为了减少内存寻址，又不会消耗分配过多没用到的内存，&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;围绕64字节的关键分界分析版本变化，Redis的字符串对象是由一个redisObject+sdshdr两部分组成，redisObject大小为4+4+24+32+64 = 128bits = 16bytes，其中的ptr是64，是为了方便各种编译器和目标平台上使用&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;sdshdr8占用内存大小: 1byte + 1byte + 1byte + 内联数组的大小，由于内联数组中还有一个&amp;rsquo;\0&amp;rsquo;占位一个字符，所以能用的大小为64-16(redisObject)-3(sdshdr非内容属性)-1(&amp;rsquo;\0&amp;rsquo;)=44&lt;/p&gt;&#xA;&lt;p&gt;**回答：**redis是使用jemalloc内存分配器，Redis以64字节为阈值区分大小字符串&lt;/p&gt;&#xA;&lt;p&gt;所以EMBSTR的边界数组，是受到64这个阈值影响&lt;/p&gt;&#xA;&lt;p&gt;redis对象占用的内存大小由redisObject和sdshdr两个部分组成，redisObject占用16字节，sdshdr中已分配、已申请、标记三个字段占用了3个字节。&amp;rsquo;\0&amp;rsquo;占用了一个字节，能够存放的数据就是64 - (16 + 3 + 1) = 44&lt;/p&gt;&#xA;&lt;h4 id=&#34;16-为什么embstr的阈值之前是39超级冷门&#34;&gt;1.6 为什么EMBSTR的阈值之前是39？（超级冷门）&lt;/h4&gt;&#xA;&lt;p&gt;&amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/post/basic/git/git-commands/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/git/git-commands/</guid>
      <description></description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%B9%B6%E5%8F%91%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%B9%B6%E5%8F%91%E6%A6%82%E5%BF%B5/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>About me</title>
      <link>https://ahang7.github.io/page/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/page/about/</guid>
      <description>&lt;p&gt;My name is Inigo Montoya. I have the following qualities:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;I rock a great mustache&lt;/li&gt;&#xA;&lt;li&gt;I&amp;rsquo;m extremely loyal to my family&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;What else do you need?&lt;/p&gt;&#xA;&lt;h3 id=&#34;my-history&#34;&gt;my history&lt;/h3&gt;&#xA;&lt;p&gt;To be honest, I&amp;rsquo;m having some trouble remembering right now, so why don&amp;rsquo;t you just watch &lt;a href=&#34;https://en.wikipedia.org/wiki/The_Princess_Bride_%28film%29&#34;&gt;my movie&lt;/a&gt; and it will answer &lt;strong&gt;all&lt;/strong&gt; your questions.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
