<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Beautiful Hugo</title>
    <link>https://ahang7.github.io/post/</link>
    <description>Recent content in Posts on Beautiful Hugo</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>ch1447571882@qq.com (ch)</managingEditor>
    <webMaster>ch1447571882@qq.com (ch)</webMaster>
    <lastBuildDate>Thu, 31 Oct 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ahang7.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[makefile] makefile学习笔记</title>
      <link>https://ahang7.github.io/post/basic/middlewares/makefile/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/middlewares/makefile/</guid>
      <description>&lt;p&gt;learn form &lt;a href=&#34;https://blog.csdn.net/haoel/article/details/2886&#34;&gt;(陈皓) 跟我一起写 Makefile（一）_haoel的博客-CSDN博客_makefile标签&lt;/a&gt; &amp;amp;&amp;amp; &lt;a href=&#34;https://zhuanlan.zhihu.com/p/47390641&#34;&gt;Makefile由浅入深&amp;ndash;教程、干货 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;code&gt;makefile&lt;/code&gt; 关系到了整个工程的编译规则，&lt;code&gt;makefile&lt;/code&gt; 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件后需要编译，哪些文件需要重新编译，甚者进行更复杂的功能操作，&lt;code&gt;makefile&lt;/code&gt; 像 &lt;code&gt;shell&lt;/code&gt;脚本一样，其中也可以执行操作系统的命令。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;makefile&lt;/code&gt;带来的好处是-“自动化编译”，一旦写好，一个&lt;code&gt;make&lt;/code&gt;命令，整个工程完全自动编译，极大提高了软件开发的效率。&lt;code&gt;make&lt;/code&gt;是一个命令工具，是一个解释&lt;code&gt;makefile&lt;/code&gt;中指令的命令工具。&lt;/p&gt;&#xA;&lt;h2 id=&#34;makefile结构说明&#34;&gt;Makefile结构说明&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;code&gt;makefile&lt;/code&gt; 主要包含了五个东西：变量定义，显示规则，隐晦规则，文件标示和注释。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;变量定义。在&lt;code&gt;makefile&lt;/code&gt;中我们需要定义一系列的变量，一般是字符串，当&lt;code&gt;makefile&lt;/code&gt;被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;显示规则。说明了如何生成一个或者多个目标文件，由&lt;code&gt;makefile&lt;/code&gt;的书写者明显指出，要生成的文件，文件的依赖文件，生成的文件。【可类似&lt;code&gt;shell&lt;/code&gt;脚本】&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;隐晦规则。由于make有自动推导功能，使用隐晦的规则可以让我们比较粗糙地简略书写&lt;code&gt;makefile&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;文件指示。其中包括了三个部分。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;注释。&lt;code&gt;Makefile&lt;/code&gt;中只有行注释，使用 &lt;code&gt;#&lt;/code&gt; 字符&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;makefile中的预定义变量&#34;&gt;Makefile中的预定义变量&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;$* 　　不包含扩展名的目标文件名称。&lt;/p&gt;&#xA;&lt;p&gt;$+ 　　所有的依赖文件，以空格分开，并以出现的先后为序，可能包含重复的依赖文件。&lt;/p&gt;&#xA;&lt;p&gt;$&amp;lt; 　　第一个依赖文件的名称。&lt;/p&gt;&#xA;&lt;p&gt;$? 　　所有的依赖文件，以空格分开，这些依赖文件的修改日期比目标的创建日期晚。&lt;/p&gt;&#xA;&lt;p&gt;$@ 　 目标的完整名称。&lt;/p&gt;&#xA;&lt;p&gt;$^ 　　所有的依赖文件，以空格分开，不包含重复的依赖文件。&lt;/p&gt;&#xA;&lt;p&gt;$% 如果目标是归档成员，则该变量表示目标的归档成员名称。&lt;/p&gt;&#xA;&lt;h2 id=&#34;go-makefile&#34;&gt;Go Makefile&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;使用&lt;code&gt;makefile&lt;/code&gt;快速编译Go web程序，期望：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;高级、简单的命令。比如：&lt;code&gt;compile&lt;/code&gt; &lt;code&gt;start&lt;/code&gt; &lt;code&gt;stop&lt;/code&gt; &lt;code&gt;watch&lt;/code&gt; 等等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;管理具体项目环境的变量，它应该包含 &lt;code&gt;.env&lt;/code&gt; 文件&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;开发模式，修改时自动编译&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;开发模式，修改时自动重启服务&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;开发模式，简洁地显示编译的错误信息&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;具体项目的GOPATH，可以在&lt;code&gt;vendor&lt;/code&gt;目录维护依赖包&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;简化文件查看，&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;1环境变量&#34;&gt;1、环境变量&lt;/h4&gt;&#xA;&lt;p&gt;在&lt;code&gt;makefile&lt;/code&gt;中 &lt;code&gt;include&lt;/code&gt;为项目定义环境变量，第一行如下&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Plaintext&#34; data-lang=&#34;Plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;include .env&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;^^^&lt;/p&gt;&#xA;&lt;p&gt;…………&lt;/p&gt;&#xA;&lt;h4 id=&#34;final最终版本&#34;&gt;final.最终版本&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Plaintext&#34; data-lang=&#34;Plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;include .env&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PROJECTNAME=$(shell basename &amp;#34;$(PWD)&amp;#34;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Go related variables.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GOBASE=$(shell pwd)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GOPATH=&amp;#34;$(GOBASE)/vendor:$(GOBASE)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GOBIN=$(GOBASE)/bin&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;GOFILES=$(wildcard *.go)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Redirect error output to a file, so we can show it in development mode.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;STDERR=/tmp/.$(PROJECTNAME)-stderr.txt&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# PID file will keep the process id of the server&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;PID=/tmp/.$(PROJECTNAME).pid&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# Make is verbose in Linux. Make it silent.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;MAKEFLAGS += --silent&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## install: Install missing dependencies. Runs `go get` internally. e.g; make install get=github.com/foo/bar&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;install: go-get&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## start: Start in development mode. Auto-starts when code changes.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;start:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    bash -c &amp;#34;trap &amp;#39;make stop&amp;#39; EXIT; $(MAKE) compile start-server watch run=&amp;#39;make compile start-server&amp;#39;&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## stop: Stop development mode.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;stop: stop-server&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;start-server: stop-server&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  $(PROJECTNAME) is available at $(ADDR)&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-$(GOBIN)/$(PROJECTNAME) 2&amp;gt;&amp;amp;1 &amp;amp; echo $$! &amp;gt; $(PID)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @cat $(PID) | sed &amp;#34;/^/s/^/  \&amp;gt;  PID: /&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;stop-server:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-touch $(PID)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-kill `cat $(PID)` 2&amp;gt; /dev/null || true&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-rm $(PID)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## watch: Run given command when code changes. e.g; make watch run=&amp;#34;echo &amp;#39;hey&amp;#39;&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;watch:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) yolo -i . -e vendor -e bin -c &amp;#34;$(run)&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;restart-server: stop-server start-server&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## compile: Compile the binary.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;compile:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-touch $(STDERR)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-rm $(STDERR)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @-$(MAKE) -s go-compile 2&amp;gt; $(STDERR)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @cat $(STDERR) | sed -e &amp;#39;1s/.*/\nError:\n/&amp;#39;  | sed &amp;#39;s/make\[.*/ /&amp;#39; | sed &amp;#34;/^/s/^/     /&amp;#34; 1&amp;gt;&amp;amp;2&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## exec: Run given command, wrapped with custom GOPATH. e.g; make exec run=&amp;#34;go test ./...&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;exec:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) $(run)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;## clean: Clean build files. Runs `go clean` internally.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;clean:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @(MAKEFILE) go-clean&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-compile: go-clean go-get go-build&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-build:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  Building binary...&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go build -o $(GOBIN)/$(PROJECTNAME) $(GOFILES)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-generate:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  Generating dependency files...&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go generate $(generate)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-get:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  Checking if there is any missing dependencies...&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go get $(get)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-install:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go install $(GOFILES)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;go-clean:&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34;  &amp;gt;  Cleaning build cache&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @GOPATH=$(GOPATH) GOBIN=$(GOBIN) go clean&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.PHONY: help&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;all: help&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;help: Makefile&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo &amp;#34; Choose a command run in &amp;#34;$(PROJECTNAME)&amp;#34;:&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @sed -n &amp;#39;s/^##//p&amp;#39; $&amp;lt; | column -t -s &amp;#39;:&amp;#39; |  sed -e &amp;#39;s/^/ /&amp;#39;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @echo&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL逻辑架构</title>
      <link>https://ahang7.github.io/post/basic/mysql/6.-mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/6.-mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;h2 id=&#34;61-sql执行过程&#34;&gt;6.1 SQL执行过程&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84&#34;&gt;https://xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;MySQL架构分为两层：&lt;strong&gt;server层和存储引擎层&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Server层负责建立连接、分析和执行SQL&#xA;&lt;ul&gt;&#xA;&lt;li&gt;MySQL大多数核心功能模块都在这里：连接器、查询缓存、解析器、预处理器、优化器、执行器等&lt;/li&gt;&#xA;&lt;li&gt;还有所有的内置函数&lt;/li&gt;&#xA;&lt;li&gt;所有跨存储引擎的功能&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;存储引擎层负责数据的存储和提取&#xA;&lt;ul&gt;&#xA;&lt;li&gt;支持InnoDB、MyISAM、Memory等多个存储引擎&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;611-连接器&#34;&gt;6.1.1 连接器&lt;/h3&gt;&#xA;&lt;p&gt;MySQL是基于TCP协议进行传输的，所以在连接MySQL的时候需要先进行TCP三次握手，在命令行使用命令进行连接&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mysql -h &lt;span class=&#34;nv&#34;&gt;$ip&lt;/span&gt; -u&lt;span class=&#34;nv&#34;&gt;$user&lt;/span&gt; -p&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户通过用户密码成功连接后，连接器会获取用户的权限，然后保存起来，在后续的此连接的任何操作，都会基于连接开始的时候读取到的权限逻辑进行判断&lt;/p&gt;&#xA;&lt;p&gt;建立连接后，即使修改了该用户的权限，也不影响已连接的权限。只有新建的连接才会有新的权限设置&lt;/p&gt;&#xA;&lt;h4 id=&#34;6111-查看mysql服务的客户端连接&#34;&gt;6.1.1.1 查看MySQL服务的客户端连接&lt;/h4&gt;&#xA;&lt;p&gt;可以执行&lt;code&gt;show processlist&lt;/code&gt; 命令进行查看&lt;/p&gt;&#xA;&lt;h4 id=&#34;6112-空闲连接会一直占着&#34;&gt;6.1.1.2 空闲连接会一直占着&lt;/h4&gt;&#xA;&lt;p&gt;不会，MySQL定义了空闲连接的最大空闲时长，由&lt;code&gt;wait_timeout&lt;/code&gt; 参数控制，默认值是8小时，超过这个时间，连接器就会把这个连接断开&lt;/p&gt;&#xA;&lt;p&gt;使用命令可以查看该值&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;show variables like &lt;span class=&#34;s1&#34;&gt;&amp;#39;wait_timeout&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以手动断开空闲的连接，使用的是&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;kill&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;connection&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当空闲的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求时，才会收到报错&lt;/p&gt;&#xA;&lt;p&gt;“ERROR 2013 (HY000): Lost connection to MySQL server during query”&lt;/p&gt;&#xA;&lt;h4 id=&#34;6113-mysql的连接限制&#34;&gt;6.1.1.3 MySQL的连接限制&lt;/h4&gt;&#xA;&lt;p&gt;MySQL服务支持的最大连接数由&lt;code&gt;max_connections&lt;/code&gt; 参数控制&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;show variables like &lt;span class=&#34;s1&#34;&gt;&amp;#39;max_connections&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;MySQL的连接跟HTTP一样，有短连接和长连接的概念&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-SQL&#34; data-lang=&#34;SQL&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;短连接&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;连接&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;服务（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;三次握手）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;执行&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;断开&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;服务（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;四次挥手）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;长连接&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;连接&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;服务（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;三次握手）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;执行&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;执行&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;执行&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;断开&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;服务（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;四次挥手）&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般推荐长连接，但是使用长连接可能会占用内存增多，因为_MySQL在执行查询过程中临时使用内存管理连接对象__，_只有在连接断开的时候才会释放&lt;/p&gt;</description>
    </item>
    <item>
      <title>[wrk] http压测工具</title>
      <link>https://ahang7.github.io/post/basic/middlewares/http%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7wrk/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/middlewares/http%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7wrk/</guid>
      <description>&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Go&#34; data-lang=&#34;Go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;使用方法&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wrk&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;选项&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;被测HTTP服务的URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;                           &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;Options&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;                                           &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;connections&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;跟服务器建立并保持的TCP连接数量&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;duration&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;压测时间&lt;/span&gt;          &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;threads&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;使用多少个线程进行压测&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;压测时&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;是有一个主线程来控制我们设置的n个子线程间调度&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                                    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;script&lt;/span&gt;      &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;指定Lua脚本路径&lt;/span&gt;      &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;header&lt;/span&gt;      &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;为每一个HTTP请求添加HTTP头&lt;/span&gt;     &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;latency&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;在压测结束后&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;打印延迟统计信息&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;超时时间&lt;/span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;version&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;打印正在使用的wrk的详细版本信&lt;/span&gt;                                              &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;代表数字参数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;支持国际单位&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;G&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;代表时间参数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;支持时间单位&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>[计网] HTTP</title>
      <link>https://ahang7.github.io/post/basic/network/3.-http/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/network/3.-http/</guid>
      <description>&lt;p&gt;接下来将从以下6个方面，逐渐学习和了解HTTP&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;HTTP基本概念&lt;/li&gt;&#xA;&lt;li&gt;Get与Post&lt;/li&gt;&#xA;&lt;li&gt;HTTP特征&lt;/li&gt;&#xA;&lt;li&gt;HTTP缓存&lt;/li&gt;&#xA;&lt;li&gt;HTTPS与HTTP&lt;/li&gt;&#xA;&lt;li&gt;HTTP/1.1、HTTP/2、HTTP/3演变&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YzgxNTk2MGIwMjM0ODdhZWNiYjM1YTdhNTM0NTMwOTJfaDdMekY5THZXQ0plelVaR2lCV1ZWWGptTUZISUMzcElfVG9rZW46TU5pOWJ0elBEbzVIa0p4bzdvTGM1N1VybkxoXzE3MjE4Mzk5Nzc6MTcyMTg0MzU3N19WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;http基本概念&#34;&gt;&lt;strong&gt;HTTP基本概念&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1http是什么&#34;&gt;&lt;strong&gt;1.HTTP是什么？&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;HTTP是超文本传输协议，也就是&lt;strong&gt;HyperText&lt;/strong&gt; &lt;strong&gt;Transfer Protocol&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;HTTP的名字【超文本传输协议】，可以拆成三个部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;超文本&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;传输&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;协议&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MWVjMWE4ZmI3M2M3YjczMWRmMDE3OWVmZjUwYTE0ODBfRXhVcm5qbEUxNlZaVGpid3I5Z25sQTJzV1ZlSVpGUTdfVG9rZW46UHhGZGJVNFI2b25hWDl4TmlsS2NoaVI2bjJpXzE3MjE4Mzk5Nzc6MTcyMTg0MzU3N19WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;针对 HTTP &lt;strong&gt;协议&lt;/strong&gt;，我们可以这么理解。&lt;/p&gt;&#xA;&lt;ol start=&#34;7&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;「协议」&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;HTTP 是一个用在计算机世界里的&lt;strong&gt;协议&lt;/strong&gt;。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（&lt;strong&gt;两个以上的参与者&lt;/strong&gt;），以及相关的各种控制和错误处理方式（&lt;strong&gt;行为约定和规范&lt;/strong&gt;）。&lt;/p&gt;&#xA;&lt;ol start=&#34;8&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;「传输」&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;HTTP 协议是一个&lt;strong&gt;双向协议&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;针对&lt;strong&gt;传输&lt;/strong&gt;，我们可以进一步理解了 HTTP。&lt;/p&gt;&#xA;&lt;p&gt;HTTP 是一个在计算机世界里专门用来在&lt;strong&gt;两点之间传输数据&lt;/strong&gt;的约定和规范。&lt;/p&gt;&#xA;&lt;ol start=&#34;9&#34;&gt;&#xA;&lt;li&gt;&lt;em&gt;「超文本」&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;HTTP 传输的内容是「超文本」。&lt;/p&gt;&#xA;&lt;p&gt;理解「超文本」，它就是&lt;strong&gt;超越了普通文本的文本&lt;/strong&gt;，它是文字、图片、视频等的混合体，最关键有超链接，能从一个超文本跳转到另外一个超文本。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;HTTP是用于从互联网服务器传输超文本到本地浏览器的协议，这个说法是错误的，因为HTTP也可以服务于【服务器&amp;lt;&amp;mdash;&amp;gt;服务器】，所有采用&lt;strong&gt;两点之间&lt;/strong&gt;的描述比较准确&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;2http常见的状态码&#34;&gt;&lt;strong&gt;2.HTTP常见的状态码&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NzMzNjU4MzA0ZWM3ZGY0ZWRjM2MzOWQyMzA1NmIyMjJfN01YaTBhejQ1RVlOMFdWcWphQXNXaHNLYUhGekNOWFdfVG9rZW46WFRQcGJWUWdBb1VYdVp4YmM2ZWNWdmd0bnJjXzE3MjE4Mzk5Nzc6MTcyMTg0MzU3N19WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;1xx&lt;/code&gt; 类状态码属于&lt;strong&gt;提示信息&lt;/strong&gt;，是协议处理中的一种中间状态，实际用到的比较少。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;2xx&lt;/code&gt; 类状态码表示服务器&lt;strong&gt;成功&lt;/strong&gt;处理了客户端的请求，也是我们最愿意看到的状态。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;「&lt;strong&gt;200 OK&lt;/strong&gt;」是最常见的成功状态码，表示一切正常。如果是非 &lt;code&gt;HEAD&lt;/code&gt; 请求，服务器返回的响应头都会有 body 数据。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;「&lt;strong&gt;204 No Content&lt;/strong&gt;」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;「&lt;strong&gt;206 Partial Content&lt;/strong&gt;」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;3xx&lt;/code&gt; 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是&lt;strong&gt;重定向&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;「&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[计网] TCP/IP网络模型</title>
      <link>https://ahang7.github.io/post/basic/network/1.-tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/network/1.-tcpip%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/network/1_base/tcp_ip_model.html&#34;&gt;2.1 TCP/IP 网络模型有哪几层？&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;21-tcpip网络模型&#34;&gt;2.1 TCP/IP网络模型&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;前言：为什么要有TCP/IP网络模型？&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;答：为了提供一套 &lt;strong&gt;通用的****网络协议&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;因为在一台设备上的进程间通信有很多方式，比如管道、消息队列、共享内存、信号等方式，而对于不同的设备上的进程间通信，就需要网络通信，而设备是多样性的，需要兼容多种多样的设备，就需要一套 &lt;code&gt;通用的网络协议&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;这个网络协议是分层的，每一层都有各自的作用和责任&lt;/p&gt;&#xA;&lt;p&gt;TCP/IP网络模型分为4层：应用层&amp;ndash;&amp;gt;传输层&amp;ndash;&amp;gt;网络层&amp;ndash;&amp;gt;网络接口层(由上到下)&lt;/p&gt;&#xA;&lt;p&gt;接下来根据 [TCP/IP 网络模型 ]分别对每一层进行介绍：&lt;/p&gt;&#xA;&lt;h3 id=&#34;应用层最上层&#34;&gt;&lt;strong&gt;应用层（最上层）&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;最上层的，也是我们能直接接触到的就是&lt;strong&gt;应用层&lt;/strong&gt;(Application Layer)，我们使用的应用软件都是在应用层实现的，当两台不同的设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是&lt;strong&gt;传输层&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;接收数据后把数据传入&lt;strong&gt;传输层&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;所以，&lt;strong&gt;应用层&lt;/strong&gt;只需要专注于为用户提供应用功能，比如HTTP、FTP、Telnet、DNS、SMTP等&lt;/p&gt;&#xA;&lt;p&gt;应用层不用关心数据是如何传输&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;是工作在操作系统的用户态，&lt;strong&gt;传输层****及其一下&lt;/strong&gt;则工作在内核态&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;传输层&#34;&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;应用层&lt;/strong&gt;的数据包会传输到传输层，&lt;strong&gt;传输层&lt;/strong&gt;(Transport Layer) 是为应用层提供网络支持&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTM5NGVmNjMyYmZhOTE2Y2JiZTlhZjRkMzJhMGU4NTVfM3F5dVFqUnppQzA2cXFoQ2F6c1RwdVlpa3QzR0U2N3lfVG9rZW46RTgwT2JPenk5b1VQaW14Y1pFY2NkYTBmbmtoXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在&lt;strong&gt;传输层&lt;/strong&gt;会有两个传输协议，分别为&lt;code&gt;TCP&lt;/code&gt;和&lt;code&gt;UDP&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;的全称是“传输控制协议”(Transmission Control Protocol)，大部分应用使用的正是TCP传输层协议，比如HTTP应用层协议。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;有很多特征：流量控制、超时重传、拥塞控制等，这些保证了数据包能可靠地传输给对方&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;相对来说比较协议，简单到&lt;strong&gt;只负责发送数据包&lt;/strong&gt;，不保证数据包是否能抵达对方，但是实时性相对更好，传输效率也高。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;也可以实现可靠传输，把&lt;strong&gt;TCP&lt;/strong&gt;的特性在应用层上实现就行，（不过要实现一个商用的可靠UDP传输协议也不简单）&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过&lt;strong&gt;MSS&lt;/strong&gt;（TCP最大报文段长度），就要将数据包分块，这样即使在传输过程中一个分块缺失或者损坏了，只需要重新发送这一分开，而不用重新发送整个数据包。&lt;/p&gt;&#xA;&lt;p&gt;在TCP协议中，每一个分块称为一个&lt;strong&gt;TCP段&lt;/strong&gt;(TCP Segment)&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTE4YjBkOWU1ZTVlYmViZDkxNDQ1NTFmYWZkMTQzMTFfNllQajladEFQVERJUDFNWUZHNWxZRGVaWFZoanVZeE9fVG9rZW46VG5ZM2JrUzVGb1ZrN1N4UkF5b2NMdW5KbmZrXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当设备作为接收方时，传输层则要负责把数据包传给应用层，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要一个编号将应用区分开来，这个编号就是&lt;strong&gt;端口&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，操作系统会为这些进程分配临时的端口号。&lt;/p&gt;&#xA;&lt;p&gt;由于传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;传输层&lt;/strong&gt;并不负责将数据从一个设备传输到另一个设备&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;网络层&#34;&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;在实际场景中，一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，其中的网络环节是错综复杂的。而&lt;strong&gt;传输层&lt;/strong&gt;的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则&lt;/p&gt;&#xA;&lt;p&gt;我们不希望传输层协议处理太多的事情，只需要服务好应用即可，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而实际的传输功能就交给下一层，也就是&lt;strong&gt;网络层&lt;/strong&gt;(Internet Layer)&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBiZTU5ZmFlMmQyNGNiYzdkMTA1M2YxNmZmNmMwYjhfeUhWM2IyVzAxbWdwdHZud0N3eWtsbVdDbHZoMGNiR1RfVG9rZW46RmIxTWJ2TEF6b1RaZU94S29SRmNIazNRbnJFXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;个人理解：应用层把大量的数据发送给传输层，传输层将这些大量的数据进行打包，分段，确定好目的应用，然后由网络层进行传输。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;最常用的是&lt;strong&gt;IP协议&lt;/strong&gt;(Internet Protocol)，IP协议会将传输层的报文作为数据部分，再加上IP包头组装成&lt;strong&gt;IP报文&lt;/strong&gt;，如果IP报文大小超过了&lt;strong&gt;MTU&lt;/strong&gt;(以太网中一般为1500字节)就会&lt;strong&gt;再次进行分片&lt;/strong&gt;，得到一个继续发送网络的IP报文&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBhODFlM2VmZWRiYWI5MTYyOTdjY2Q3NTlmNGQ4OTNfMWhGUGlQbmszY2FmYnhmYlhUU1dHTGw3VmxEU0JXV3pfVG9rZW46WnFoWmJwM09Ub2F6VDV4ek5FMGN6dnY3bmpmXzE3MjE4Mzk4OTE6MTcyMTg0MzQ5MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;网络层&lt;/strong&gt;负责将数据从一个设备传输到另一个设备，但是世界上那么多设备，如何找到对方呢，因此，网络层需要有区分设备的编号&lt;/p&gt;&#xA;&lt;p&gt;一般用&lt;strong&gt;IP地址&lt;/strong&gt;给设备进行编号，对于IPv4协议，IP地址共32位，分成了四段（比如127.0.0.1，分成四段，每段8位）。但是寻址起来特别麻烦，不能一个一个去匹配。&lt;/p&gt;&#xA;&lt;p&gt;因此，需要将IP地址分成两种意义：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个是&lt;strong&gt;网络号&lt;/strong&gt;，负责标识该IP地址是属于那个[ 子网 ]的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个是&lt;strong&gt;主机号&lt;/strong&gt;，负责标识同一[ 子网 ]下的不同主机&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;怎么区分&lt;strong&gt;网络号&lt;/strong&gt;和&lt;strong&gt;主机号&lt;/strong&gt;呢？这需要配合&lt;strong&gt;子网掩码&lt;/strong&gt;才能算出IP地址的网络号和主机号&lt;/p&gt;&#xA;&lt;p&gt;举个例子，比如 10.100.122.0/24，后面的&lt;code&gt;/24&lt;/code&gt;表示就是 &lt;code&gt;255.255.255.0&lt;/code&gt; 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[计网] 键入网址的过程</title>
      <link>https://ahang7.github.io/post/basic/network/2.-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/network/2.-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E7%9A%84%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;p&gt;面试题：【当键入网址后，到网页显示，期间发生了什么？&lt;/p&gt;&#xA;&lt;p&gt;下面一张较简单的网络拓扑模型作为例子，探究探究其间发生了什么？&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YWYxZjYxMTdhY2RlODA5Yzc5ZDJmNzdlNzM3ZWNkZThfYXpBSE8zNllUVmREclRrV0l5RmEyaXE4V0lodEh3enpfVG9rZW46TGxKMmJSWDlXb1dTUWN4RUJNd2NaZ0IyblhlXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;http&#34;&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;浏览器做的第一步工作是&lt;strong&gt;解析****URL&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;首先浏览器做的第一步工作就是要对&lt;code&gt;URL&lt;/code&gt;进行解析，从而生成发生给&lt;code&gt;Web&lt;/code&gt;服务器的请求信息&lt;/p&gt;&#xA;&lt;p&gt;在一条长长的URL里的各个元素的代表是什么&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ4MGEyMTY1MWRiNGE0MjliMjBhNTRhNmM3OTkwOWZfS0tDMENDOUNRb05hZkxXZ0JJNkZIZWRFTklGZDI5R1VfVG9rZW46RnF1TWJpVklTb0pUSUR4Njg3N2NMVGRvbkZlXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这里的URL实际上是请求服务器里的文件资源&lt;/p&gt;&#xA;&lt;p&gt;当上图的蓝色部分URL元素都省略了，那么请求的是哪个文件呢？&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;当没有路径名时，就代表访问根目录下事先设置的&lt;strong&gt;默认文件&lt;/strong&gt;，也就是&lt;code&gt;/index.html&lt;/code&gt;或者&lt;code&gt;/default.html&lt;/code&gt;这些文件，这样就不好发生混乱&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;生产HTTP请求信息&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;对&lt;code&gt;URL&lt;/code&gt;进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生产HTTP请求信息&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQ5OTZhMDE0M2U1NDg3YjkxOGM0YTBlMmZmZGNhODNfSU5nQW93c3pXYUppT1FKaGJ4WWd1VEZrU0hIUVVDd2JfVG9rZW46R1U3bWJ4aTZ6b0l5b1Z4VzdUUmN1a1FlblFQXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;真实地址查询dns&#34;&gt;&lt;strong&gt;真实地址查询——DNS&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;通过浏览器解析URL并生成HTTP消息后，需要委托操作系统将消息发送给&lt;code&gt;Web&lt;/code&gt;服务器&lt;/p&gt;&#xA;&lt;p&gt;但是在发送之前，还需要&lt;strong&gt;查询服务器域名对应的IP地址&lt;/strong&gt;，因为委托操作系统发送消息时，必须提供通信对象的IP地址&lt;/p&gt;&#xA;&lt;p&gt;这里，有一种服务器就专门保存了&lt;code&gt;Web&lt;/code&gt;服务器域名与&lt;code&gt;IP&lt;/code&gt;的对应关系——DNS服务器&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;域名的层级关系&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;DNS中的域名都是用&lt;strong&gt;句点&lt;/strong&gt;来分隔的，比如&lt;code&gt;www.server.com&lt;/code&gt;，这里的句点带不了不同层次之间的界限&lt;/p&gt;&#xA;&lt;p&gt;在域名中，&lt;strong&gt;越靠右&lt;/strong&gt;的位置表示其&lt;strong&gt;层级越高&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;实际上&lt;strong&gt;域名&lt;/strong&gt;最后还有一个点，比如&lt;code&gt;www``.server.com.&lt;/code&gt;，这个最后一个点代表根域名&lt;/p&gt;&#xA;&lt;p&gt;也就是说，&lt;code&gt;.&lt;/code&gt;根域是最顶层，它的下一层是&lt;code&gt;.com&lt;/code&gt;顶级域,再下面是&lt;code&gt;server.com&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以，域名的层级关系类似一个树状结构&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;根DNS服务器&lt;code&gt;.&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;顶级域DNS服务器&lt;code&gt;.com&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;权威DNS服务器&lt;code&gt;server.com&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YzA0NDVhMjA2MDAxMDFkNTUxNTg4Yzg2MDhlYjk0ZTRfcVJsVzU0WHl0cXZFT1h5WHpDMEpjYnlRWnkxSEhWUkNfVG9rZW46RUhFTWIwWFBFb04yZ3V4RHVNSGM1V0dBbnc0XzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;根域的DNS服务器信息保存在互联网中所有的DNS服务器中，这样一来任何DNS服务器都可以找到并访问根域DNS服务器&lt;/p&gt;&#xA;&lt;p&gt;因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。&lt;/p&gt;&#xA;&lt;p&gt;域名解析的工作流程&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;首先会发出一个DNS请求，问&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;的IP是啥，并发给本地DNS服务器（也就是客户端的TCP/IP设置中填写的DNS服务器地址）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地域名服务器收到客户端的请求后，如果&lt;strong&gt;缓存里的表格&lt;/strong&gt;能找到&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;，则直接返回IP地址，如果没有，本地DNS会去问它的根域名服务器， 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;根DNS收到本地DNS的请求后，根据&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;的后置是&lt;code&gt;.com&lt;/code&gt;，这个域名归于&lt;code&gt;.com&lt;/code&gt;区域管理，返回&lt;code&gt;.com&lt;/code&gt;顶级域名服务器地址给本地&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地DNS收到顶级域名服务器地址后，向顶级域名服务器请求负责&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;的权威DNS服务器的地址，&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地DNS最后向权威DNS服务器请求&lt;a href=&#34;http://www.server.com&#34;&gt;www.server.com&lt;/a&gt;的IP地址，该server.com的权威服务器就是域名解析结果的出处。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;权威DNS服务器查询结后将对应的IP地址X.X.X.X返回到本地DNS&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;本地DNS再将IP地址返回客户端，客户端和目标建立连接&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;至此，DNS的解析过程完成了，其过程可见下图&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjI2MmYzMWEzODdiOWY0YjcxMjZjMmEzZmUzNzEwZDFfTENsN3NZRWxDc1pVVlpKaTB3RzJwWEpGOEdhU1NBYU5fVG9rZW46SE9EVmJ5NzFlb3VHdlV4cHBPV2NiRVZ5bjZnXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;域名解析并不是每次都需要经过这么多步骤&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;还有&lt;strong&gt;缓存&lt;/strong&gt;的存在。&lt;/p&gt;&#xA;&lt;p&gt;浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。&lt;/p&gt;&#xA;&lt;h2 id=&#34;协议栈&#34;&gt;&lt;strong&gt;协议栈&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;通过DNS获取IP后，就可以把HTTP的传输工具交给操作系统中的&lt;strong&gt;协议栈&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=OTJiYWJjOTQwZjU3YTI3ODUyMWExMzU2MTlhNjkxZTNfaU5halB3SXMwdzRTdTdXVUVWQnBPYjhTWnpIN1ZEbWhfVG9rZW46WDJTQWIyU3R6b1RvQzN4aGc2OWNWczZJblNiXzE3MjE4Mzk5MzY6MTcyMTg0MzUzNl9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。&lt;/p&gt;&#xA;&lt;p&gt;协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL内存</title>
      <link>https://ahang7.github.io/post/basic/mysql/5.-mysql%E5%86%85%E5%AD%98/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/5.-mysql%E5%86%85%E5%AD%98/</guid>
      <description>&lt;h2 id=&#34;为什么要有buffer-pool&#34;&gt;为什么要有Buffer Pool&lt;/h2&gt;&#xA;&lt;p&gt;MySQL的数据存储在磁盘的，如果每次都从磁盘里面读取数据，这样性能是很差的&lt;/p&gt;&#xA;&lt;p&gt;提高性能，就需要加入缓存。当数据从磁盘中取出来之后，缓存内存中，下次查询同样的数据，直接从内存中读取&lt;/p&gt;&#xA;&lt;p&gt;为此InnoDB存储引擎设计了&lt;strong&gt;一个缓存池（Buffer Pool），来提高数据库的读写性能&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;有了缓冲池后：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读取数据时，如果数据存在于Buffer Pool中，客户端就会直接读取Buffer Pool中的数据，否则再去磁盘中读取&lt;/li&gt;&#xA;&lt;li&gt;当修改数据时，首先修改Buffer Pool中数据所在的数据页，然后将该页设置为脏页，最后由后台线程将脏页写入到磁盘&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;buffer-pool有多大&#34;&gt;Buffer Pool有多大？&lt;/h2&gt;&#xA;&lt;p&gt;Buffer Pool在MySQL启动的时候，向操作系统申请的一片连续的内存空间，默认配置下Buffer Pool只有&lt;code&gt;128MB&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以通过调整&lt;code&gt;innodb_buffer_pool_size&lt;/code&gt; 参数来设置Buffer Pool的大小，一般建议设置为可用物理内存的60%~80%&lt;/p&gt;&#xA;&lt;h2 id=&#34;buffer-pool缓存什么&#34;&gt;Buffer Pool缓存什么？&lt;/h2&gt;&#xA;&lt;p&gt;InnoDB会把存储的数据分为若干个&lt;strong&gt;页&lt;/strong&gt;，以页作为磁盘和内存交互的基本单位，一个页的默认大小为**16kb，**因此Buffer Pool同样需要按页来划分&lt;/p&gt;&#xA;&lt;p&gt;在MySQL启动的时候，**InnoDB会为Buffer Pool申请一片连续的&lt;strong&gt;&lt;strong&gt;内存&lt;/strong&gt;&lt;/strong&gt;空间，然后按照默认的16&lt;strong&gt;&lt;strong&gt;kb&lt;/strong&gt;&lt;/strong&gt;的大小划分出一个个的页，Buffer Pool中的页就叫做缓存页。**这些缓存页都是空的，之后随着程序的运行，才会有磁盘上的页被缓存到Buffer Pool中&lt;/p&gt;&#xA;&lt;p&gt;所以，MySQL刚启动的时候，其使用的虚拟内存空间很大，而使用到的物理内存空间很小，这时因为这些虚拟内存被访问后，操作系统才会触发缺页中断，接着将虚拟地址和物理地址建立映射关系&lt;/p&gt;&#xA;&lt;p&gt;Buffer Pool缓存了以下的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;索引页&lt;/li&gt;&#xA;&lt;li&gt;数据页&lt;/li&gt;&#xA;&lt;li&gt;插入缓存页&lt;/li&gt;&#xA;&lt;li&gt;Undo页&lt;/li&gt;&#xA;&lt;li&gt;自适应哈希索引&lt;/li&gt;&#xA;&lt;li&gt;锁信息&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;为了更好管理Buffer Pool中的缓存页，InnoDB为每一个缓存页都创建了一个**控制块，**控制块包括缓存页的表空间，页号，缓存页地址，链表节点等，控制块也占据内存空间，它是在Buffer Pool的最前面，接着才是缓存页&lt;/p&gt;&#xA;&lt;p&gt;暂时无法在飞书文档外展示此内容&lt;/p&gt;&#xA;&lt;p&gt;上面的控制块和缓存页之间的空白空间称为&lt;strong&gt;碎片空间&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;碎片空间：每一个控制块对应一个缓存页，在分配足够多的控制块和缓存页后，可能剩余的空间不足够一个控制块和缓存页的大小，那么这块空间就不被使用，剩下的这块空间就被称为碎片&lt;/p&gt;&#xA;&lt;p&gt;当Buffer Pool的大小设置的刚刚好，就不会产生碎片&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;查询一条记录时，InnoDB会把整个页的数据加载到Buffer Pool中，通过索引只能定位到磁盘中的页，而不能定位到页中一条记录。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s/A5gNVXMNE-iIlY3oofXtLw&#34;&gt;mp.weixin.qq.com&lt;/a&gt;(从数据页的角度看B+树——InnoDB存储引擎)&lt;/p&gt;&#xA;&lt;p&gt;记录是按照行来存储的，但是数据库的读取并不是以&lt;strong&gt;行&lt;/strong&gt;为单位，否则一次读取（一次IO操作）只能处理一行数据，效率会非常低，因此，&lt;strong&gt;InnoDB的数据是按照数据页为单位来读写的&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;数据页的结构分为7个部分&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;          &lt;th&gt;&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;File Header(38)&lt;/td&gt;&#xA;          &lt;td&gt;文件头，表示页的信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Page Header(56)&lt;/td&gt;&#xA;          &lt;td&gt;页头，表示页的状态信息&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;infimum+supermun(26)&lt;/td&gt;&#xA;          &lt;td&gt;两个虚拟伪记录，分别表示页中最小记录和最大记录&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;User Records(unclear)&lt;/td&gt;&#xA;          &lt;td&gt;存储行记录内容&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Free Space(unclear)&lt;/td&gt;&#xA;          &lt;td&gt;页中还没被使用的&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Page Directory(unclear)&lt;/td&gt;&#xA;          &lt;td&gt;页目录，存储用户记录的相对位置，对记录起索引作用&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;File Tailer(8)&lt;/td&gt;&#xA;          &lt;td&gt;校验页是否完整&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;其中，行记录由&lt;code&gt;infimum+supremum&lt;/code&gt; 和 &lt;code&gt;User Records&lt;/code&gt;构成&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] 集群</title>
      <link>https://ahang7.github.io/post/basic/redis/6-redis%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Wed, 30 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/6-redis%E9%9B%86%E7%BE%A4/</guid>
      <description></description>
    </item>
    <item>
      <title>[MySQL] MySQL日志</title>
      <link>https://ahang7.github.io/post/basic/mysql/4.-mysql%E6%97%A5%E5%BF%97/</link>
      <pubDate>Tue, 29 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/4.-mysql%E6%97%A5%E5%BF%97/</guid>
      <description>&lt;p&gt;先理解执行一条sql语句，在mysql内部会发生什么？&lt;/p&gt;&#xA;&lt;p&gt;以执行一条&lt;code&gt;update&lt;/code&gt; 语句为例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;客户端会先通过连接器建立连接，连接器会判断用户身份&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;这里是一条update语句，所以不需要经过查询缓存（注意，当表上有更新语句，会把整个查询缓存清空，所以在Mysql8.0这个功能就被移除了）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解析器会通过词法分析识别出关键字，构建出语法树，接着做语法分析，判断输入的语句是否符合MySQL语法&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;预处理器会判断表和字段是否存在&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;优化器确定执行计划（使用索引或者全表查询）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;执行器负责具体执行，找到这一行然后更新&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不过，更新语句的流程会涉及到&lt;strong&gt;undo&lt;/strong&gt; &lt;strong&gt;log&lt;/strong&gt;**，redo log，binlog**三种日志：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;undo log（回滚日志）：是InnoDB存储引擎生成的日志，实现了事务中的&lt;strong&gt;原子性&lt;/strong&gt;，主要用于事务回滚和MVCC&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;redo log（重做日志）：是InnoDB存储引擎生成的日志，实现了事务中的&lt;strong&gt;持久性&lt;/strong&gt;，主要用于掉电等故障恢复&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;bing log（归档日志）：是Server层生成的日志，主要用于数据备份和主从复制&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;1为什么需要undo-log&#34;&gt;1.为什么需要undo log？&lt;/h2&gt;&#xA;&lt;p&gt;在执行一条“增删改”语句的时候，MySQL会隐式开启事务，执行完后自动提交事务&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;MySQL中执行一条语句后是否自动提交事务，是由&lt;code&gt;autocommit&lt;/code&gt; 参数来决定的，默认是开启的&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;当事务执行过程中，都记录下回滚时需要的信息到一个日志中，那么在事务执行过程中发生MySQL崩溃后，可以通过这个日志回滚到事务之前的数据&lt;/p&gt;&#xA;&lt;p&gt;实现这一机制就是 &lt;strong&gt;undo&lt;/strong&gt; &lt;strong&gt;log&lt;/strong&gt;**（回滚日志），它保证了事务的&lt;strong&gt;&lt;strong&gt;ACID&lt;/strong&gt;&lt;/strong&gt;特性中的原子性**&lt;/p&gt;&#xA;&lt;p&gt;每当InnoDB引擎对每种操作进行回滚时，进行相反操作就行：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;插入 - 删除&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;删除 - 插入&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;更新 - 更新为旧值&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;一条记录每次进行操作产生的undo log格式都有一个roll_pointer和一个trx_id事务id：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;trx_id：记录该记录是被哪些事务修改的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;roll_pointer：指针可以将这些undo log串成一个链表，这个链表被称为版本链&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=N2UyNDE0NmNmNDU2N2UyY2Q5NDJkYzZiNzAwMzY3OTRfUjh5Zmw4d3VoWFI5VGZnaFR2a0NsVWk0bVdPTEM2WW5fVG9rZW46V3FmemIzbkhQb1BkRjB4UGFLbWNwR2RpbkRLXzE3MjE4NDExMjk6MTcyMTg0NDcyOV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;另外，undo log可以跟Read View一起实现MVCC（多版本并发控制）：&lt;/p&gt;&#xA;&lt;p&gt;对于 &lt;strong&gt;读提交&lt;/strong&gt; 和 &lt;strong&gt;可重复读&lt;/strong&gt; 隔离级别的事务来说，它们的快照读（普通select语句）是通过Read View + undo log来实现的，区别在于创建Read View的时机不同&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读提交：是在每一个select都会生成一个新的Read View，也意味着事务期间的多次读取同一数据，前后两次读的数据可能会出现不一致（不可重复读）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可重复读：是在启动事务时生成一个Read View，然后整个事务期间都在用这个Read View，这样保证了事务期间读到的数据都是事务启动时的记录&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这两个隔离级别实现是通过事务的Read View里的字段和记录两个隐藏列trx_id和roll_pointer的对比&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B&#34;&gt;事务隔离级别是怎么实现的？&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;因此，undo log两大作用：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现事务回滚，保障事务的原子性&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;实现MVCC（多版本并发控制）关键因素之一&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Undo log是如何刷盘？&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] 场景</title>
      <link>https://ahang7.github.io/post/basic/redis/5-redis%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Tue, 29 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/5-redis%E5%9C%BA%E6%99%AF/</guid>
      <description>&lt;h2 id=&#34;六场景&#34;&gt;六、场景&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1缓存&#34;&gt;1.缓存&lt;/h3&gt;&#xA;&lt;p&gt;Redis由于性能高效，通常可以做数据库存储的缓存，比如给Mysql做缓存&lt;/p&gt;&#xA;&lt;p&gt;通常业务都满足二八原则，80%的流量在20%的热点数据上，所以缓存可以很大程度提高系统的吞吐量&lt;/p&gt;&#xA;&lt;h4 id=&#34;11缓存基础&#34;&gt;1.1缓存基础&lt;/h4&gt;&#xA;&lt;p&gt;一般而言，缓存分为服务器缓存，客户端缓存&lt;/p&gt;&#xA;&lt;p&gt;缓存一般有以下几种模式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;旁路缓存模式：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读穿透模式：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;写穿透模式：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;异步缓存写入模式：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h5 id=&#34;旁路缓存模式适用于读多写少&#34;&gt;旁路缓存模式（适用于读多写少）&lt;/h5&gt;&#xA;&lt;p&gt;Cache Aside，旁路缓存模式，是&lt;strong&gt;最常见的模式&lt;/strong&gt;，应用服务把缓存当作数据库的旁路，直接和缓存交互&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读操作：服务端收到查询请求，先查询数据是否在缓存上，如果在，就用缓存数据直接打包返回，如果不存在，就去数据库查询，并放到缓存&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;写操作：cache aside模式一般先更新数据库，再直接删除缓存（更新相比删除更容易造成时序性问题）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;适用于读多写少的场景，缺点是可能会出现缓存和数据库不一致的情况&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这里的写操作，更新相比删除更容易造成时序性问题，具体举例：线程1更新mysql -&amp;gt; 线程2更新mysql -&amp;gt; 线程2更新缓存 -&amp;gt; 线程1更新mysql，这样就出现了时许性问题&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;该模型的缺点：&lt;/p&gt;&#xA;&lt;p&gt;可能出现缓存和数据库不一致的情况，具体见：&lt;a href=&#34;https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98&#34;&gt;数据库和缓存如何保证一致性？&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h5 id=&#34;读穿透模式&#34;&gt;读穿透模式&lt;/h5&gt;&#xA;&lt;p&gt;与cache aside模式的区别主要在应用服务不再与缓存直接交互，而是直接去访问数据服务。&lt;/p&gt;&#xA;&lt;p&gt;这里的数据服务理解为一个**代理服务，**用它来访问缓存和数据库&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NGRhNWI5ZGY3OGFiNjlkNTc3NTQ1MTdjMGJiOTg2YmJfT09iTTdsU1pjbnNsR0dlU2ZvMEprMGlDa1hjd0l1QldfVG9rZW46TmE5MGJGTW52b3RWbHN4SmZadmM2dXZTbjJnXzE3MjE4NDE0OTU6MTcyMTg0NTA5NV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;相比于旁路缓存模式，读穿透模式的优势是缓存对业务是透明的；缺点是缓存命中的性能不如旁路缓存模式，会多一层服务调用&lt;/p&gt;&#xA;&lt;h5 id=&#34;写穿透模式&#34;&gt;写穿透模式&lt;/h5&gt;&#xA;&lt;p&gt;WriteThrough做了一层封装：有缓存服务先写入Mysql，再同步写入Redis，这样及时加载或更新了缓存数据（理解为，应用程序由一个单独的访问源，而存储服务自己维护访问逻辑）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=YWE5MTA1Y2MyNWE3OTYyY2I3Y2FmZjNiM2VmN2M3NDBfV1JIVlJVR01KN3VCakM4WVZ2REpFeXRtb21nb1ZYa0FfVG9rZW46U0F6emJXa3JFb29tSHV4OWh6cmNFdGpVbnllXzE3MjE4NDE0OTU6MTcyMTg0NTA5NV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在使用WriteThrough时，一般都配合使用ReadThrough来使用&lt;/p&gt;&#xA;&lt;p&gt;适用情况：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对缓存及时性要求更高&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;不能忍受数据丢失和数据不一致&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h5 id=&#34;异步缓存写入模式write-behind&#34;&gt;异步缓存写入模式（Write-Behind）&lt;/h5&gt;&#xA;&lt;p&gt;write-Behind和Write-Through相同点是都是写入时会更新数据库、也会更新缓存&lt;/p&gt;&#xA;&lt;p&gt;不同点是：Write-Behind是先写缓存，后&lt;strong&gt;异步&lt;/strong&gt;把数据一起写入数据库&lt;/p&gt;&#xA;&lt;p&gt;数据库写操作可以用不同的方式完成：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;收集写操作并在某个时间点慢慢写入&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;合并几个写操作成为一个批量操作，一起批量写入&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;异步写操作极大降低了请求延迟，并减轻了数据库的负担，但是代价是安全性不够，如果缓存中的数据还没写入数据库，存储服务发生了崩溃，那么数据就丢失了&lt;/p&gt;&#xA;&lt;h4 id=&#34;12缓存异常&#34;&gt;1.2缓存异常&lt;/h4&gt;&#xA;&lt;h5 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题背景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;缓存穿透是指**缓存和数据库都没有的数据，**而用户不断发起请求。&lt;/p&gt;&#xA;&lt;p&gt;在流量大的时候，DB可能就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解决方案&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;接口层增加校验，如用户鉴权校验，id做击穿校验，id&amp;lt;=0的直接拦截&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;从缓存取不到的数据，在数据库中也没有取到，这时可以将key-value对写成key-null，缓存有效时间写短点，例如30s&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;布隆过滤器：bloomfilter类似于一个hash set，用于快速判断某个元素是否存在于集合中，关键在于hash算法和容器大小&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;布隆过滤器：&lt;/p&gt;&#xA;&lt;p&gt;原理：布隆过滤器底层是一个64位的整型，将字符串用多个Hash函数映射不同的二进制位置，将整型中对应位置设置为1&lt;/p&gt;&#xA;&lt;p&gt;优点：空间、时间消耗都很小&lt;/p&gt;&#xA;&lt;p&gt;缺点：结果不完全准&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h5 id=&#34;缓存击穿&#34;&gt;缓存击穿&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题背景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;缓存击穿是指&lt;strong&gt;缓存中没有但数据库中有的数据&lt;/strong&gt;（一般缓存时间到期），这时由于并发的用户过多，同时读缓存没有数据又同时查询数据库，引起数据库压力瞬时增大&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;解决方案&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;热点数据支付续期，持续访问的数据不断续期，避免因为过期失效而被击穿&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;发现缓存失效，重建缓存加互斥锁，当线程查询缓存发现缓存不存在就会尝试加锁，线程抢锁，拿到锁的线程进行查询数据库，然后重建缓存&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h5 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h5&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;问题背景&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;指大量的应用请求因为异常无法在Redis缓存中处理，直接打到数据库。这里的异常就是：&lt;strong&gt;缓存中数据&lt;strong&gt;&lt;strong&gt;大批量&lt;/strong&gt;&lt;/strong&gt;到过期时间，而查询数据量巨大，引起数据库压力过大甚者宕机&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL锁</title>
      <link>https://ahang7.github.io/post/basic/mysql/3.-mysql%E9%94%81/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/3.-mysql%E9%94%81/</guid>
      <description>&lt;h2 id=&#34;锁的类型&#34;&gt;锁的类型&lt;/h2&gt;&#xA;&lt;p&gt;Mysql的锁，根据加锁的范围可以分为全局锁、表级锁和行锁三类&lt;/p&gt;&#xA;&lt;h3 id=&#34;全局锁&#34;&gt;全局锁&lt;/h3&gt;&#xA;&lt;p&gt;要使用全局锁，执行下面这条命令：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;flush&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;执行之后，整个数据库就处于只读状态，这时其他线程执行以下操作，就会被阻塞&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对数据的增删改，比如insert、delete、update等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对表结构的更改操作，比如alter table、drop table等&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;要释放全局锁，执行下面的命令：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;全局锁的应用场景：&lt;/p&gt;&#xA;&lt;p&gt;全局锁主要用于做&lt;strong&gt;全库逻辑备份&lt;/strong&gt;，这样在备份数据库期间，不会因为数据或者结构的更新，而出现备份文件的数据与预期的不一样&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;加全局锁带来的缺点：会导致业务停滞，因为加全局锁之后，整个数据库都只是只读状态，不能更新数据&lt;/p&gt;&#xA;&lt;p&gt;可以通过开启事务，在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的Read View，&lt;/p&gt;&#xA;&lt;p&gt;备份数据库的工具是&lt;code&gt;mysqldump&lt;/code&gt; ，在使用mysqldump时加上&lt;code&gt;-single-transaction&lt;/code&gt; 参数的时候，就会在备份数据库之前开启事务&lt;/p&gt;&#xA;&lt;h3 id=&#34;表级锁&#34;&gt;表级锁&lt;/h3&gt;&#xA;&lt;p&gt;MySQL里面表级锁有以下几种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;表锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;元数据锁（MDL）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;意向锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;AUTO-INC锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;表锁&#34;&gt;表锁&lt;/h4&gt;&#xA;&lt;p&gt;使用下面的命令对表加锁和释放锁&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 加读锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 写锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;table_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 释放锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unlock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tables&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;表锁会影响别的线程和本线程的读写操作&lt;/p&gt;&#xA;&lt;h4 id=&#34;元数据锁mdl&#34;&gt;元数据锁（MDL）&lt;/h4&gt;&#xA;&lt;p&gt;对于MDL，我们不需要显示使用，因为当我们在对数据库进行操作时，会自动给这个表上加MDL：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对一张表进行CURD操作时，加的是MDL读锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对一张表做结构变更操作的时候，加的是MDL写锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;MDL是为了保证当前用户对表执行CRUD操作时，防止其他线程对这个表结构做了变更&lt;/p&gt;&#xA;&lt;p&gt;MDL是在事务提交之后才会释放，这意味着&lt;strong&gt;事务执行期间，MDL是一直持有&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;需要注意的是，在事务启用之后，如果事务A没有提交，此时如果有表结构的修改请求发起，就会发生阻塞，这个阻塞也会导致其他CURD的请求被阻塞住&lt;/p&gt;&#xA;&lt;p&gt;这是因为申请MDL锁的操作会形成一个队列，队列中&lt;strong&gt;写锁&lt;strong&gt;&lt;strong&gt;获取优先级大于&lt;/strong&gt;&lt;/strong&gt;读锁&lt;/strong&gt;，一旦出现MDL写锁等待，会阻塞该表后续的CRUD操作&lt;/p&gt;&#xA;&lt;h4 id=&#34;意向锁&#34;&gt;意向锁&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在使用InnoDB引擎的表里对某些记录加上共享锁之前，需要先在表级别加上一个意向共享锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在使用InnoDB引擎的表里对某些记录加上独占锁之前，需要先在表级别加上一个意向独占锁&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在执行insert、update、delete操作时，需要先对表上加 意向独占锁，然后对该记录加独占锁&lt;/p&gt;&#xA;&lt;p&gt;而普通的select是不会加行级锁，普通的select语句是利用MVCC实现一致性读，是无锁的&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// select也是可以对记录加共享锁和独占锁，&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 先在表上加上意向共享锁，然后对读取的记录加共享锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;share&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 先表上加上意向锁，然后再读取记录加独占锁&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;意向锁的目的是为了快速判断表里是否有记录被加锁&lt;/p&gt;&#xA;&lt;h4 id=&#34;auto-inc锁&#34;&gt;AUTO-INC锁&lt;/h4&gt;&#xA;&lt;p&gt;表里面的主键通常设置成自增的，在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过&lt;strong&gt;AUTO-INC锁&lt;/strong&gt;实现的&lt;/p&gt;&#xA;&lt;p&gt;Auto-Inc锁是特殊的表锁机制，不是在一个事务提交后才释放，而是再执行完插入语句后就会立即释放&lt;/p&gt;&#xA;&lt;h3 id=&#34;行级锁&#34;&gt;行级锁&lt;/h3&gt;&#xA;&lt;p&gt;InnoDB引擎是支持行级锁的，而MyISAM引擎并不支持行级锁&lt;/p&gt;&#xA;&lt;p&gt;行级锁的类型主要有三类：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] 持久化</title>
      <link>https://ahang7.github.io/post/basic/redis/4-redis%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/4-redis%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;五持久化&#34;&gt;五、持久化&lt;/h2&gt;&#xA;&lt;h3 id=&#34;0持久化介绍&#34;&gt;0.持久化介绍&lt;/h3&gt;&#xA;&lt;p&gt;redis是跑在内存里的，当程序重启或者服务崩溃，数据就会丢失，所以需要持久化，即把数据保存到可永久保存的存储设备中&lt;/p&gt;&#xA;&lt;h4 id=&#34;持久化方法&#34;&gt;持久化方法&lt;/h4&gt;&#xA;&lt;p&gt;redis提供两种方式来持久化：&lt;/p&gt;&#xA;&lt;h5 id=&#34;1rdbredis-database&#34;&gt;1.RDB(Redis Database)&lt;/h5&gt;&#xA;&lt;p&gt;记录Redis某个时刻的全部数据，这个方法的本质就是数据快照，直接保存二进制数据到磁盘，后续通过加载RDB文件恢复数据&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjc1YTM5MmU0NGI0MTVmNDVmYjMxZGU1ODg3ZTNiMDZfM01CeE9kMU9iRlVlSTNyUTBRSHFVa0dNS3RwUEJ2MHRfVG9rZW46RGR5NGIxdFJrb0NPa1l4RzJ2OWNsUHNsbnRjXzE3MjE4NDE0NjM6MTcyMTg0NTA2M19WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h5 id=&#34;2aofappend-only-file&#34;&gt;2.AOF(Append Only File)&lt;/h5&gt;&#xA;&lt;p&gt;记录执行的每条命令，重启之后通过重放命令来恢复数据，AOF是记录操作日志，后续通过日志重放恢复数据&lt;/p&gt;&#xA;&lt;h5 id=&#34;两种持久化方法的对比&#34;&gt;两种持久化方法的对比（*）&lt;/h5&gt;&#xA;&lt;p&gt;上面两种持久化方法对比：RDB（快照恢复）和AOF（日志恢复）&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;体积方面：相同数据量下，RDB体积小，因为RDB记录的是二进制紧凑型数据&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;恢复速度方面：RDB是数据快照，可以直接加载，而AOF文件恢复，相当于重放情况，RDB显然更快&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据完整性：AOF记录了每条日志，RDB是间隔一段时间记录一次，用AOF恢复数据通常会更加完整&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;rdb好还是aof好&#34;&gt;RDB好还是AOF好&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;业务本身需要的是缓存数据并且不是一个海量访问，可以不用开持久化&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对数据本身十分重视，可以同时开启RDB和AOF，注意，在同时开启的情况下，只会用AOF来加载，如果只有RDB文件而没有AOF文件，不会用RDB文件去恢复数据，如果逻辑是你自主开启选择AOF，表明要强一点的一致性，但是AOF文件缺失，此时不会去使用RDB，业务RDB会少很多数据，此时启动是一个空库&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;1rdb&#34;&gt;1.RDB&lt;/h3&gt;&#xA;&lt;p&gt;RDB文件的内容是**二进制数据，**记录的是某一瞬间的内存数据，是实际的数据，也叫做快照&lt;/p&gt;&#xA;&lt;p&gt;在Redis恢复数据时，RDB恢复数据的效率会比AOF高，因为会直接读取RDB文件到内存即可，不需要像AOF那样还需要额外执行操作命令的步骤才能恢复数据&lt;/p&gt;&#xA;&lt;h4 id=&#34;11-rdb怎么使用&#34;&gt;1.1 RDB怎么使用&lt;/h4&gt;&#xA;&lt;p&gt;Redis提供两个命令来使用RDB文件，分别是&lt;code&gt;save&lt;/code&gt; 和&lt;code&gt;bgsave&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;save&lt;/code&gt; :执行了save命令，会在主线程生成RDB文件，由于和执行操作命令在同一个线程，所以写入RDB文件的时间太长，会&lt;strong&gt;阻塞主线程&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;code&gt;bgsave&lt;/code&gt; :执行了bgsave命令，会创建一个子进程来生成RDB文件，这样可以&lt;strong&gt;避免主线程的阻塞&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;RDB文件的加载工作是在服务器启动时自动执行，Redis并没有提供专门加载RDB文件的命令&lt;/p&gt;&#xA;&lt;p&gt;在Redis的配置文件中，有以下的选项来实现每隔一段时间自动执行一次bgsave命令&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Plain&#34; data-lang=&#34;Plain&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 这里写的是save，实际上是bgsave&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;save 900 1         # 900s之内，对数据库进行至少1次修改&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;save 300 10        # 300s之内，对数据库进行至少10次修改&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;save 60 10000      # 60s之内，对数据库进行至少10000次修改&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Redis的快照是&lt;strong&gt;全量快照&lt;/strong&gt;，也就是说每次执行快照，都是把内存中的所有数据记录到磁盘中&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;RDB快照的缺点：当服务器发送故障时，丢失的数据会比AOF更多&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;12-执行快照时bgsave修改数据会发生什么&#34;&gt;1.2 执行快照时（bgsave），修改数据会发生什么？&lt;/h4&gt;&#xA;&lt;p&gt;在执行bgsave时，主线程是可以继续执行操作命令，由子线程来构建RDB文件，所以内存里的数据是可以修改的&lt;/p&gt;&#xA;&lt;p&gt;实现这一功能靠的是&lt;strong&gt;写时复制****技术&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;流程如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;执行bgsave命令时，会fork()创建子进程，此时子进程和父进程是共享同一片内存数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;主进程创建子进程时，子进程会复制父进程的页表，但是页表指向的物理内存跟主进程是同一个物理内存&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;此时如果主线程由写命令的执行，就会发生写时复制，物理内存才会被复制一次&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;发生&lt;strong&gt;&lt;strong&gt;写时复制&lt;/strong&gt;&lt;/strong&gt;后，&lt;strong&gt;&lt;strong&gt;RDB&lt;/strong&gt;&lt;/strong&gt;快照保存的是原本的&lt;strong&gt;&lt;strong&gt;内存&lt;/strong&gt;&lt;/strong&gt;数据&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这是因为创建bgsave子进程后，由于父子进程共享所有内存数据，所以可以直接将数据写入到RDB文件&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当主进程对共享的内存数据是&lt;strong&gt;只读****操作&lt;/strong&gt;，那么主进程和bgsave子进程是相互不影响&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当主进程对共享的内存数据进行&lt;strong&gt;写操作&lt;/strong&gt;时，就会发生&lt;strong&gt;写时复制&lt;/strong&gt;，这块数据的物理内存就会被复制一份，然后主线程在这个&lt;strong&gt;数据副本进行写操作&lt;/strong&gt;，此时bgsave子进程继续把原来的数据（原物理内存）写入到RDB文件&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;执行bgsave时，在极端情况下，如果所有的共享内存都被修改，则此时的内存占用是原先的两倍&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;13-什么时候执行rdb持久化&#34;&gt;1.3 什么时候执行RDB持久化&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主动执行命令save&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主动执行命令bgsave&lt;/p&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL事务</title>
      <link>https://ahang7.github.io/post/basic/mysql/2.-mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/2.-mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>&lt;h2 id=&#34;1事务有哪些特征&#34;&gt;1.事务有哪些特征&lt;/h2&gt;&#xA;&lt;p&gt;原子性，隔离性，一致性，持久性&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;原子性：要么全做，要么全不做&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;隔离性：保证其它的状态转换不会影响到本次状态的转&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一致性：数据全部符合现实世界的约束&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;持久性： 更新后的数据存储到磁盘&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;InnoDB引擎通过以下技术来保证事务的四个特性&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;持久性是通过 redo log（重做日志）来保证&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;原子性是通过 undo log（回滚日志）来保证&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;隔离性是通过 mvcc（多版本并发控制）或者锁机制来保证&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一致性是通过持久性+原子性+隔离性来保证&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;2并发事务会引发的问题&#34;&gt;2.并发事务会引发的问题&lt;/h2&gt;&#xA;&lt;p&gt;MySQL服务端是允许多个客户端连接，这意味着MySQL会出现同时处理多个事务的情况&lt;/p&gt;&#xA;&lt;p&gt;在同时处理多个事务的时候，可能会出现脏读、不可重复读、幻读的问题&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;脏读：一个事务读到了另一个&lt;strong&gt;未提交事务修改过&lt;/strong&gt;的数据&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;不可重复读：在一个事务中多次读取同一个&lt;strong&gt;数据&lt;/strong&gt;，出现前后两次读到的数据不一样的情况&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;幻读：在一个事务中多次查询某个符合查询条件的&lt;strong&gt;记录数量&lt;/strong&gt;，如果出现前后两次查询到的记录数据不一样的情况&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;以上三个现象，问题的严重性是 脏读 &amp;gt; 不可重复读 &amp;gt; 幻读&lt;/p&gt;&#xA;&lt;h2 id=&#34;3事务的隔离级别&#34;&gt;3.事务的隔离级别&lt;/h2&gt;&#xA;&lt;p&gt;四种隔离级别：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读未提交：指一个事务还没有提交时，它做的变更就能被其他事务看到&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读提交：指一个事务提交之后，它做的变更才能被其他事务看到&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，&lt;strong&gt;MySQL&lt;/strong&gt; &lt;strong&gt;InnoDB引擎的默认隔离级别&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;串行化：对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生读写冲突的时候，后访问的事务必须等前一个事务执行完成&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;按隔离水平高低排序如下：&lt;/p&gt;&#xA;&lt;p&gt;串行化 &amp;gt; 可重复读 &amp;gt; 读已提交 &amp;gt; 读未提交&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;针对不同的隔离级别：并发事务时可能发生的现象也不同&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读未提交：脏读、不可重复读、幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;读提交：不可重复读、幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可重复读：幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;串行化：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;可重复读的隔离级别下，可以&lt;strong&gt;很大程度上避免&lt;/strong&gt;幻读现象的发生，所以MySQL不使用串行化隔离级别来避免幻读现象的发生，因为&lt;strong&gt;串行化隔离级别会影响性能&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;InnoDB在默认隔离级别：&lt;strong&gt;可重复读&lt;/strong&gt;的情况下很大程度上解决幻读现象的解决方案有两种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;针对**快照读（普通 select 语句），**是通过MVCC方式解决幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;针对**当前读（select &amp;hellip; for update），**通过next-key lock（记录锁+间隙锁）方式解决了幻读&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;四种隔离事务是怎么实现的&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于读未提交：可以读到未提交事务修改的数据，所以直接读取就行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于串行化，通过加读写锁的方式来避免并行访问&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于读提交和可重复读这两种隔离级别的事务，是通过Read View来实现的，它们的区别是在于创建Read View时，读提交隔离级别是在每个语句执行之前都会重新生成一个Read View；而可重复读隔离级别是启动事务时生成一个Read View，然后整个事务都在用这个Read View&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在执行开启事务命令，并不意味着启动了事务：&lt;/p&gt;&#xA;&lt;p&gt;在MySQL中，开启事务有两种命令，分别是：&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] 执行流程</title>
      <link>https://ahang7.github.io/post/basic/redis/3-redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/3-redis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;四执行流程&#34;&gt;四、执行流程&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内存结构&lt;/li&gt;&#xA;&lt;li&gt;核心执行是单线程&lt;/li&gt;&#xA;&lt;li&gt;多线程负载一些异步任务&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;1redis在内存中是怎么存储的&#34;&gt;1.Redis在内存中是怎么存储的&lt;/h3&gt;&#xA;&lt;p&gt;redis是内存存储，将数据放在redis时，都是以键值对形式存到内存&lt;/p&gt;&#xA;&lt;h4 id=&#34;数据库结构&#34;&gt;数据库结构&lt;/h4&gt;&#xA;&lt;p&gt;redisDb代表Redis数据库结构，各种操作对象，都是存储在dict数据结构里&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// redisDb 结构&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;//字典&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;expires&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 过期键&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;blocking_keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ready_keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;watched_keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;avg_ttl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;defrag_later&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisDb&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// dict 结构&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dictType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;privdata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;dictht&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ht&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rehashidx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iterators&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;redisDb即数据库对象，指向了数据字典，字典包含我们平常存储的k-v数据，v支持任意redis对象&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjUwNmMwNDdlZTRiYmE0ODNjZjNlYWE1M2U2ZjRhZmZfMVhzNEFiWk0xQ2tYMXh0T21yQ045OGgwOVVLSzhDV0NfVG9rZW46VkdtbmJwMEZSb0tqcHF4ckhqVGNrTHI4blBkXzE3MjE4NDE0MjU6MTcyMTg0NTAyNV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在增加、查询、更新、删除的操作后，分别在内存存储是怎么体现的？&lt;/p&gt;&#xA;&lt;h4 id=&#34;增删改查在redis内存中的体现&#34;&gt;增删改查在Redis内存中的体现&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;即添加键值对，添加到dict结构字典中，Key必须为String对象，value为任何类型的对象&lt;/p&gt;&#xA;&lt;p&gt;添加数据后，会在redisDb里字段dict上添加dict对象&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查询数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;直接在dict找到对应的key，即完成查询&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;更新数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;对已经Key对象的任何变更操作，都是更新&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;删除数据&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;删除即把key和value从dict结构里删除&lt;/p&gt;&#xA;&lt;h4 id=&#34;过期键&#34;&gt;过期键&lt;/h4&gt;&#xA;&lt;p&gt;Redis可以设置过期键，到达一定时间，这些对象会被自动过期并回收&lt;/p&gt;&#xA;&lt;p&gt;**过期键存储在&lt;strong&gt;&lt;strong&gt;expires&lt;/strong&gt;&lt;/strong&gt;字典上，**expires字典中，value就是过期时间&lt;/p&gt;&#xA;&lt;p&gt;在redisDb中，dict和expires中Key对象，实际都是存储String对象指针，两个的key都会指向内存相应的字符串地址&lt;/p&gt;&#xA;&lt;h3 id=&#34;2redis是单线程还是多线程&#34;&gt;2.Redis是单线程？还是多线程？&lt;/h3&gt;&#xA;&lt;p&gt;redis是一个能高效处理请求的组件&lt;/p&gt;&#xA;&lt;p&gt;核心处理逻辑，Redis一直都是单线程，其他辅助模块会有一些多线程、多进程的功能，例如：复制模块用的多进程；某些异步流程从4.0开始用多线程；网络I/O解包从6.0开始用多线程；&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;核心处理逻辑：Redis在处理客户端的请求时，包括获取（socket写）、解析、执行、内容返回等都是由一个顺序串行的主线程处理，这就是所谓的单线程&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h4 id=&#34;redis为什么选择单线程&#34;&gt;Redis为什么选择单线程&lt;/h4&gt;&#xA;&lt;p&gt;redis的定位是内存k-v存储，是做短平快的热点数据处理，一般来说执行会很快，执行本身不会成为瓶颈，瓶颈通常在网络I/O，处理逻辑多线程并不会有太大收益&lt;/p&gt;&#xA;&lt;p&gt;同时Redis本身秉持简洁高效的理念，代码的简单性、可维护性是redis一直依赖的追求，执行本身不应该成为瓶颈，而且多线程本身也会引起额外成本&lt;/p&gt;&#xA;&lt;h4 id=&#34;1多线程引入的复杂度是极大的&#34;&gt;1.多线程引入的复杂度是极大的&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多线程引入后，redis原来的顺序执行特性就不复存在，为了事务的原子性、隔离性，redis就不得不引入一些很复杂的实现&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;redis的数据结构是极其高效，在单线程模式下做了很多特性的优化，如果引入多线程，那么所有底层数据都要改为线性安全，这很复杂&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;多线程模式使得程序调试更加复杂和麻烦，会带来额外的开发成本及运营成本&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;2多线程带来额外的成本&#34;&gt;2.多线程带来额外的成本&lt;/h4&gt;&#xA;&lt;p&gt;除了引入复杂度，多线程还会带来额外成本，包括&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;上下文切换成本，多线程调度需要切换线程上下文，这个操作先存储当前线程的本地数据，程序指针，然后载入另一个线程数据，这种内核操作的成本不可忽略&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;同步机制的开销，一些公共资源，在单线程模式下直接访问就行，多线程需要通过加锁等方式进行同步&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一个线程本身也占据内存大小，对redis这种内存数据库来说，内存非常珍贵，多线程本身带来的内存使用的成本也需要谨慎决策&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;总结&#34;&gt;总结&lt;/h4&gt;&#xA;&lt;p&gt;多线程会引入额外的复杂度和成本，而redis是追求简洁高效的存储组件，而且事实也证明，虽然redis是单线程处理架构，redis性能还是经受住了考验&lt;/p&gt;&#xA;&lt;h3 id=&#34;3redis单线程为什么能这么快&#34;&gt;3.Redis单线程为什么能这么快&lt;/h3&gt;&#xA;&lt;h4 id=&#34;redis单线程&#34;&gt;Redis单线程&lt;/h4&gt;&#xA;&lt;p&gt;Redis核心的请求处理是单线程，但是Redis却能使用单线程模型达到每秒数万级别的处理能力，这是Redis多方面极致设计的一个综合结果&lt;/p&gt;</description>
    </item>
    <item>
      <title>[MySQL] MySQL索引</title>
      <link>https://ahang7.github.io/post/basic/mysql/1.-mysql%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/mysql/1.-mysql%E7%B4%A2%E5%BC%95/</guid>
      <description>&lt;h2 id=&#34;1-b树索引数据结构&#34;&gt;1. B+树（索引数据结构）&lt;/h2&gt;&#xA;&lt;p&gt;什么是索引？&#xA;为什么索引能加快查询？&#xA;索引的数据结构是什么？&#xA;B+ 树 和（B 树 和 红黑树）有什么区别？&#xA;为什么选择 B+树 作为索引数据结构？&lt;/p&gt;&#xA;&lt;h3 id=&#34;为什么mysql-innodb选择b-tree作为索引&#34;&gt;为什么Mysql InnoDB选择B+ Tree作为索引？&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;B+ 树 vs B 树&#xA;B+ 树只在叶子节点存储数据，B树的非叶子节点也要存储数据，所以B+ 树的单个节点的数据量更小&lt;/li&gt;&#xA;&lt;li&gt;B+ 树 vs 二叉树&#xA;对于有N个叶子节点的B+ 树，搜索复制度为O（logdn）&lt;/li&gt;&#xA;&lt;li&gt;B+ 树 vs Hash&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/08%20%20%E7%B4%A2%E5%BC%95%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E8%89%BA%E6%9C%AF.md&#34;&gt;08 索引:排序的艺术&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html&#34;&gt;为什么 MySQL 采用 B+ 树作为索引？&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;2-索引组织表索引存储&#34;&gt;2. 索引组织表（索引存储）&lt;/h2&gt;&#xA;&lt;p&gt;堆表和索引组织表有什么区别？&lt;/p&gt;&#xA;&lt;p&gt;分别应用场景是什么？&lt;/p&gt;&#xA;&lt;p&gt;Mysql InnoDB存储引擎中数据存储方式：&lt;strong&gt;索引组织表&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;数据存储有&lt;strong&gt;堆表和索引组织表两种。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;堆表中的数据是无序存放的，数据的排序完全依赖索引&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;索引组织表，数据根据主键进行排序存放在索引中，主键索引也叫&lt;strong&gt;聚集索引&lt;/strong&gt;（Clustered Index）&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在索引组织表中，数据即索引，索引即数据&lt;/p&gt;&#xA;&lt;h3 id=&#34;二级索引&#34;&gt;二级索引&lt;/h3&gt;&#xA;&lt;p&gt;InnoDB存储引擎的数据是根据主键索引排序存储的，除了主键索引外，其它的索引都称为二级索引（Secondeary Index），或者非聚集索引&lt;/p&gt;&#xA;&lt;p&gt;二级索引也是一颗B+树索引，但是它和主键索引不同的是叶子节点存放的是索引键值、主键值&lt;/p&gt;&#xA;&lt;p&gt;通过二级索引&lt;code&gt;idx_name&lt;/code&gt; 只能定位主键值，需要额外再通过主键索引进行查询，才能得到最终结果。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;这种二级索引通过&lt;strong&gt;&lt;strong&gt;主键&lt;/strong&gt;&lt;/strong&gt;索引进行再一次查询的操作叫做“回表”&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这样的二级索引设计的好处：若记录发生了修改，则其它索引无须进行维护，除非记录的主键发生了修改&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;在索引组织表中，万物皆索引，索引就是数据，数据就是索引&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;二级索引的性能评估&#34;&gt;二级索引的性能评估&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;要比较顺序，对聚集索引性能友好&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;尽可能紧凑，对二级索引的性能和存储友好&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;函数索引先了解&#34;&gt;函数索引（先了解）&lt;/h3&gt;&#xA;&lt;p&gt;&amp;hellip;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/09%20%20%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E8%A1%A8%EF%BC%9A%E4%B8%87%E7%89%A9%E7%9A%86%E7%B4%A2%E5%BC%95.md&#34;&gt;09 索引组织表:万物皆索引&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;3组合索引联合索引&#34;&gt;3.组合索引（联合索引）&lt;/h2&gt;&#xA;&lt;p&gt;联合索引的结构是什么？&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] redis 对象</title>
      <link>https://ahang7.github.io/post/basic/redis/2-redis%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/2-redis%E5%AF%B9%E8%B1%A1/</guid>
      <description>&lt;h2 id=&#34;三对象&#34;&gt;三、对象&lt;/h2&gt;&#xA;&lt;h3 id=&#34;redis-object-是什么&#34;&gt;Redis Object 是什么？&lt;/h3&gt;&#xA;&lt;p&gt;redis是key-value存储，key-value在redis中被抽象为对象(Object)，key只能是String对象，value支持丰富的对象类型{String, List, Set, Hash, Sorted Set, Stream&amp;hellip;}&lt;/p&gt;&#xA;&lt;h4 id=&#34;object在内存中的样子&#34;&gt;Object在内存中的样子&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define LRU_BITS 24&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reidsObject&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LRU_BITS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;refcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;Type: 查看redis对象&lt;/li&gt;&#xA;&lt;li&gt;Encoding: 表明使用哪种底层编码&lt;/li&gt;&#xA;&lt;li&gt;Lru: 记录对象访问信息，用于内存淘汰&lt;/li&gt;&#xA;&lt;li&gt;Refcount: 引用计数，用来描述有多少指针，指向该对象&lt;/li&gt;&#xA;&lt;li&gt;Ptr: 内容指针，指向实际内容&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;对象与数据结果&#34;&gt;对象与数据结果&lt;/h4&gt;&#xA;&lt;p&gt;实际操作的对象有6个Redis对象，他们的底层依赖一些数据对象，包括字符串、跳表、哈希表、压缩列表、双端列表等&lt;/p&gt;&#xA;&lt;h3 id=&#34;1string&#34;&gt;1.String&lt;/h3&gt;&#xA;&lt;h4 id=&#34;string是什么&#34;&gt;String是什么&lt;/h4&gt;&#xA;&lt;p&gt;String是字符串，是Redis中最基本的数据对象，最大为512MB，可以通过配置项&lt;strong&gt;proto-max-bulk-len&lt;/strong&gt;修改它&lt;/p&gt;&#xA;&lt;p&gt;String可以存储各种类型的字符串（包括二进制文件）&lt;/p&gt;&#xA;&lt;h4 id=&#34;适用场景&#34;&gt;适用场景&lt;/h4&gt;&#xA;&lt;p&gt;使用场景：一般用来存放&lt;strong&gt;字节数据&lt;/strong&gt;、&lt;strong&gt;文本数据&lt;/strong&gt;、&lt;strong&gt;序列化****后的对象数据&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;例子：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;缓存场景：Value存Json字符串等信息&lt;/li&gt;&#xA;&lt;li&gt;计数场景：因为Redis处理命令是单线程，所以执行命令的过程是原子的，因此String数据类型适合计数场景&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;在redis中怎么使用&#34;&gt;在redis中怎么使用：&lt;/h4&gt;&#xA;&lt;p&gt;常用操作：创建、查询、更新、删除&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;创建 &amp;ndash;&amp;gt; set, setnx&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;SET&lt;/strong&gt; key value # 设置一个key值为特定的value&#xA;  set命令扩展参数：EX（键过期时间秒）、PX（键过期时间毫秒）、NX（只有键不存在时才对键进行操作，基本替代下面的SETNX操作）、XX（键存在时才对键进行操作）&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;SETNX&lt;/strong&gt; key value # 用于在指定的&lt;strong&gt;key不存在&lt;/strong&gt;时，为key设置指定的值&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查询 &amp;ndash;&amp;gt; get, mget&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Get&lt;/strong&gt; key # 查询某个key，存在就返回对应的value，不存在返回nil&lt;/p&gt;</description>
    </item>
    <item>
      <title>[redis] Base理论</title>
      <link>https://ahang7.github.io/post/basic/redis/1-redis-base%E7%90%86%E8%AE%BA/</link>
      <pubDate>Fri, 25 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/redis/1-redis-base%E7%90%86%E8%AE%BA/</guid>
      <description>&lt;h2 id=&#34;一什么是redis&#34;&gt;一、什么是redis？&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redis是一个内存数据结构储存，KV储存&lt;/li&gt;&#xA;&lt;li&gt;常用于缓存、消息中转、数据流引擎、分布式锁&lt;/li&gt;&#xA;&lt;li&gt;支持的数据结构有：字符串、散列、列表、集合、带范围查询的排序集合、位图、超日志、地理空间索引和流&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;(strings, hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs, geospatial indexes, and streams)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;redis内置了复制、Lua脚本、LRU驱逐、事务和不同级别的磁盘持久化&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://try.redis.io/&#34;&gt;Try Redis&lt;/a&gt; 官方redis在线操作平台&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;二base理论&#34;&gt;二、Base理论&lt;/h2&gt;&#xA;&lt;p&gt;Base理论是CAP中一致性的妥协，不追求强一致性，允许数据在一段时间内不一致，但是最终达到一致状态&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://rt5bap83jl.feishu.cn/docx/XXiHdxRVRokY7vxCqVccZ9PlnVe&#34;&gt;分布式系统的CAP定理与BASE理论&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>[golang] snc.Map</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/sync.map/</link>
      <pubDate>Fri, 04 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/sync.map/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] string</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/string/</link>
      <pubDate>Thu, 03 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/string/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] Map</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/map/</link>
      <pubDate>Wed, 02 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/map/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] interface</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/interface/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/interface/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] context</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/context/</link>
      <pubDate>Mon, 30 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/context/</guid>
      <description></description>
    </item>
    <item>
      <title>[golang] channel</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/channel/</link>
      <pubDate>Sun, 29 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/channel/</guid>
      <description></description>
    </item>
    <item>
      <title>[git] git-commit-message 规范</title>
      <link>https://ahang7.github.io/post/basic/git/git-commit-message/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/git/git-commit-message/</guid>
      <description>&lt;h1 id=&#34;符合angular规范的commit-message&#34;&gt;符合Angular规范的Commit Message&lt;/h1&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;type&amp;gt;[(optional scope)]: &amp;lt;description&amp;gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[optional body]  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[optional footers]  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;分为了Header、Body、footer三个部分&lt;/p&gt;&#xA;&lt;h2 id=&#34;header&#34;&gt;Header&lt;/h2&gt;&#xA;&lt;p&gt;Header部分只有一行&lt;code&gt;&amp;lt;type&amp;gt;[(optional scope)]: &amp;lt;description&amp;gt;&lt;/code&gt;，其中type必选，其它可选&lt;/p&gt;&#xA;&lt;p&gt;type&amp;ndash;&amp;gt;归为两类：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Development(项目管理类变更，不影响用户和生产环境的代码)&lt;/li&gt;&#xA;&lt;li&gt;Production(影响用户和生产环境的代码)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;类型&lt;/th&gt;&#xA;          &lt;th&gt;类别&lt;/th&gt;&#xA;          &lt;th&gt;说明&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;feat&lt;/td&gt;&#xA;          &lt;td&gt;Production&lt;/td&gt;&#xA;          &lt;td&gt;新增功能&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;fix&lt;/td&gt;&#xA;          &lt;td&gt;Production&lt;/td&gt;&#xA;          &lt;td&gt;修复缺陷&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;perf&lt;/td&gt;&#xA;          &lt;td&gt;Production&lt;/td&gt;&#xA;          &lt;td&gt;提高代码性能的变更&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;style&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;代码格式类的变更，例如使用gofmt格式化代码&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;refactor&lt;/td&gt;&#xA;          &lt;td&gt;Production&lt;/td&gt;&#xA;          &lt;td&gt;其他代码类的变更，例如 简化代码、重命名变量、删除冗余代码等等&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;test&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;新增测试用例或更新现有的测试用例&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;ci&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;持续基础和部署相关的改动，例如修改Jenkins、GitLab CI等Ci配置文件或者更新系统单元文件&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;docs&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;文档类的更新，包括修改用户文档、开发文档&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;chore&lt;/td&gt;&#xA;          &lt;td&gt;Development&lt;/td&gt;&#xA;          &lt;td&gt;其他类型，例如构建流程、依赖管理或者复制工具的变动&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;scope&amp;ndash;&amp;gt;不设置太具体的值，说明commit的影响范围&lt;br&gt;&#xA;description&amp;ndash;&amp;gt;对commit的简短描述，以动词开头&lt;/p&gt;&#xA;&lt;h2 id=&#34;body&#34;&gt;Body&lt;/h2&gt;&#xA;&lt;p&gt;Body对Commit Message的高度概况，方便查看具体做了什么变更&lt;/p&gt;&#xA;&lt;h2 id=&#34;footer&#34;&gt;Footer&lt;/h2&gt;&#xA;&lt;p&gt;Footer部分不是必选，可根据需要选择，主要用来说什么本次commit导致的后果，通常用来说明不兼容的改动或者关闭的issue&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BREAKING CHANGE: &amp;lt;breaking change summary&amp;gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;breaking change description + migration instructions&amp;gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 空行  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Fixes(Closes) #&amp;lt;issue number&amp;gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;revert-commit&#34;&gt;Revert Commit&lt;/h2&gt;&#xA;&lt;p&gt;特殊的Commit Message。还原了先前的commit，则以&lt;code&gt;revert&lt;/code&gt;开头，后面跟还原的commit的Header，&lt;br&gt;&#xA;在Body必须写&lt;code&gt;This reverts commit &amp;lt;hash&amp;gt;&lt;/code&gt;，其中hash为要还原的commit的SHA标识&lt;/p&gt;</description>
    </item>
    <item>
      <title>[git] git-README 参考</title>
      <link>https://ahang7.github.io/post/basic/git/git-readme/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/git/git-readme/</guid>
      <description>&lt;h1 id=&#34;项目名称&#34;&gt;项目名称&lt;/h1&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;功能特性&#34;&gt;功能特性&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;软件架构可选&#34;&gt;软件架构(可选)&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;快速开始&#34;&gt;快速开始&lt;/h2&gt;&#xA;&lt;h3 id=&#34;依赖检查&#34;&gt;依赖检查&lt;/h3&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h3 id=&#34;构建&#34;&gt;构建&lt;/h3&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;使用指南&#34;&gt;使用指南&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;如何贡献&#34;&gt;如何贡献&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;社区可选&#34;&gt;社区(可选)&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;关于作者&#34;&gt;关于作者&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;谁在用可选&#34;&gt;谁在用(可选)&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;h2 id=&#34;许可证&#34;&gt;许可证&lt;/h2&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    <item>
      <title>[golang] rpc</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%AE%9E%E8%B7%B5/1.-rpc/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%AE%9E%E8%B7%B5/1.-rpc/</guid>
      <description>&lt;p&gt;rpc包路径&lt;code&gt;net/rpc&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;RPC服务的接口规范分为三个部分：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;服务名&lt;/li&gt;&#xA;&lt;li&gt;服务要实现的方法列表&lt;/li&gt;&#xA;&lt;li&gt;注册服务&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;注册服务的时候在RPC服务的名称中增加包路径前缀（这个RPC服务抽象的包路径，非真实的包路径）&lt;/p&gt;</description>
    </item>
    <item>
      <title>[golang] 内存逃逸</title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%8E%9F%E7%90%86/%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8/</guid>
      <description></description>
    </item>
    <item>
      <title>[MQ] 消息队列</title>
      <link>https://ahang7.github.io/post/basic/middlewares/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97mq/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/middlewares/mq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97mq/</guid>
      <description>&lt;p&gt;消息队列是大型分布式系统不可缺少的中间件，也是高并发系统的基石中间件&lt;/p&gt;&#xA;&lt;h2 id=&#34;一消息队列mq概述&#34;&gt;一、消息队列MQ概述&lt;/h2&gt;&#xA;&lt;p&gt;消息队列（Message Queue），指保存消息的一个容器，本质是个&lt;!-- raw HTML omitted --&gt;队列&lt;!-- raw HTML omitted --&gt;，传送的消息可以是文本字符串，也可以是复杂的嵌入对象&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;基本模型&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;&#xA;&lt;h4 id=&#34;1异步处理&#34;&gt;1.异步处理&lt;/h4&gt;&#xA;&lt;p&gt;消息队列的主要特点是异步处理，主要目的是减少请求响应的时间，实现非核心流程异步化，提高系统响应性能&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;了解同步与异步&lt;a href=&#34;https://blog.csdn.net/hong521520/article/details/106671930&#34;&gt;同步与异步的区别(一看则懂)_同步和异步的区别-CSDN博客&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;异步的经典场景就是将比较耗时而且不需要即时（同步）返回结果的操作，通过&lt;strong&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/strong&gt;来实现****异步化&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;2应用解耦&#34;&gt;2.应用解耦&lt;/h4&gt;&#xA;&lt;p&gt;解耦：保证消息格式不变，消息的发送方和接收方之间并不需要彼此联系，也不受对方的影响&lt;/p&gt;&#xA;&lt;p&gt;只通过消息队列MQ来联系（？）&lt;/p&gt;&#xA;&lt;h4 id=&#34;3流量削锋&#34;&gt;3.流量削锋&lt;/h4&gt;&#xA;&lt;p&gt;一般在秒杀或团抢活动中使用广泛&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;这种场景中系统的&lt;strong&gt;&lt;strong&gt;峰值流量&lt;/strong&gt;&lt;/strong&gt;往往集中于一小段时间内，所以为了防止系统在短时间内的峰值流量冲垮，往往采用&lt;strong&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/strong&gt;来削弱峰值流量，相当于消息队列做了一次缓冲&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;4日志处理&#34;&gt;4.日志处理&lt;/h4&gt;&#xA;&lt;p&gt;日志处理是指将消息队列用在日志处理中，以解决大量日志传输的问题（比如Kafka）&lt;/p&gt;&#xA;&lt;p&gt;暂时无法在飞书文档外展示此内容&lt;/p&gt;&#xA;&lt;h2 id=&#34;二消息队列mq设计&#34;&gt;二、消息队列MQ设计&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1整体框架&#34;&gt;1.整体框架&lt;/h3&gt;&#xA;&lt;p&gt;暂时无法在飞书文档外展示此内容&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Producer 消息生产者：负责产生和发生消息到Broker；&lt;/li&gt;&#xA;&lt;li&gt;Broker 消息处理中心：负责消息存储、确认、重试等，一般会有多个queue；&lt;/li&gt;&#xA;&lt;li&gt;Consumer 消息消费者：负责从Broker中获取消息，并进行相应处理；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;2详细设计&#34;&gt;2.详细设计&lt;/h3&gt;&#xA;&lt;p&gt;Producer生产者 产生消息 &amp;ndash;&amp;gt; Broker消息处理中心 存储消息 &amp;ndash;&amp;gt; Consumer 消费者对消费消息，返回 消息确认 &amp;ndash;&amp;gt; Broker 进行消息备份/删除&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;RPC通信&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Producer产生消息，Consumer消费消息都会涉及到通信的问题，消息队列使用了RPC将数据流串起来&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;Broker存储&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;消息到达服务端后需要存储到Broker&lt;/p&gt;&#xA;&lt;p&gt;流量削峰、最终一致性等需求都是需要Broker先存储下来，等待合适的时机投递&lt;/p&gt;&#xA;&lt;p&gt;存储可以有很多方式，存储在内存，分布式KV，磁盘，数据库等，存储的选项需要考虑&lt;strong&gt;综合性能/高可用和开发维护成本&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;消费模型&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;消息到达Broker后，最终需要Consumer去消费消息，这里涉及到消费模型&lt;/p&gt;&#xA;&lt;p&gt;目前主要有两种：单播和广播&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;单播：点到点&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;广播：一点对多点&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;高级特性&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Consumer端把消息消费了，除了需要消息确认，还会涉及到比如：重复消息、顺序消息、消息延迟、事务消息等需要考虑的高级特性&lt;/p&gt;&#xA;&lt;h3 id=&#34;消息队列mq模型&#34;&gt;消息队列MQ模型&lt;/h3&gt;&#xA;&lt;p&gt;主要有两种模型：&lt;strong&gt;点对点&lt;/strong&gt; 与 &lt;strong&gt;发布订阅&lt;/strong&gt; 两种模型&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://aws.amazon.com/cn/message-queue/&#34;&gt;消息队列是什么_mq是什么_MQ消息队列服务-AWS云服务&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/431149128&#34;&gt;深入消息队列MQ，看这篇就够了！&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>docker-基础</title>
      <link>https://ahang7.github.io/post/basic/docker/docker/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/docker/docker/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://yeasy.gitbook.io/docker_practice/&#34;&gt;https://yeasy.gitbook.io/docker_practice/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;一基本概念&#34;&gt;一、基本概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;镜像(&lt;code&gt;Image&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;容器(&lt;code&gt;Container&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;仓库(&lt;code&gt;Repository&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;理解以上三个概念，就能理解docker的生命周期&lt;/p&gt;&#xA;&lt;h3 id=&#34;1镜像&#34;&gt;1.镜像&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;Docker镜像&lt;/strong&gt;是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件，以及一些运行时所需的配置参数。镜像不包含任何动态数据，其内容在插件之后也不会被改变&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分层存储&lt;/strong&gt;，镜像采用了分层存储的架构，由一组文件系统组成的（多层文件系统联合组成）。在构建镜像时，会一层一层构建，后一层依赖于上一层，后一层上的任何改变都只会发生在本层，不会干涉到上一层。因此构建镜像的时候，需要对每层需要添加的东西尽量加最少最有必要的东西，减少额外的东西&lt;/p&gt;&#xA;&lt;p&gt;分层存储的特征还使得&lt;strong&gt;镜像的复用，定制&lt;/strong&gt;更为容易&lt;/p&gt;&#xA;&lt;h3 id=&#34;2容器&#34;&gt;2.容器&lt;/h3&gt;&#xA;&lt;p&gt;容器是镜像运行时的实体，可以被创建、启动、停止、删除暂停等&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;镜像(Image)和容器(container)的关系，就像是面向对象程序设计中的&lt;code&gt;类&lt;/code&gt; 和&lt;code&gt;实例&lt;/code&gt; 一样&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;容器的实质是进程，运行于属于自己的独立的命名空间。因此容器可以拥有自己的&lt;code&gt;root&lt;/code&gt; 文件系统，网络配置、进程空间等，运行在一个隔离的环境。这样的隔离特性，使得容器封装的应用比直接在宿主运行更加安全&lt;/p&gt;&#xA;&lt;p&gt;容器也是分层存储，是&lt;strong&gt;以镜像为基础层&lt;/strong&gt;，在其上创建一个当前容器的存储层，这个层是为容器运行时进行读写而准备的，称为&lt;strong&gt;容器存储层&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;容器存储层的生命周期跟容器一样，当容器消亡时，容器存储层也随之消亡，因此任何保存于容器存储层的信息都会随着容器的删除而丢失&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Dokcer最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层保存无状态化，所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录&lt;/p&gt;&#xA;&lt;p&gt;数据卷独立于容器，使用容器卷，容器的删除或者重写运行之后，数据都不会丢失&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;3仓库&#34;&gt;3.仓库&lt;/h3&gt;&#xA;&lt;p&gt;Docker Register：提供一个集中的存储、分发镜像的服务&lt;/p&gt;&#xA;&lt;p&gt;一个&lt;strong&gt;Docker Register&lt;/strong&gt;可以包含多个**仓库（&lt;strong&gt;&lt;strong&gt;Repository&lt;/strong&gt;&lt;/strong&gt;）;&lt;strong&gt;每个仓库可以包含多个&lt;/strong&gt;标签（Tag）,**每个标签对应一个镜像&lt;/p&gt;&#xA;&lt;p&gt;可以通过&lt;code&gt;&amp;lt;Repository Name&amp;gt;:&amp;lt;Tag Name&amp;gt;&lt;/code&gt; 的格式来指定具体的软件是那个版本的镜像&lt;/p&gt;&#xA;&lt;p&gt;仓库名以两段路径形式出现，比如&lt;code&gt;jwilder/nginx-proxy&lt;/code&gt; 前者是Docker Registry多用户环境下的用户名，后者是对应的软件名&lt;/p&gt;&#xA;&lt;h3 id=&#34;docker-registry-公开服务&#34;&gt;Docker Registry 公开服务&lt;/h3&gt;&#xA;&lt;p&gt;Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。&lt;/p&gt;&#xA;&lt;p&gt;最常见的是Docker Registry公开服务是官方的&lt;a href=&#34;https://hub.docker.com/&#34;&gt;hub.docker.com&lt;/a&gt;，也是默认的Registry&lt;/p&gt;&#xA;&lt;p&gt;也可以使用国内的镜像网站&lt;/p&gt;&#xA;&lt;h3 id=&#34;私有docker-registry&#34;&gt;私有Docker Registry&lt;/h3&gt;&#xA;&lt;p&gt;用户可以在本地搭建私有的Docker Registry。Docker提供了Docker Registry镜像，可以直接使用搭建私有Registry服务&lt;/p&gt;&#xA;&lt;h2 id=&#34;二镜像&#34;&gt;二、镜像&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1获取镜像&#34;&gt;1.获取镜像&lt;/h3&gt;&#xA;&lt;p&gt;从Docker镜像仓库获取镜像的命令是 &lt;code&gt;docker pull&lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker pull &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;选项&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;Docker Registry 地址&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;:端口号&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;/&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; 仓库名&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;:标签&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体选项可以从&lt;code&gt;docker pull --help&lt;/code&gt; 命令查看，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Docker镜像仓库地址：地址格式一般为 &lt;code&gt;&amp;lt;域名/IP&amp;gt;[:端口号]&lt;/code&gt;。默认地址是 Docker Hub&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;仓库名：仓库名是两段式，即&lt;code&gt;&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;&lt;/code&gt;.对于Docker Hub，如果不给出用户名，默认为 &lt;code&gt;library&lt;/code&gt;，也就是官方镜像&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker pull ubuntu:18.04&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面命令没有给出Docker镜像仓库地址，默认从&lt;code&gt;Docker Hub&lt;/code&gt;获取镜像。而镜像名称是&lt;code&gt;ubuntun:18.04&lt;/code&gt;,因此会获取官方镜像 &lt;code&gt;library/ubuntun&lt;/code&gt;仓库中标签为&lt;code&gt;18.04&lt;/code&gt;的镜像&lt;/p&gt;</description>
    </item>
    <item>
      <title>docker-部署</title>
      <link>https://ahang7.github.io/post/basic/docker/docker%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/docker/docker%E9%83%A8%E7%BD%B2/</guid>
      <description>&lt;p&gt;使用Docker 以及Docker Compose部署Go程序&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要docker&#34;&gt;为什么需要docker&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用docker的主要目标是其容器化。可以为应用程序提供一致的环境，而不依赖它运行的主机&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;部署示例&#34;&gt;部署示例&lt;/h3&gt;&#xA;&lt;h4 id=&#34;1准备代码&#34;&gt;1.准备代码&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Plaintext&#34; data-lang=&#34;Plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;package main&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;import (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &amp;#34;fmt&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &amp;#34;net/http&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func main() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        http.HandleFunc(&amp;#34;/&amp;#34;, hello)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        server := &amp;amp;http.Server{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                Addr: &amp;#34;:8888&amp;#34;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  fmt.Println(&amp;#34;server startup...&amp;#34;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if err := server.ListenAndServe(); err != nil {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                fmt.Printf(&amp;#34;server startup failed, err:%v\n&amp;#34;, err)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func hello(w http.ResponseWriter, _ *http.Request) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        w.Write([]byte(&amp;#34;hello liwenzhou.com!&amp;#34;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里是简单代码&lt;/p&gt;&#xA;&lt;h4 id=&#34;2创建docker镜像&#34;&gt;2.创建Docker镜像&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;镜像(image)包含运行应用程序所需的所有东西——代码/二进制文件、运行时、依赖项以及所需的任何其它人间系统对象&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;简单讲，镜像是定义应用程序以及运行所需的一切&lt;/p&gt;&#xA;&lt;h4 id=&#34;3编写dockerfile&#34;&gt;3.编写Dockerfile&lt;/h4&gt;&#xA;&lt;p&gt;要创建Docker镜像(image)必须在配置文件中的指定步骤，这个文件默认称为&lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>dockerfile-学习</title>
      <link>https://ahang7.github.io/post/basic/docker/dockerfile%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/docker/dockerfile%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;p&gt;学习自&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/7179042892395053113&#34;&gt;一篇文章带你吃透 Dockerfile - 掘金 (juejin.cn)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;Dockerfile reference&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/7042663735156015140&#34;&gt;全网最详细的Docker-Compose详细教程 - 掘金 (juejin.cn)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/387840381&#34;&gt;docker compose 配置文件 .yml 全面指南 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/compose-spec/compose-spec/blob/master/spec.md&#34;&gt;compose-spec/spec.md at master · compose-spec/compose-spec · GitHub&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;学习Dockers前期，通过Docker的官方镜像仓库拉取里面的镜像，根据这些镜像创建出容器并运行&lt;/p&gt;&#xA;&lt;p&gt;实际上，Docker官方镜像也是通过一定的方式构建出来的，只要弄清其中的逻辑，我们也可以仿照官方镜像的构建过程，构建出自己的镜像&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;就是这样一个用于描述Docker镜像构建过程的文本文件，dockerfile可以包含多条构建指令，以及相关的描述&lt;/p&gt;&#xA;&lt;h3 id=&#34;1什么是容器&#34;&gt;1.什么是容器&lt;/h3&gt;&#xA;&lt;p&gt;容器是计算机上的沙盒进程，与主机上的其它进程隔离，这种隔离利用了&lt;code&gt;内核命名空间和cgroups&lt;/code&gt;。简而言之容器是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;是&lt;code&gt;image&lt;/code&gt;的可运行实例&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以在本地计算机、虚拟机上运行或部署到云中&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;是可移植的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;与其它容器隔离，并运行自己的软件，二进制文件和配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2什么是容器映射&#34;&gt;2.什么是容器映射&lt;/h3&gt;&#xA;&lt;p&gt;当容器运行时，它使用了隔离的文件系统。这个自定义的文件系统由容器映像&lt;code&gt;container image&lt;/code&gt;提供。因为image包含了容器的问价系统，使用image必须包含所有的运行应用程序所必须的所有东西——依赖项、配置、脚本、二进制文件等等。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;沙盒进程是指在计算机系统中，为了保障安全和隔离性而采用的一种技术，将应用程序运行在一个受限制的环境中，限制它们能访问的资源和操作范围，从而避免恶意程序和授权程序对系统的破坏&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;3容器是怎么运行的&#34;&gt;3.容器是怎么运行的&lt;/h3&gt;&#xA;&lt;p&gt;当一个容器运行时，它为其文件系统使用来image的各个层。每个容器都有自己的命名空间来创建/更新/删除文件。在另一个容器中不会看到任何更改，即使它们使用相同的image&lt;/p&gt;&#xA;&lt;h3 id=&#34;4容器卷container-volumes&#34;&gt;4.容器卷[container volumes]&lt;/h3&gt;&#xA;&lt;p&gt;每个容器启动时都是从容器的定义开始的。在容器中可以创建、更新和删除文件，但当容器被删除时，这些改变将回丢失，所有更变都被隔离在各个容器中&lt;/p&gt;&#xA;&lt;p&gt;卷：提供了将容器的特定文件系统路径链路到主机的能力。如果在主机上的某个文件被挂载，那么当容器中该文件路径下的文件发送更改时，我们在主机上同样也可以看到更改。同样的，启动另一个挂载了同一个文件目录的容器，它也可以访问到相同的文件&lt;/p&gt;&#xA;&lt;h2 id=&#34;镜像构建原理&#34;&gt;镜像构建原理&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1docker架构模式&#34;&gt;1.Docker架构模式&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNkMzZjNzQ1MTljOTE0ZThhNjliYjMwODFiMjQ0NTJfSVlseWZldFNjR0l6QVpDbzFMdmNhYXg1TWRZb1oxUjZfVG9rZW46RjhBeWJoWkZpb2ZZbll4WEd2dGN3RXJHbkxoXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;使用了&lt;strong&gt;client&lt;/strong&gt;/&lt;strong&gt;server&lt;/strong&gt;的架构模式。构建镜像时，用户在&lt;strong&gt;dockers&lt;/strong&gt; &lt;strong&gt;client&lt;/strong&gt;输入构建命令。&lt;strong&gt;docker&lt;/strong&gt;引擎以 &lt;code&gt;REST API&lt;/code&gt;的形式，像 &lt;strong&gt;docker&lt;/strong&gt; &lt;strong&gt;daemon&lt;/strong&gt;发送构建请求，如何dockers daemon就根据构建请求的内容，开始镜像构建的工作，并向Client持续放回构建过程的信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2镜像分层模型&#34;&gt;2.镜像分层模型&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;docker&lt;/strong&gt;镜像是用于创建容器的只读模板，是通过 &lt;strong&gt;Dockerfile&lt;/strong&gt;中定义的指令构建而成的，构建结束后，会在原有的镜像层上生成一个新的镜像层，如下所示&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE5Yjk1OTNiMTc0MDI5YmU0NGZiNTNjZDU4NDQ5MDFfZmlPNWJYSnRaQ0RUSnJZNXpGSmN0anNFN1V6WGw4VkRfVG9rZW46RU9scmI4N0Jrb2RQVHJ4cVJFM2NwNlNtblBkXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在 tomcat 镜像创建一个容器后，会在tomcat镜像之上新创建一个可写的容器层，在容器中写文件时，会保存到这个容器层中&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MWU3YzUzYTM5OTE3NmZkZmEyNjhiYjZhYjljZTFiOTZfaTY2T1RORTY0UEVXWVJ0cnZ4RGxnSVE2ZGE0QWtsVlVfVG9rZW46Vk5McWI1RVV1b2h5WFV4aHBPM2NrcTNRbnVnXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;3基础镜像与父级镜像&#34;&gt;3.基础镜像与父级镜像&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;用于构建基础镜像的 &lt;strong&gt;Dockerfile&lt;/strong&gt; 不指定父级镜像，Docker约定使用如下形式基础镜像&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 &lt;code&gt;scratch&lt;/code&gt;是一个空镜像，可以从零开始构建镜像，常用来构建最小镜像，如&lt;code&gt;busybox&lt;/code&gt;，&lt;code&gt;debian&lt;/code&gt;，&lt;code&gt;alpine&lt;/code&gt;等镜像，省去很多linux命令，因此很小。一般，不需要自己去构建基础镜像。&lt;/p&gt;</description>
    </item>
    <item>
      <title>vscode.keyMap</title>
      <link>https://ahang7.github.io/post/tools/vscode/vscode.keymap/</link>
      <pubDate>Fri, 06 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/tools/vscode/vscode.keymap/</guid>
      <description>&lt;h3 id=&#34;常用-general&#34;&gt;常用 General&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + P，F1&lt;/td&gt;&#xA;          &lt;td&gt;显示命令面板 Show Command Palette&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + P&lt;/td&gt;&#xA;          &lt;td&gt;快速打开 Quick Open&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + N&lt;/td&gt;&#xA;          &lt;td&gt;新窗口/实例 New window/instance&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + W&lt;/td&gt;&#xA;          &lt;td&gt;关闭窗口/实例 Close window/instance&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + ,&lt;/td&gt;&#xA;          &lt;td&gt;用户设置 User Settings&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + S&lt;/td&gt;&#xA;          &lt;td&gt;设置键盘快捷方式 Keyboard Shortcuts&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;基础编辑-basic-editing&#34;&gt;基础编辑 Basic editing&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + X&lt;/td&gt;&#xA;          &lt;td&gt;剪切行（空选定） Cut line (empty selection)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + C&lt;/td&gt;&#xA;          &lt;td&gt;复制行（空选定）Copy line (empty selection)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + ↑ / ↓&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下移动行 Move line up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + ↓ / ↑&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下复制行 Copy line up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + K&lt;/td&gt;&#xA;          &lt;td&gt;删除行 Delete line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Enter&lt;/td&gt;&#xA;          &lt;td&gt;在下面插入行 Insert line below&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Enter&lt;/td&gt;&#xA;          &lt;td&gt;在上面插入行 Insert line above&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + |&lt;/td&gt;&#xA;          &lt;td&gt;跳到匹配的括号 Jump to matching bracket&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + ] / [&lt;/td&gt;&#xA;          &lt;td&gt;缩进/缩进行 Indent/outdent line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Home&lt;/td&gt;&#xA;          &lt;td&gt;转到行首 Go to beginning of line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;End&lt;/td&gt;&#xA;          &lt;td&gt;转到行尾 Go to end of line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Home&lt;/td&gt;&#xA;          &lt;td&gt;转到文件开头 Go to beginning of file&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + End&lt;/td&gt;&#xA;          &lt;td&gt;转到文件末尾 Go to end of file&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + ↑ / ↓&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下滚动行 Scroll line up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + PgUp / PgDown&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下滚动页面 Scroll page up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + [&lt;/td&gt;&#xA;          &lt;td&gt;折叠（折叠）区域 Fold (collapse) region&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + ]&lt;/td&gt;&#xA;          &lt;td&gt;展开（未折叠）区域 Unfold (uncollapse) region&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + [&lt;/td&gt;&#xA;          &lt;td&gt;折叠（未折叠）所有子区域 Fold (collapse) all subregions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + ]&lt;/td&gt;&#xA;          &lt;td&gt;展开（未折叠）所有子区域 Unfold (uncollapse) all subregions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + 0&lt;/td&gt;&#xA;          &lt;td&gt;折叠（折叠）所有区域 Fold (collapse) all regions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + J&lt;/td&gt;&#xA;          &lt;td&gt;展开（未折叠）所有区域 Unfold (uncollapse) all regions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + C&lt;/td&gt;&#xA;          &lt;td&gt;添加行注释 Add line comment&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + U&lt;/td&gt;&#xA;          &lt;td&gt;删除行注释 Remove line comment&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + /&lt;/td&gt;&#xA;          &lt;td&gt;切换行注释 Toggle line comment&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + A&lt;/td&gt;&#xA;          &lt;td&gt;切换块注释 Toggle block comment&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + Z&lt;/td&gt;&#xA;          &lt;td&gt;切换换行 Toggle word wrap&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;导航-navigation&#34;&gt;导航 Navigation&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + T&lt;/td&gt;&#xA;          &lt;td&gt;显示所有符号 Show all Symbols&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + G&lt;/td&gt;&#xA;          &lt;td&gt;转到行&amp;hellip; Go to Line&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + P&lt;/td&gt;&#xA;          &lt;td&gt;转到文件&amp;hellip; Go to File&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + O&lt;/td&gt;&#xA;          &lt;td&gt;转到符号&amp;hellip; Go to Symbol&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + M&lt;/td&gt;&#xA;          &lt;td&gt;显示问题面板 Show Problems panel&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F8&lt;/td&gt;&#xA;          &lt;td&gt;转到下一个错误或警告 Go to next error or warning&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + F8&lt;/td&gt;&#xA;          &lt;td&gt;转到上一个错误或警告 Go to previous error or warning&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Tab&lt;/td&gt;&#xA;          &lt;td&gt;导航编辑器组历史记录 Navigate editor group history&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + ← / →&lt;/td&gt;&#xA;          &lt;td&gt;返回/前进 Go back / forward&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + M&lt;/td&gt;&#xA;          &lt;td&gt;切换选项卡移动焦点 Toggle Tab moves focus&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;搜索和替换-search-and-replace&#34;&gt;搜索和替换 Search and replace&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + F&lt;/td&gt;&#xA;          &lt;td&gt;查找 Find&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + H&lt;/td&gt;&#xA;          &lt;td&gt;替换 Replace&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F3 / Shift + F3&lt;/td&gt;&#xA;          &lt;td&gt;查找下一个/上一个 Find next/previous&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + Enter&lt;/td&gt;&#xA;          &lt;td&gt;选择查找匹配的所有出现 Select all occurences of Find match&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + D&lt;/td&gt;&#xA;          &lt;td&gt;将选择添加到下一个查找匹配 Add selection to next Find match&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + D&lt;/td&gt;&#xA;          &lt;td&gt;将最后一个选择移至下一个查找匹配项 Move last selection to next Find match&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + C / R / W&lt;/td&gt;&#xA;          &lt;td&gt;切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;多光标和选择-multi-cursor-and-selection&#34;&gt;多光标和选择 Multi-cursor and selection&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt +单击&lt;/td&gt;&#xA;          &lt;td&gt;插入光标 Insert cursor&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Alt +↑/↓&lt;/td&gt;&#xA;          &lt;td&gt;在上/下插入光标 Insert cursor above / below&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + U&lt;/td&gt;&#xA;          &lt;td&gt;撤消上一个光标操作 Undo last cursor operation&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + I&lt;/td&gt;&#xA;          &lt;td&gt;在选定的每一行的末尾插入光标 Insert cursor at end of each line selected&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + L&lt;/td&gt;&#xA;          &lt;td&gt;选择当前行 Select current line&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + L&lt;/td&gt;&#xA;          &lt;td&gt;选择当前选择的所有出现 Select all occurrences of current selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + F2&lt;/td&gt;&#xA;          &lt;td&gt;选择当前字的所有出现 Select all occurrences of current word&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + →&lt;/td&gt;&#xA;          &lt;td&gt;展开选择 Expand selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + ←&lt;/td&gt;&#xA;          &lt;td&gt;缩小选择 Shrink selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + （拖动鼠标）&lt;/td&gt;&#xA;          &lt;td&gt;列（框）选择 Column (box) selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Alt +（箭头键）&lt;/td&gt;&#xA;          &lt;td&gt;列（框）选择 Column (box) selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Alt + PgUp / PgDown&lt;/td&gt;&#xA;          &lt;td&gt;列（框）选择页上/下 Column (box) selection page up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;丰富的语言编辑-rich-languages-editing&#34;&gt;丰富的语言编辑 Rich languages editing&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + 空格&lt;/td&gt;&#xA;          &lt;td&gt;触发建议 Trigger suggestion&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Space&lt;/td&gt;&#xA;          &lt;td&gt;触发器参数提示 Trigger parameter hints&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + F&lt;/td&gt;&#xA;          &lt;td&gt;格式化文档 Format document&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + F&lt;/td&gt;&#xA;          &lt;td&gt;格式选定区域 Format selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F12&lt;/td&gt;&#xA;          &lt;td&gt;转到定义 Go to Definition&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Alt + F12&lt;/td&gt;&#xA;          &lt;td&gt;Peek定义 Peek Definition&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K F12&lt;/td&gt;&#xA;          &lt;td&gt;打开定义到边 Open Definition to the side&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + .&lt;/td&gt;&#xA;          &lt;td&gt;快速解决 Quick Fix&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + F12&lt;/td&gt;&#xA;          &lt;td&gt;显示引用 Show References&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F2&lt;/td&gt;&#xA;          &lt;td&gt;重命名符号 Rename Symbol&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + X&lt;/td&gt;&#xA;          &lt;td&gt;修剪尾随空格 Trim trailing whitespace&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K M&lt;/td&gt;&#xA;          &lt;td&gt;更改文件语言 Change file language&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;编辑器管理-editor-management&#34;&gt;编辑器管理 Editor management&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + F4, Ctrl + W&lt;/td&gt;&#xA;          &lt;td&gt;关闭编辑器 Close editor&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K F&lt;/td&gt;&#xA;          &lt;td&gt;关闭文件夹 Close folder&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + |&lt;/td&gt;&#xA;          &lt;td&gt;拆分编辑器 Split editor&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + 1 / 2 / 3&lt;/td&gt;&#xA;          &lt;td&gt;聚焦到第 1，第 2 或第 3 编辑器组 Focus into 1st, 2nd or 3rd editor group&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + ← / →&lt;/td&gt;&#xA;          &lt;td&gt;聚焦到上一个/下一个编辑器组 Focus into previous/next editor group&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + PgUp / PgDown&lt;/td&gt;&#xA;          &lt;td&gt;向左/向右移动编辑器 Move editor left/right&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K ← / →&lt;/td&gt;&#xA;          &lt;td&gt;移动活动编辑器组 Move active editor group&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;文件管理-file-management&#34;&gt;文件管理 File management&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + N&lt;/td&gt;&#xA;          &lt;td&gt;新文件 New File&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + O&lt;/td&gt;&#xA;          &lt;td&gt;打开文件&amp;hellip; Open File&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + S&lt;/td&gt;&#xA;          &lt;td&gt;保存 Save&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + S&lt;/td&gt;&#xA;          &lt;td&gt;另存为&amp;hellip; Save As&amp;hellip;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K S&lt;/td&gt;&#xA;          &lt;td&gt;全部保存 Save All&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + F4&lt;/td&gt;&#xA;          &lt;td&gt;关闭 Close&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + W&lt;/td&gt;&#xA;          &lt;td&gt;关闭所有 Close All&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + T&lt;/td&gt;&#xA;          &lt;td&gt;重新打开关闭的编辑器 Reopen closed editor&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Enter&lt;/td&gt;&#xA;          &lt;td&gt;输入保持打开 Enter Keep Open&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Tab&lt;/td&gt;&#xA;          &lt;td&gt;打开下一个 Open next&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + Tab&lt;/td&gt;&#xA;          &lt;td&gt;打开上一个 Open previous&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K P&lt;/td&gt;&#xA;          &lt;td&gt;复制活动文件的路径 Copy path of active file&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K R&lt;/td&gt;&#xA;          &lt;td&gt;显示资源管理器中的活动文件 Reveal active file in Explorer&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K O&lt;/td&gt;&#xA;          &lt;td&gt;显示新窗口/实例中的活动文件 Show active file in new window/instance&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;显示-display&#34;&gt;显示 Display&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F11&lt;/td&gt;&#xA;          &lt;td&gt;切换全屏 Toggle full screen&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + Alt + 0&lt;/td&gt;&#xA;          &lt;td&gt;切换编辑器布局 Toggle editor layout&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + = / -&lt;/td&gt;&#xA;          &lt;td&gt;放大/缩小 Zoom in/out&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + B&lt;/td&gt;&#xA;          &lt;td&gt;切换侧栏可见性 Toggle Sidebar visibility&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + E&lt;/td&gt;&#xA;          &lt;td&gt;显示浏览器/切换焦点 Show Explorer / Toggle focus&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + F&lt;/td&gt;&#xA;          &lt;td&gt;显示搜索 Show Search&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + G&lt;/td&gt;&#xA;          &lt;td&gt;显示 Git Show Git&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + D&lt;/td&gt;&#xA;          &lt;td&gt;显示调试 Show Debug&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + X&lt;/td&gt;&#xA;          &lt;td&gt;显示扩展 Show Extensions&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + H&lt;/td&gt;&#xA;          &lt;td&gt;替换文件 Replace in files&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + J&lt;/td&gt;&#xA;          &lt;td&gt;切换搜索详细信息 Toggle Search details&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + C&lt;/td&gt;&#xA;          &lt;td&gt;打开新命令提示符/终端 Open new command prompt/terminal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift +U&lt;/td&gt;&#xA;          &lt;td&gt;显示输出面板 Show Output panel&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + V&lt;/td&gt;&#xA;          &lt;td&gt;切换 Markdown 预览 Toggle Markdown preview&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K V&lt;/td&gt;&#xA;          &lt;td&gt;从旁边打开 Markdown 预览 Open Markdown preview to the side&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Z&lt;/td&gt;&#xA;          &lt;td&gt;打开禅模式（ Esc 键退出） Zen Mode (Esc Esc to ecit)&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;调试-debug&#34;&gt;调试 Debug&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F9&lt;/td&gt;&#xA;          &lt;td&gt;切换断点 Toggle breakpoint&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F5&lt;/td&gt;&#xA;          &lt;td&gt;开始/继续 Start/Continue&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + F5&lt;/td&gt;&#xA;          &lt;td&gt;停止 Stop&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F11 / Shift + F11&lt;/td&gt;&#xA;          &lt;td&gt;下一步/上一步 Step into/out&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;F10&lt;/td&gt;&#xA;          &lt;td&gt;跳过 Step over&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + K Ctrl + I&lt;/td&gt;&#xA;          &lt;td&gt;显示悬停 Show hover&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;集成终端-integrated-terminal&#34;&gt;集成终端 Integrated terminal&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;按 Press&lt;/th&gt;&#xA;          &lt;th&gt;功能 Function&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + `&lt;/td&gt;&#xA;          &lt;td&gt;显示集成终端 Show integrated terminal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Shift + `&lt;/td&gt;&#xA;          &lt;td&gt;创建新终端 Create new terminal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + C&lt;/td&gt;&#xA;          &lt;td&gt;复制选定 Copy selection&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + V&lt;/td&gt;&#xA;          &lt;td&gt;粘贴到活动端子 Paste into active terminal&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + ↑ / ↓&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下滚动 Scroll up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Shift + PgUp / PgDown&lt;/td&gt;&#xA;          &lt;td&gt;向上/向下滚动页面 Scroll page up/down&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;Ctrl + Home / End&lt;/td&gt;&#xA;          &lt;td&gt;滚动到顶部/底部 Scroll to top/bottom&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;</description>
    </item>
    <item>
      <title>Linux 下编译安装Protobuf</title>
      <link>https://ahang7.github.io/post/tools/installx/protoc/linux.install/</link>
      <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/tools/installx/protoc/linux.install/</guid>
      <description>&lt;p&gt;以Ubuntu22.04为例，使用CMake从源码安装Protobuf v3.25.4&lt;/p&gt;&#xA;&lt;p&gt;前期准备：&lt;/p&gt;&#xA;&lt;p&gt;首先安装&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install -y gcc g++ cmake git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;cmake 版本高于 3.15&lt;/p&gt;&#xA;&lt;p&gt;Ubuntu的官方源没有提供abseil安装包，需要手动安装&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/abseil/abseil-cpp.git  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; abseil-cpp  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir build &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; build  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake -DABSL_BUILD_TESTING&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ON -DABSL_USE_GOOGLETEST_HEAD&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ON -DCMAKE_CXX_STANDARD&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;14&lt;/span&gt; ..  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ldconfig&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开始安装&lt;code&gt;protobuf&lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone -b v3.23.2 https://github.com/protocolbuffers/protobuf.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; protobuf  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git submodule update --init --recursive&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake .  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install .  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ldconfig &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>todo list</title>
      <link>https://ahang7.github.io/post/todo.list/</link>
      <pubDate>Tue, 06 Jul 2021 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/todo.list/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-iam&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-bitDB&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-distributedFS&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-asyncflow&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-timker&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-flashSale&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-pay&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-tcpZinx&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-anyX&lt;/li&gt;&#xA;&lt;li&gt;&lt;input disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; go-rpc&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/post/basic/git/git-commands/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/git/git-commands/</guid>
      <description></description>
    </item>
    <item>
      <title></title>
      <link>https://ahang7.github.io/post/basic/golang/%E5%B9%B6%E5%8F%91%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/golang/%E5%B9%B6%E5%8F%91%E6%A6%82%E5%BF%B5/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;&#xA;&lt;!-- raw HTML omitted --&gt;</description>
    </item>
  </channel>
</rss>
