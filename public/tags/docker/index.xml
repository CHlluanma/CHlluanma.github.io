<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on Beautiful Hugo</title>
    <link>https://ahang7.github.io/tags/docker/</link>
    <description>Recent content in Docker on Beautiful Hugo</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>ch1447571882@qq.com (ch)</managingEditor>
    <webMaster>ch1447571882@qq.com (ch)</webMaster>
    <lastBuildDate>Sat, 28 Sep 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ahang7.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>docker-基础</title>
      <link>https://ahang7.github.io/post/basic/docker/docker/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/docker/docker/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://yeasy.gitbook.io/docker_practice/&#34;&gt;https://yeasy.gitbook.io/docker_practice/&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;一基本概念&#34;&gt;一、基本概念&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;镜像(&lt;code&gt;Image&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;容器(&lt;code&gt;Container&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;li&gt;仓库(&lt;code&gt;Repository&lt;/code&gt;)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;理解以上三个概念，就能理解docker的生命周期&lt;/p&gt;&#xA;&lt;h3 id=&#34;1镜像&#34;&gt;1.镜像&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;Docker镜像&lt;/strong&gt;是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件，以及一些运行时所需的配置参数。镜像不包含任何动态数据，其内容在插件之后也不会被改变&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;分层存储&lt;/strong&gt;，镜像采用了分层存储的架构，由一组文件系统组成的（多层文件系统联合组成）。在构建镜像时，会一层一层构建，后一层依赖于上一层，后一层上的任何改变都只会发生在本层，不会干涉到上一层。因此构建镜像的时候，需要对每层需要添加的东西尽量加最少最有必要的东西，减少额外的东西&lt;/p&gt;&#xA;&lt;p&gt;分层存储的特征还使得&lt;strong&gt;镜像的复用，定制&lt;/strong&gt;更为容易&lt;/p&gt;&#xA;&lt;h3 id=&#34;2容器&#34;&gt;2.容器&lt;/h3&gt;&#xA;&lt;p&gt;容器是镜像运行时的实体，可以被创建、启动、停止、删除暂停等&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;镜像(Image)和容器(container)的关系，就像是面向对象程序设计中的&lt;code&gt;类&lt;/code&gt; 和&lt;code&gt;实例&lt;/code&gt; 一样&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;容器的实质是进程，运行于属于自己的独立的命名空间。因此容器可以拥有自己的&lt;code&gt;root&lt;/code&gt; 文件系统，网络配置、进程空间等，运行在一个隔离的环境。这样的隔离特性，使得容器封装的应用比直接在宿主运行更加安全&lt;/p&gt;&#xA;&lt;p&gt;容器也是分层存储，是&lt;strong&gt;以镜像为基础层&lt;/strong&gt;，在其上创建一个当前容器的存储层，这个层是为容器运行时进行读写而准备的，称为&lt;strong&gt;容器存储层&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;容器存储层的生命周期跟容器一样，当容器消亡时，容器存储层也随之消亡，因此任何保存于容器存储层的信息都会随着容器的删除而丢失&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Dokcer最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层保存无状态化，所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录&lt;/p&gt;&#xA;&lt;p&gt;数据卷独立于容器，使用容器卷，容器的删除或者重写运行之后，数据都不会丢失&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;3仓库&#34;&gt;3.仓库&lt;/h3&gt;&#xA;&lt;p&gt;Docker Register：提供一个集中的存储、分发镜像的服务&lt;/p&gt;&#xA;&lt;p&gt;一个&lt;strong&gt;Docker Register&lt;/strong&gt;可以包含多个**仓库（&lt;strong&gt;&lt;strong&gt;Repository&lt;/strong&gt;&lt;/strong&gt;）;&lt;strong&gt;每个仓库可以包含多个&lt;/strong&gt;标签（Tag）,**每个标签对应一个镜像&lt;/p&gt;&#xA;&lt;p&gt;可以通过&lt;code&gt;&amp;lt;Repository Name&amp;gt;:&amp;lt;Tag Name&amp;gt;&lt;/code&gt; 的格式来指定具体的软件是那个版本的镜像&lt;/p&gt;&#xA;&lt;p&gt;仓库名以两段路径形式出现，比如&lt;code&gt;jwilder/nginx-proxy&lt;/code&gt; 前者是Docker Registry多用户环境下的用户名，后者是对应的软件名&lt;/p&gt;&#xA;&lt;h3 id=&#34;docker-registry-公开服务&#34;&gt;Docker Registry 公开服务&lt;/h3&gt;&#xA;&lt;p&gt;Docker Registry公开服务是开放给用户使用、允许用户管理镜像的Registry服务。&lt;/p&gt;&#xA;&lt;p&gt;最常见的是Docker Registry公开服务是官方的&lt;a href=&#34;https://hub.docker.com/&#34;&gt;hub.docker.com&lt;/a&gt;，也是默认的Registry&lt;/p&gt;&#xA;&lt;p&gt;也可以使用国内的镜像网站&lt;/p&gt;&#xA;&lt;h3 id=&#34;私有docker-registry&#34;&gt;私有Docker Registry&lt;/h3&gt;&#xA;&lt;p&gt;用户可以在本地搭建私有的Docker Registry。Docker提供了Docker Registry镜像，可以直接使用搭建私有Registry服务&lt;/p&gt;&#xA;&lt;h2 id=&#34;二镜像&#34;&gt;二、镜像&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1获取镜像&#34;&gt;1.获取镜像&lt;/h3&gt;&#xA;&lt;p&gt;从Docker镜像仓库获取镜像的命令是 &lt;code&gt;docker pull&lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;docker pull &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;选项&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;Docker Registry 地址&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;:端口号&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;/&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; 仓库名&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;:标签&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体选项可以从&lt;code&gt;docker pull --help&lt;/code&gt; 命令查看，&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Docker镜像仓库地址：地址格式一般为 &lt;code&gt;&amp;lt;域名/IP&amp;gt;[:端口号]&lt;/code&gt;。默认地址是 Docker Hub&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;仓库名：仓库名是两段式，即&lt;code&gt;&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;&lt;/code&gt;.对于Docker Hub，如果不给出用户名，默认为 &lt;code&gt;library&lt;/code&gt;，也就是官方镜像&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Bash&#34; data-lang=&#34;Bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ docker pull ubuntu:18.04&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面命令没有给出Docker镜像仓库地址，默认从&lt;code&gt;Docker Hub&lt;/code&gt;获取镜像。而镜像名称是&lt;code&gt;ubuntun:18.04&lt;/code&gt;,因此会获取官方镜像 &lt;code&gt;library/ubuntun&lt;/code&gt;仓库中标签为&lt;code&gt;18.04&lt;/code&gt;的镜像&lt;/p&gt;</description>
    </item>
    <item>
      <title>docker-部署</title>
      <link>https://ahang7.github.io/post/basic/docker/docker%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/docker/docker%E9%83%A8%E7%BD%B2/</guid>
      <description>&lt;p&gt;使用Docker 以及Docker Compose部署Go程序&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要docker&#34;&gt;为什么需要docker&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;使用docker的主要目标是其容器化。可以为应用程序提供一致的环境，而不依赖它运行的主机&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;部署示例&#34;&gt;部署示例&lt;/h3&gt;&#xA;&lt;h4 id=&#34;1准备代码&#34;&gt;1.准备代码&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Plaintext&#34; data-lang=&#34;Plaintext&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;package main&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;import (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &amp;#34;fmt&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &amp;#34;net/http&amp;#34;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func main() {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        http.HandleFunc(&amp;#34;/&amp;#34;, hello)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        server := &amp;amp;http.Server{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                Addr: &amp;#34;:8888&amp;#34;,&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  fmt.Println(&amp;#34;server startup...&amp;#34;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if err := server.ListenAndServe(); err != nil {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                fmt.Printf(&amp;#34;server startup failed, err:%v\n&amp;#34;, err)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;func hello(w http.ResponseWriter, _ *http.Request) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        w.Write([]byte(&amp;#34;hello liwenzhou.com!&amp;#34;))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里是简单代码&lt;/p&gt;&#xA;&lt;h4 id=&#34;2创建docker镜像&#34;&gt;2.创建Docker镜像&lt;/h4&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;镜像(image)包含运行应用程序所需的所有东西——代码/二进制文件、运行时、依赖项以及所需的任何其它人间系统对象&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;简单讲，镜像是定义应用程序以及运行所需的一切&lt;/p&gt;&#xA;&lt;h4 id=&#34;3编写dockerfile&#34;&gt;3.编写Dockerfile&lt;/h4&gt;&#xA;&lt;p&gt;要创建Docker镜像(image)必须在配置文件中的指定步骤，这个文件默认称为&lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>dockerfile-学习</title>
      <link>https://ahang7.github.io/post/basic/docker/dockerfile%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/basic/docker/dockerfile%E5%AD%A6%E4%B9%A0/</guid>
      <description>&lt;p&gt;学习自&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/7179042892395053113&#34;&gt;一篇文章带你吃透 Dockerfile - 掘金 (juejin.cn)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;Dockerfile reference&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://juejin.cn/post/7042663735156015140&#34;&gt;全网最详细的Docker-Compose详细教程 - 掘金 (juejin.cn)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/387840381&#34;&gt;docker compose 配置文件 .yml 全面指南 - 知乎 (zhihu.com)&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/compose-spec/compose-spec/blob/master/spec.md&#34;&gt;compose-spec/spec.md at master · compose-spec/compose-spec · GitHub&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;学习Dockers前期，通过Docker的官方镜像仓库拉取里面的镜像，根据这些镜像创建出容器并运行&lt;/p&gt;&#xA;&lt;p&gt;实际上，Docker官方镜像也是通过一定的方式构建出来的，只要弄清其中的逻辑，我们也可以仿照官方镜像的构建过程，构建出自己的镜像&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;就是这样一个用于描述Docker镜像构建过程的文本文件，dockerfile可以包含多条构建指令，以及相关的描述&lt;/p&gt;&#xA;&lt;h3 id=&#34;1什么是容器&#34;&gt;1.什么是容器&lt;/h3&gt;&#xA;&lt;p&gt;容器是计算机上的沙盒进程，与主机上的其它进程隔离，这种隔离利用了&lt;code&gt;内核命名空间和cgroups&lt;/code&gt;。简而言之容器是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;是&lt;code&gt;image&lt;/code&gt;的可运行实例&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;可以在本地计算机、虚拟机上运行或部署到云中&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;是可移植的&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;与其它容器隔离，并运行自己的软件，二进制文件和配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;2什么是容器映射&#34;&gt;2.什么是容器映射&lt;/h3&gt;&#xA;&lt;p&gt;当容器运行时，它使用了隔离的文件系统。这个自定义的文件系统由容器映像&lt;code&gt;container image&lt;/code&gt;提供。因为image包含了容器的问价系统，使用image必须包含所有的运行应用程序所必须的所有东西——依赖项、配置、脚本、二进制文件等等。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;沙盒进程是指在计算机系统中，为了保障安全和隔离性而采用的一种技术，将应用程序运行在一个受限制的环境中，限制它们能访问的资源和操作范围，从而避免恶意程序和授权程序对系统的破坏&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;3容器是怎么运行的&#34;&gt;3.容器是怎么运行的&lt;/h3&gt;&#xA;&lt;p&gt;当一个容器运行时，它为其文件系统使用来image的各个层。每个容器都有自己的命名空间来创建/更新/删除文件。在另一个容器中不会看到任何更改，即使它们使用相同的image&lt;/p&gt;&#xA;&lt;h3 id=&#34;4容器卷container-volumes&#34;&gt;4.容器卷[container volumes]&lt;/h3&gt;&#xA;&lt;p&gt;每个容器启动时都是从容器的定义开始的。在容器中可以创建、更新和删除文件，但当容器被删除时，这些改变将回丢失，所有更变都被隔离在各个容器中&lt;/p&gt;&#xA;&lt;p&gt;卷：提供了将容器的特定文件系统路径链路到主机的能力。如果在主机上的某个文件被挂载，那么当容器中该文件路径下的文件发送更改时，我们在主机上同样也可以看到更改。同样的，启动另一个挂载了同一个文件目录的容器，它也可以访问到相同的文件&lt;/p&gt;&#xA;&lt;h2 id=&#34;镜像构建原理&#34;&gt;镜像构建原理&lt;/h2&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;1docker架构模式&#34;&gt;1.Docker架构模式&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=ODNkMzZjNzQ1MTljOTE0ZThhNjliYjMwODFiMjQ0NTJfSVlseWZldFNjR0l6QVpDbzFMdmNhYXg1TWRZb1oxUjZfVG9rZW46RjhBeWJoWkZpb2ZZbll4WEd2dGN3RXJHbkxoXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;使用了&lt;strong&gt;client&lt;/strong&gt;/&lt;strong&gt;server&lt;/strong&gt;的架构模式。构建镜像时，用户在&lt;strong&gt;dockers&lt;/strong&gt; &lt;strong&gt;client&lt;/strong&gt;输入构建命令。&lt;strong&gt;docker&lt;/strong&gt;引擎以 &lt;code&gt;REST API&lt;/code&gt;的形式，像 &lt;strong&gt;docker&lt;/strong&gt; &lt;strong&gt;daemon&lt;/strong&gt;发送构建请求，如何dockers daemon就根据构建请求的内容，开始镜像构建的工作，并向Client持续放回构建过程的信息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;2镜像分层模型&#34;&gt;2.镜像分层模型&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;docker&lt;/strong&gt;镜像是用于创建容器的只读模板，是通过 &lt;strong&gt;Dockerfile&lt;/strong&gt;中定义的指令构建而成的，构建结束后，会在原有的镜像层上生成一个新的镜像层，如下所示&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE5Yjk1OTNiMTc0MDI5YmU0NGZiNTNjZDU4NDQ5MDFfZmlPNWJYSnRaQ0RUSnJZNXpGSmN0anNFN1V6WGw4VkRfVG9rZW46RU9scmI4N0Jrb2RQVHJ4cVJFM2NwNlNtblBkXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;在 tomcat 镜像创建一个容器后，会在tomcat镜像之上新创建一个可写的容器层，在容器中写文件时，会保存到这个容器层中&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://rt5bap83jl.feishu.cn/space/api/box/stream/download/asynccode/?code=MWU3YzUzYTM5OTE3NmZkZmEyNjhiYjZhYjljZTFiOTZfaTY2T1RORTY0UEVXWVJ0cnZ4RGxnSVE2ZGE0QWtsVlVfVG9rZW46Vk5McWI1RVV1b2h5WFV4aHBPM2NrcTNRbnVnXzE3MjE4NDA4ODE6MTcyMTg0NDQ4MV9WNA&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;3基础镜像与父级镜像&#34;&gt;3.基础镜像与父级镜像&lt;/h3&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;用于构建基础镜像的 &lt;strong&gt;Dockerfile&lt;/strong&gt; 不指定父级镜像，Docker约定使用如下形式基础镜像&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Dockerfile&#34; data-lang=&#34;Dockerfile&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;s&#34;&gt; scratch&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 &lt;code&gt;scratch&lt;/code&gt;是一个空镜像，可以从零开始构建镜像，常用来构建最小镜像，如&lt;code&gt;busybox&lt;/code&gt;，&lt;code&gt;debian&lt;/code&gt;，&lt;code&gt;alpine&lt;/code&gt;等镜像，省去很多linux命令，因此很小。一般，不需要自己去构建基础镜像。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
