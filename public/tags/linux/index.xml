<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on Beautiful Hugo</title>
    <link>https://ahang7.github.io/tags/linux/</link>
    <description>Recent content in Linux on Beautiful Hugo</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>ch1447571882@qq.com (ch)</managingEditor>
    <webMaster>ch1447571882@qq.com (ch)</webMaster>
    <lastBuildDate>Thu, 06 Apr 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ahang7.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux 下编译安装Protobuf</title>
      <link>https://ahang7.github.io/post/tools/installx/protoc/linux.install/</link>
      <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/post/tools/installx/protoc/linux.install/</guid>
      <description>&lt;p&gt;以Ubuntu22.04为例，使用CMake从源码安装Protobuf v3.25.4&lt;/p&gt;&#xA;&lt;p&gt;前期准备：&lt;/p&gt;&#xA;&lt;p&gt;首先安装&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo apt install -y gcc g++ cmake git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;cmake 版本高于 3.15&lt;/p&gt;&#xA;&lt;p&gt;Ubuntu的官方源没有提供abseil安装包，需要手动安装&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone https://github.com/abseil/abseil-cpp.git  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; abseil-cpp  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mkdir build &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; build  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake -DABSL_BUILD_TESTING&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ON -DABSL_USE_GOOGLETEST_HEAD&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;ON -DCMAKE_CXX_STANDARD&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;14&lt;/span&gt; ..  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ldconfig&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开始安装&lt;code&gt;protobuf&lt;/code&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone -b v3.23.2 https://github.com/protocolbuffers/protobuf.git &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; protobuf  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git submodule update --init --recursive&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;cmake .  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;make  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo make install .  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sudo ldconfig &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>mysql面试题</title>
      <link>https://ahang7.github.io/eightlessay/mysql/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Thu, 06 Apr 2023 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/eightlessay/mysql/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>&lt;h2 id=&#34;0-sql语法&#34;&gt;0. SQL语法&lt;/h2&gt;&#xA;&lt;h3 id=&#34;01-count主键和count非主键结果会不同吗&#34;&gt;0.1 count主键和count非主键结果会不同吗？&lt;/h3&gt;&#xA;&lt;p&gt;分析：count()函数是返回表中某个列的非NULL值数量&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主键不能存储NULL值，所以count(主键)返回的结果，可以表示数据库中所有行数据的量&lt;/li&gt;&#xA;&lt;li&gt;非主键可以保存NULL值，所以count(非主键)返回表中非主键列的非NULL值的数量&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;回答：&#xA;主键不能存NULL值，所以count主键代表统计表中所有行数据的数量&#xA;而非主键可以存储NULL值，所以count非主键返回的是表中这个列的非NULL值的数量&lt;/p&gt;&#xA;&lt;h2 id=&#34;一索引面试题&#34;&gt;一、索引面试题&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-mysql有哪些索引&#34;&gt;1.1 MySQL有哪些索引？&lt;/h3&gt;&#xA;&lt;p&gt;分析：索引是由存储引擎来实现的，不同存储引擎支持的索引类型也是不同的，大多数存储引擎都是支持&lt;/p&gt;&#xA;&lt;p&gt;B+树索引，哈希索引，全文索引的区别：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;B+树索引：InnoDB引擎默认的索引，支持排序，分组，模糊查询等，并且性能稳定&lt;/li&gt;&#xA;&lt;li&gt;哈希索引：多用于等值查询，时间复杂度为O(1)，效率非常高，但不支持排序，范围查询以及模糊查询&lt;/li&gt;&#xA;&lt;li&gt;全文索引：一般用于查询文本中的关键字，而不是直接比较是否相等等，主要用来解决 WHERE name LIKE &amp;ldquo;%aaaa%&amp;rdquo;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html&#34;&gt;dev.mysql.com&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;回答：我了解到Mysql支持B+树索引，哈希索引，全文索引这三种索引类型，比较常用的是B+树索引，因为它是InnoDB引擎默认使用的索引类型，支持排序，分组，范围查询，模糊查询等&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-innodb引擎的索引数据结构是什么&#34;&gt;1.2 InnoDB引擎的索引数据结构是什么？&lt;/h3&gt;&#xA;&lt;p&gt;回答：InnoDB引擎是采用B+树作为索引的数据结构&lt;/p&gt;&#xA;&lt;h3 id=&#34;130-mysql为什么使用b树&#34;&gt;1.3.0 mysql为什么使用B+树？&lt;/h3&gt;&#xA;&lt;p&gt;分析：这里要回答对平衡树、红黑树，跳表，B树等的对比&lt;/p&gt;&#xA;&lt;p&gt;回答：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;B+树是多叉树，平衡二叉树、红黑树是二叉树，在同等数据量下，平衡二叉树、红黑树高度更高，磁盘IO次数更多，性能更差，而且它们会频繁执行在平衡过程，来保证树形结构平衡&lt;/li&gt;&#xA;&lt;li&gt;和B+树相比，跳表在极端情况下会退化为链表，平衡性差，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存&lt;/li&gt;&#xA;&lt;li&gt;和B+树相比，B树的数据结构存储在全部节点，对范围查询不友好，非叶子节点存储了数据，导致内存中难以放下全部非叶子节点，如果内存放不下非叶子节点，那么意味着查询非叶子节点的时候都需要磁盘IO&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;学习：&lt;a href=&#34;https://leeshengis.com/archives/672553&#34;&gt;10｜数据库索引：为什么MySQL用B+树而不用B树？ | JUST DO IT&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;13-为什么索引用b树而不用红黑树&#34;&gt;1.3 为什么索引用B+树？而不用红黑树？&lt;/h3&gt;&#xA;&lt;p&gt;分析：InnoDB引擎的数据是存储在磁盘上的，所以选择数据结构的第一优先级是考虑从磁盘查询数据的成本，如果树的高度越高，意味着磁盘I/O就越多，这样会影响查询性能&lt;/p&gt;&#xA;&lt;p&gt;对于N个叶子节点的B+树，其搜索复杂度为&lt;code&gt;O(logdN)&lt;/code&gt; ，其中d表示节点允许的最大子节点个数为d&lt;/p&gt;&#xA;&lt;p&gt;在实际的应用中，即使数据达到了千万级别，B+树的高度依旧维持在3&lt;del&gt;4层，也就是说一次数据查询操作只需要做3&lt;/del&gt;4次的磁盘I/O操作&lt;/p&gt;&#xA;&lt;p&gt;而红黑树本质上是二叉树，二叉树的每个父节点的儿子节点只能是2个，意味着其搜索复杂度为&lt;code&gt;O(logN)&lt;/code&gt; ，这已经比B+Tree高出不少，因此二叉树搜索到目标数据所经历的磁盘I/O次数要更多&lt;/p&gt;&#xA;&lt;p&gt;回答：主要原因是随着数据量的增多，红黑树的树高会比B+树高 ，这样查询数据的时候会面临更多的磁盘I/O，查询性能没那么好。&lt;/p&gt;&#xA;&lt;p&gt;因为红黑树本质是二叉树，而b+树是多叉树，存储相同数量的数据量下，红黑树的树高会比B+树的树高，由于InnoDB引擎的数据都是存储在磁盘上的，如果树的高度过高，意味着磁盘I/O就越多，会影响到查询性能，所以InnoDB引擎的索引选择了B+树&lt;/p&gt;&#xA;&lt;h3 id=&#34;14-为什么索引用b树而不是b树&#34;&gt;1.4 为什么索引用B+树？而不是B树？&lt;/h3&gt;&#xA;&lt;p&gt;分析：考察对B+树 和 B 树的理解，可以从三个角度分析&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;磁盘I/O角度&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;范围查询角度&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;增删改查角度&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;回答：我觉得主要有三个原因：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;B+树的磁盘读写代价更低：B+树只有叶子节点存储索引和数据，非叶子节点只存放索引，而B树所有节点都会存放索引和数据，因此存储相同数据量的情况下，B+树可以比B树更矮胖，查询叶子节点的磁盘I/O次数也少&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;B+树便于范围查询：MySQL经常需要使用范围查询，B+树所有叶子节点间都有链表进行连接，这种设计对范围查询查询非常有帮助，B树没有将所有叶子节点用链表串联起来的结构，只能用中序遍历来完成范围查询，这会比B+树范围查询涉及多个节点的磁盘I/O操作，一次范围查询的效率不如B+树&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;B+树增删改查效率更加稳定：B+树有大量冗余节点，这些冗余数据可以让B+树在插入、删除的效率都更高，比如删除根节点的时候，不会像B树那样会发生复杂的树的变化。另外，B+树把所有指向数据的指针都放在叶子节点，因此查询、插入、删除数据都需要走到最后一层，这不同于B树可能在任意一层找到数据，所以B+树更为稳定&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;15-为什么索引用b树而不用哈希表&#34;&gt;1.5 为什么索引用B+树？而不用哈希表？&lt;/h3&gt;&#xA;&lt;p&gt;分析：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;哈希表的数据是散列分布的，不具有序性，无法进行范围和排序&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;哈希表存在哈希冲突，哈希冲突严重，也会降低查询效率&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;回答：MySQL会有会多范围和排序的场景，虽然哈希表的搜索时间复杂度是O(1)，但是由于哈希表的数据都是通过哈希函数计算后散列分布的，所以哈希表索引不支持范围和排序操作，不支持联合索引最左匹配原则，如果重复键比较多，还容易操作哈希碰撞导致效率进一步降低。而B+树可以满足这些应用&lt;/p&gt;&#xA;&lt;h3 id=&#34;16聚簇索引和非聚簇索引有什么区别&#34;&gt;1.6聚簇索引和非聚簇索引有什么区别？&lt;/h3&gt;&#xA;&lt;p&gt;分析：先说聚簇索引和非聚簇索引B+树叶子节点存放内容的区别，然后再引出回表查询和覆盖索引查询&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
