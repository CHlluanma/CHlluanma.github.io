<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bitcask on Beautiful Hugo</title>
    <link>https://ahang7.github.io/tags/bitcask/</link>
    <description>Recent content in Bitcask on Beautiful Hugo</description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>ch1447571882@qq.com (ch)</managingEditor>
    <webMaster>ch1447571882@qq.com (ch)</webMaster>
    <lastBuildDate>Thu, 31 Oct 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ahang7.github.io/tags/bitcask/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[kv存储引擎] golang实现</title>
      <link>https://ahang7.github.io/backend-project/bit-db/kv%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Thu, 31 Oct 2024 00:00:00 +0000</pubDate><author>ch1447571882@qq.com (ch)</author>
      <guid>https://ahang7.github.io/backend-project/bit-db/kv%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description>&lt;h2 id=&#34;1-kv基础&#34;&gt;1. KV基础&lt;/h2&gt;&#xA;&lt;p&gt;KV存储，即键值数据存储，是一种基于键值对的存储方式，将数据存储为一个由键和值组成的二元组&lt;/p&gt;&#xA;&lt;p&gt;KC存储的应用场景：作数据库的缓存层、分布式系统中的元数据、分布式锁&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;最常见的KV数据库是Redis，Redis是基于内存的KV数据库，虽有持久化策略AOF和RDB，但是本质上还是面向内存设计的，数据收到内存的限制&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;而本项目&lt;code&gt;go-bitDB&lt;/code&gt;是面向磁盘的KV数据库&lt;/p&gt;&#xA;&lt;p&gt;KV数据库的数据存储模型大致分为两种，一个B+树，一个是LSM树&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;B+树：BolitDB&lt;/li&gt;&#xA;&lt;li&gt;LSM树：LevelDB、RocksDB&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-了解bitcask存储模型&#34;&gt;2. 了解bitcask存储模型&lt;/h2&gt;&#xA;&lt;p&gt;[[bitcask-intro.pdf]]&lt;/p&gt;&#xA;&lt;p&gt;bitcask存储模型是由提供分布式存储系统的企业Riak提出&#xA;对bitcask存储模型的理想：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读写低延迟&lt;/li&gt;&#xA;&lt;li&gt;高吞吐，特别对大量的随机写入&lt;/li&gt;&#xA;&lt;li&gt;能处理超过内存容量的数据&lt;/li&gt;&#xA;&lt;li&gt;崩溃恢复好，保证快速恢复，进来不丢失数据&lt;/li&gt;&#xA;&lt;li&gt;简单的备份和恢复策略&lt;/li&gt;&#xA;&lt;li&gt;相对简单，易懂的代码结构和数据存储格式&lt;/li&gt;&#xA;&lt;li&gt;在大数据量下，性能有保障&lt;/li&gt;&#xA;&lt;li&gt;能够自由使用在Riak系统&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;一个bitcask实例就是系统上的一个目录，并且限制同一时刻只能有一个进程打开这个目录。&#xA;目录中多个文件同一个刻只能有一个活跃的文件用于写入新的数据&lt;/p&gt;&#xA;&lt;p&gt;当活跃文件写到一个阈值后，就会被关闭，成为旧的数据文件，并打开一个新的文件用于写入&#xA;所以一个目录里面就是：一个活跃文件和多个旧文件&lt;/p&gt;&#xA;&lt;p&gt;当前活跃文件的写入是追加(append only)，这表示可以利用顺序IO，不会有多余的磁盘寻址，减少了磁盘寻道实践，最大限度保证吞吐&lt;/p&gt;&#xA;&lt;p&gt;写入文件的数据格式，其字段为&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;crc&lt;/code&gt;：数据校验，防止数据被破环、篡改&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;timestamp&lt;/code&gt;：写入数据的时间戳&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ksz&lt;/code&gt;：key size，key的大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;value_sz&lt;/code&gt;：value size，value的大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;key&lt;/code&gt;：用户实际存储的key&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;value&lt;/code&gt;：用户实际存储的value&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;crc | tstamp | ksz | value_sz | key | value&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次写入都是追加到活跃文件中，删除操作实际上也是一次追加写入&lt;/p&gt;&#xA;&lt;p&gt;当下次merge的时候，才会将这种无效的数据清理。旧数据在merge前将一直存在于磁盘文件中，旧数据的删除操作是新追加一条标识其被删除的记录&lt;/p&gt;&#xA;&lt;p&gt;在追加写入磁盘文件后，更新内存中的数据结构，叫&lt;code&gt;keydir&lt;/code&gt;，实际是全部key的一个集合，存储的是key到一条磁盘文件数据的位置&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;keydir&lt;/code&gt;根据需求可以使用哈希表、B树、跳表等天然支持排序的数据结构&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;key --&amp;gt; file_id | value_sz | value_pos | tstamp&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;key --&amp;gt; file_id | value_sz | value_pos | tstamp&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#x9;......&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;key --&amp;gt; file_id | value_sz | value_pos | tstamp&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;keydir&lt;/code&gt;在内存中存储一条数据在磁盘中的最新位置，旧数据等待merge的时候清理&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
